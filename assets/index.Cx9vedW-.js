var t,e,n,r,s,i,o,a,l,c,d,u,h,p,m,g,f,y,v,w,b,A,S=Object.defineProperty,x=t=>{throw TypeError(t)},k=(t,e,n)=>((t,e,n)=>e in t?S(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n)(t,"symbol"!=typeof e?e+"":e,n),E=(t,e,n)=>e.has(t)?x("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),P=(t,e,n)=>(((t,e,n)=>{e.has(t)||x("Cannot "+n)})(t,e,"access private method"),n);import{g as C,r as I,a as M,d as _,h as T,i as D,p as L,N as F,c as R,b as N,j as q,A as $,D as O,T as K,k as U,l as j,C as V,t as z,f as W,U as B,m as G,n as Q,o as H,q as Y,s as X,u as J}from"./index.BofkdKOa.js";import{a as Z,f as tt,m as et,p as nt}from"./index.CzrOjCaM.js";import{K as rt,R as st,d as it}from"./key.PHAHNoTJ.js";import{A as ot,s as at,T as lt,r as ct,o as dt,p as ut,q as ht,u as pt,v as mt,w as gt,x as ft,m as yt,F as vt,M as wt,y as bt,z as At,t as St,R as xt,B as kt,D as Et,E as Pt,G as Ct,H as It,I as Mt,J as _t,L as Tt,N as Dt,W as Lt,O as Ft,Q as Rt,S as Nt,U as qt,h as $t,i as Ot,V as Kt,X as Ut,e as jt,Y as Vt,Z as zt,_ as Wt,$ as Bt,g as Gt,a as Qt,d as Ht,K as Yt,k as Xt,n as Jt,a0 as Zt,a1 as te,a2 as ee,l as ne}from"./index.8G8SSLdM.js";import{d as re}from"./index.DnnBcP15.js";import{r as se,p as ie,c as oe,m as ae,b as le}from"./scalable-cuckoo-filter.BKNYiDuL.js";import{u as ce,x as de,E as ue,U as he,w as pe,m as me,h as ge,i as fe,k as ye,d as ve,e as we,C as be,l as Ae,a as Se,f as xe,j as ke}from"./message.Ve-2rN-7.js";import{a7 as Ee,g as Pe}from"./mermaid-core.CmyEpniE.js";const Ce=Symbol.for("@libp2p/connection"),Ie=Symbol.for("@libp2p/content-routing"),Me=Symbol.for("@libp2p/peer-discovery"),_e=Symbol.for("@libp2p/peer-routing");function Te(t){if(null!=t[Symbol.asyncIterator])return(async()=>{for await(const e of t);})();for(const e of t);}class De extends Error{constructor(t="The queue was full"){super(t),this.name="QueueFullError"}}k(De,"name","QueueFullError");class Le{constructor(t){var e;k(this,"deferred"),k(this,"signal"),this.signal=t,this.deferred=Promise.withResolvers(),this.onAbort=this.onAbort.bind(this),null==(e=this.signal)||e.addEventListener("abort",this.onAbort)}onAbort(){var t;this.deferred.reject((null==(t=this.signal)?void 0:t.reason)??new ot)}cleanup(){var t;null==(t=this.signal)||t.removeEventListener("abort",this.onAbort)}}class Fe{constructor(t,e){k(this,"id"),k(this,"fn"),k(this,"options"),k(this,"recipients"),k(this,"status"),k(this,"timeline"),k(this,"controller"),this.id=`${parseInt(String(1e9*Math.random()),10).toString()}${Date.now()}`,this.status="queued",this.fn=t,this.options=e,this.recipients=[],this.timeline={created:Date.now()},this.controller=new AbortController,at(1/0,this.controller.signal),this.onAbort=this.onAbort.bind(this)}abort(t){this.controller.abort(t)}onAbort(){this.recipients.reduce((t,e)=>{var n;return t&&!0===(null==(n=e.signal)?void 0:n.aborted)},!0)&&(this.controller.abort(new ot),this.cleanup())}async join(t={}){var e;const n=new Le(t.signal);return this.recipients.push(n),null==(e=t.signal)||e.addEventListener("abort",this.onAbort),n.deferred.promise}async run(){this.status="running",this.timeline.started=Date.now();try{this.controller.signal.throwIfAborted();const t=await se(this.fn({...this.options??{},signal:this.controller.signal}),this.controller.signal);this.recipients.forEach(e=>{e.deferred.resolve(t)}),this.status="complete"}catch(t){this.recipients.forEach(e=>{e.deferred.reject(t)}),this.status="errored"}finally{this.timeline.finished=Date.now(),this.cleanup()}}cleanup(){this.recipients.forEach(t=>{var e;t.cleanup(),null==(e=t.signal)||e.removeEventListener("abort",this.onAbort)})}}function Re(t,e){let n;const r=function(){clearTimeout(n),n=setTimeout(function(){n=void 0,t()},e)};return r.start=()=>{},r.stop=()=>{clearTimeout(n)},r}class Ne extends lt{constructor(t={}){super(),k(this,"concurrency"),k(this,"maxSize"),k(this,"queue"),k(this,"pending"),k(this,"sort"),k(this,"autoStart"),this.concurrency=t.concurrency??Number.POSITIVE_INFINITY,this.maxSize=t.maxSize??Number.POSITIVE_INFINITY,this.pending=0,this.autoStart=t.autoStart??!0,this.sort=t.sort,this.queue=[],this.emitEmpty=Re(this.emitEmpty.bind(this),1),this.emitIdle=Re(this.emitIdle.bind(this),1)}[Symbol.asyncIterator](){return this.toGenerator()}emitEmpty(){0===this.size&&this.safeDispatchEvent("empty")}emitIdle(){0===this.running&&this.safeDispatchEvent("idle")}tryToStartAnother(){if(0===this.size)return this.emitEmpty(),0===this.running&&this.emitIdle(),!1;if(this.pending<this.concurrency){let t;for(const e of this.queue)if("queued"===e.status){t=e;break}return null!=t&&(this.safeDispatchEvent("active"),this.pending++,t.run().finally(()=>{for(let e=0;e<this.queue.length;e++)if(this.queue[e]===t){this.queue.splice(e,1);break}this.pending--,this.safeDispatchEvent("next"),this.autoStart&&this.tryToStartAnother()}),!0)}return!1}enqueue(t){this.queue.push(t),null!=this.sort&&this.queue.sort(this.sort)}start(){!1===this.autoStart&&(this.autoStart=!0,this.tryToStartAnother())}pause(){this.autoStart=!1}async add(t,e){var n;if(null==(n=null==e?void 0:e.signal)||n.throwIfAborted(),this.size===this.maxSize)throw new De;const r=new Fe(t,e);return this.enqueue(r),this.safeDispatchEvent("add"),this.autoStart&&this.tryToStartAnother(),r.join(e).then(t=>(this.safeDispatchEvent("success",{detail:{job:r,result:t}}),t)).catch(t=>{if("queued"===r.status)for(let e=0;e<this.queue.length;e++)if(this.queue[e]===r){this.queue.splice(e,1);break}throw this.safeDispatchEvent("failure",{detail:{job:r,error:t}}),t})}clear(){this.queue.splice(0,this.queue.length)}abort(){this.queue.forEach(t=>{t.abort(new ot)}),this.clear()}async onEmpty(t){0!==this.size&&await ct(this,"empty",null==t?void 0:t.signal)}async onSizeLessThan(t,e){this.size<t||await ct(this,"next",null==e?void 0:e.signal,{filter:()=>this.size<t})}async onIdle(t){0===this.pending&&0===this.size||await ct(this,"idle",null==t?void 0:t.signal)}get size(){return this.queue.length}get queued(){return this.queue.length-this.pending}get running(){return this.pending}async*toGenerator(t){var e,n,r;null==(e=null==t?void 0:t.signal)||e.throwIfAborted();const s=ie({objectMode:!0}),i=t=>{null!=t?this.abort():this.clear(),s.end(t)},o=t=>{null!=t.detail&&s.push(t.detail.result)},a=t=>{i(t.detail.error)},l=()=>{i()},c=()=>{i(new ot("Queue aborted"))};this.addEventListener("success",o),this.addEventListener("failure",a),this.addEventListener("idle",l),null==(n=null==t?void 0:t.signal)||n.addEventListener("abort",c);try{yield*s}finally{this.removeEventListener("success",o),this.removeEventListener("failure",a),this.removeEventListener("idle",l),null==(r=null==t?void 0:t.signal)||r.removeEventListener("abort",c),i()}}}const qe="lock:worker:request-read",$e="lock:worker:abort-read-request",Oe="lock:worker:release-read",Ke="lock:master:grant-read",Ue="lock:master:error-read",je="lock:worker:request-write",Ve="lock:worker:abort-write-request",ze="lock:worker:release-write",We="lock:master:grant-write",Be="lock:master:error-write",Ge="lock:worker:finalize",Qe="mortice",He={singleProcess:!1},Ye=(t,e,n,r,s,i,o,a,l)=>c=>{if(null==c.data)return;const d={type:c.data.type,name:c.data.name,identifier:c.data.identifier};d.type===s&&t.safeDispatchEvent(n,{detail:{name:d.name,identifier:d.identifier,handler:async()=>{e.postMessage({type:l,name:d.name,identifier:d.identifier}),await new Promise(t=>{const n=r=>{if(null==(null==r?void 0:r.data))return;const s=r.data.type,i=(r.data.name,r.data.identifier);s===a&&i===d.identifier&&(e.removeEventListener("message",n),t())};e.addEventListener("message",n)})},onError:t=>{e.postMessage({type:o,name:d.name,identifier:d.identifier,error:{message:t.message,name:t.name,stack:t.stack}})}}}),d.type===i&&t.safeDispatchEvent(r,{detail:{name:d.name,identifier:d.identifier}}),d.type===Ge&&t.safeDispatchEvent("finalizeRequest",{detail:{name:d.name}})};class Xe{constructor(t){k(this,"name"),k(this,"channel"),this.name=t,this.channel=new BroadcastChannel(Qe)}readLock(t){return this.sendRequest(qe,$e,Ke,Ue,Oe,t)}writeLock(t){return this.sendRequest(je,Ve,We,Be,ze,t)}finalize(){this.channel.postMessage({type:Ge,name:this.name}),this.channel.close()}async sendRequest(t,e,n,r,s,i){var o;null==(o=null==i?void 0:i.signal)||o.throwIfAborted();const a=((t=10)=>Math.random().toString().substring(2,t+2))();return this.channel.postMessage({type:t,identifier:a,name:this.name}),new Promise((t,o)=>{var l;const c=()=>{this.channel.postMessage({type:e,identifier:a,name:this.name})};null==(l=null==i?void 0:i.signal)||l.addEventListener("abort",c,{once:!0});const d=e=>{var l,u,h,p;if((null==(l=e.data)?void 0:l.identifier)===a&&((null==(u=e.data)?void 0:u.type)===n&&(this.channel.removeEventListener("message",d),null==(h=null==i?void 0:i.signal)||h.removeEventListener("abort",c),t(()=>{this.channel.postMessage({type:s,identifier:a,name:this.name})})),e.data.type===r)){this.channel.removeEventListener("message",d),null==(p=null==i?void 0:i.signal)||p.removeEventListener("abort",c);const t=new Error;null!=e.data.error&&(t.message=e.data.error.message,t.name=e.data.error.name,t.stack=e.data.error.stack),o(t)}};this.channel.addEventListener("message",d)})}}const Je=new Map;let Ze;function tn(t){return"function"==typeof(null==t?void 0:t.readLock)&&"function"==typeof(null==t?void 0:t.writeLock)}function en(t){if(null==Ze&&(Ze=(t=>{if(t=Object.assign({},He,t),Boolean(globalThis.document)||t.singleProcess){const t=new BroadcastChannel(Qe),e=new lt;return t.addEventListener("message",Ye(e,t,"requestReadLock","abortReadLockRequest",qe,$e,Ue,Oe,Ke)),t.addEventListener("message",Ye(e,t,"requestWriteLock","abortWriteLockRequest",je,Ve,Be,ze,We)),e}return new Xe(t.name)})(t),!tn(Ze))){const t=Ze;t.addEventListener("requestReadLock",e=>{const n=e.detail.name,r=e.detail.identifier,s=Je.get(n);if(null==s)return;const i=new AbortController,o=t=>{t.detail.name===n&&t.detail.identifier===r&&i.abort()};t.addEventListener("abortReadLockRequest",o),s.readLock({signal:i.signal}).then(async t=>{await e.detail.handler().finally(()=>{t()})}).catch(t=>{e.detail.onError(t)}).finally(()=>{t.removeEventListener("abortReadLockRequest",o)})}),t.addEventListener("requestWriteLock",e=>{const n=e.detail.name,r=e.detail.identifier,s=Je.get(n);if(null==s)return;const i=new AbortController,o=t=>{t.detail.name===n&&t.detail.identifier===r&&i.abort()};t.addEventListener("abortWriteLockRequest",o),s.writeLock({signal:i.signal}).then(async t=>{await e.detail.handler().finally(()=>{t()})}).catch(t=>{e.detail.onError(t)}).finally(()=>{t.removeEventListener("abortWriteLockRequest",o)})}),t.addEventListener("finalizeRequest",t=>{const e=t.detail.name,n=Je.get(e);null!=n&&n.finalize()})}return Ze}async function nn(t,e){var n;let r,s;const i=new Promise((t,e)=>{r=t,s=e}),o=()=>{s(new ot)};return null==(n=null==e?void 0:e.signal)||n.addEventListener("abort",o,{once:!0}),t.add(async()=>{await new Promise(t=>{r(()=>{var n;null==(n=null==e?void 0:e.signal)||n.removeEventListener("abort",o),t()})})},{signal:null==e?void 0:e.signal}).catch(t=>{s(t)}),i}const rn={name:"lock",concurrency:1/0,singleProcess:!1,autoFinalize:!1};function sn(t){const e=Object.assign({},rn,t);return((t,e)=>{let n=Je.get(t);if(null!=n)return n;const r=en(e);if(tn(r))return n=r,Je.set(t,n),n;const s=new Ne({concurrency:1});let i;return n={async readLock(t){if(null!=i)return nn(i,t);i=new Ne({concurrency:e.concurrency,autoStart:!1});const n=i,r=nn(i,t);return s.add(async()=>{n.start(),await n.onIdle().then(()=>{i===n&&(i=null)})}),r},writeLock:async t=>(i=null,nn(s,t)),finalize:()=>{Je.delete(t)},queue:s},Je.set(t,n),!0===e.autoFinalize&&s.addEventListener("idle",()=>{n.finalize()},{once:!0}),n})(e.name,e)}const on=class t extends Error{constructor(e="Not Found"){super(e),k(this,"name",t.name),k(this,"code",t.code)}};k(on,"name","NotFoundError"),k(on,"code","ERR_NOT_FOUND");let an=on;function ln(t){if(isNaN(t)||t<=0)throw new C("random bytes length must be a Number bigger than 0");return I(t)}const cn=4194304;class dn extends Error{constructor(){super(...arguments),k(this,"name","InvalidMessageLengthError"),k(this,"code","ERR_INVALID_MSG_LENGTH")}}class un extends Error{constructor(){super(...arguments),k(this,"name","InvalidDataLengthError"),k(this,"code","ERR_MSG_DATA_TOO_LONG")}}class hn extends Error{constructor(){super(...arguments),k(this,"name","InvalidDataLengthLengthError"),k(this,"code","ERR_MSG_LENGTH_TOO_LONG")}}class pn extends Error{constructor(){super(...arguments),k(this,"name","UnexpectedEOFError"),k(this,"code","ERR_UNEXPECTED_EOF")}}function mn(t){return null!=t[Symbol.asyncIterator]}function gn(t,e){if(t.byteLength>e)throw new un("Message length too long")}const fn=t=>{const e=ce(t),n=ue(e);return de(t,n),fn.bytes=e,n};function yn(t,e){const n=(e=e??{}).lengthEncoder??fn,r=(null==e?void 0:e.maxDataLength)??cn;function*s(t){gn(t,r);const e=n(t.byteLength);e instanceof Uint8Array?yield e:yield*e,t instanceof Uint8Array?yield t:yield*t}return mn(t)?async function*(){for await(const e of t)yield*s(e)}():function*(){for(const e of t)yield*s(e)}()}var vn,wn;fn.bytes=0,yn.single=(t,e)=>{const n=(e=e??{}).lengthEncoder??fn;return gn(t,(null==e?void 0:e.maxDataLength)??cn),new he(n(t.byteLength),t)},(wn=vn||(vn={}))[wn.LENGTH=0]="LENGTH",wn[wn.DATA=1]="DATA";const bn=t=>{const e=pe(t);return bn.bytes=ce(e),e};function An(t,e){const n=new he;let r=vn.LENGTH,s=-1;const i=(null==e?void 0:e.lengthDecoder)??bn,o=(null==e?void 0:e.maxLengthLength)??8,a=(null==e?void 0:e.maxDataLength)??cn;function*l(){for(;n.byteLength>0;){if(r===vn.LENGTH)try{if(s=i(n),s<0)throw new dn("Invalid message length");if(s>a)throw new un("Message length too long");const t=i.bytes;n.consume(t),null!=(null==e?void 0:e.onLength)&&e.onLength(s),r=vn.DATA}catch(t){if(t instanceof RangeError){if(n.byteLength>o)throw new hn("Message length length too long");break}throw t}if(r===vn.DATA){if(n.byteLength<s)break;const t=n.sublist(0,s);n.consume(s),null!=(null==e?void 0:e.onData)&&e.onData(t),yield t,r=vn.LENGTH}}}return mn(t)?async function*(){for await(const e of t)n.append(e),yield*l();if(n.byteLength>0)throw new pn("Unexpected end of input")}():function*(){for(const e of t)n.append(e),yield*l();if(n.byteLength>0)throw new pn("Unexpected end of input")}()}function Sn(t,e){return null!=t[Symbol.asyncIterator]?async function*(){let n=0;if(!(e<1))for await(const r of t)if(yield r,n++,n===e)return}():function*(){let n=0;if(!(e<1))for(const r of t)if(yield r,n++,n===e)return}()}bn.bytes=0,An.fromReader=(t,e)=>{let n=1;return An(async function*(){for(;;)try{const{done:e,value:r}=await t.next(n);if(!0===e)return;null!=r&&(yield r)}catch(e){if("ERR_UNDER_READ"===e.code)return{done:!0,value:null};throw e}finally{n=1}}(),{...e??{},onLength:t=>{n=t}})};class xn{constructor(t){if(k(this,"set"),this.set=new Set,null!=t)for(const e of t)this.set.add(e.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(t){this.set.add(t.toString())}clear(){this.set.clear()}delete(t){this.set.delete(t.toString())}entries(){return dt(this.set.entries(),t=>{const e=ut(t[0]);return[e,e]})}forEach(t){this.set.forEach(e=>{const n=ut(e);t(n,n,this)})}has(t){return this.set.has(t.toString())}values(){return dt(this.set.values(),t=>ut(t))}intersection(t){const e=new xn;for(const n of t)this.has(n)&&e.add(n);return e}difference(t){const e=new xn;for(const n of this)t.has(n)||e.add(n);return e}union(t){const e=new xn;for(const n of t)e.add(n);for(const n of this)e.add(n);return e}}function kn(){return new xn}class En extends Map{constructor(t){super(),k(this,"metric");const{name:e,metrics:n}=t;this.metric=n.registerMetric(e),this.updateComponentMetric()}set(t,e){return super.set(t,e),this.updateComponentMetric(),this}delete(t){const e=super.delete(t);return this.updateComponentMetric(),e}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function Pn(t){const{name:e,metrics:n}=t;let r;return r=null!=n?new En({name:e,metrics:n}):new Map,r}const Cn=4,In=16,Mn=new Uint8Array([0,0,0,0,0,0,0,0,0,0,255,255]);function _n(t,e){e.length===In&&t.length===Cn&&function(t,e,n){let r=0;for(const s of t)if(!(r<e)){if(r>n)break;if(255!==s)return!1;r++}return!0}(e,0,11)&&(e=e.slice(12)),e.length===Cn&&t.length===In&&function(t,e,n,r){let s=0;for(const i of t)if(!(s<n)){if(s>r)break;if(i!==e[s])return!1;s++}return!0}(t,Mn,0,11)&&(t=t.slice(12));const n=t.length;if(n!=e.length)throw new Error("Failed to mask ip");const r=new Uint8Array(n);for(let s=0;s<n;s++)r[s]=t[s]&e[s];return r}function Tn(t,e){if(e!==8*Cn&&e!==8*In)throw new Error("Invalid CIDR mask");if(t<0||t>e)throw new Error("Invalid CIDR mask");const n=e/8,r=new Uint8Array(n);for(let s=0;s<n;s++)t>=8?(r[s]=255,t-=8):(r[s]=255-(255>>t),t=0);return r}class Dn{constructor(t,e){if(null==e)({network:this.network,mask:this.mask}=function(t){const[e,n]=t.split("/");if(!e||!n)throw new Error("Failed to parse given CIDR: "+t);let r=Cn,s=pt(e);if(null==s&&(r=In,s=mt(e),null==s))throw new Error("Failed to parse given CIDR: "+t);const i=parseInt(n,10);if(Number.isNaN(i)||String(i).length!==n.length||i<0||i>8*r)throw new Error("Failed to parse given CIDR: "+t);const o=Tn(i,8*r);return{network:_n(s,o),mask:o}}(t));else{const n=ht(t);if(null==n)throw new Error("Failed to parse network");e=String(e);const r=parseInt(e,10);if(Number.isNaN(r)||String(r).length!==e.length||r<0||r>8*n.length){const t=ht(e);if(null==t)throw new Error("Failed to parse mask");this.mask=t}else this.mask=Tn(r,8*n.length);this.network=_n(n,this.mask)}}contains(t){return function(t,e){if("string"==typeof e&&(e=ht(e)),null==e)throw new Error("Invalid ip");if(e.length!==t.network.length)return!1;for(let n=0;n<e.length;n++)if((t.network[n]&t.mask[n])!==(e[n]&t.mask[n]))return!1;return!0}({network:this.network,mask:this.mask},t)}toString(){const t=function(t){let e=0;for(let[n,r]of t.entries()){if(255!==r){for(;128&r;)e++,r<<=1;if(128&r)return-1;for(let e=n+1;e<t.length;e++)if(0!=t[e])return-1;break}e+=8}return e}(this.mask),e=-1!==t?String(t):function(t){let e="0x";for(const n of t)e+=(n>>4).toString(16)+(15&n).toString(16);return e}(this.mask);return function(t){switch(t.length){case Cn:return t.join(".");case In:{const e=[];for(let n=0;n<t.length;n++)n%2==0&&e.push(t[n].toString(16).padStart(2,"0")+t[n+1].toString(16).padStart(2,"0"));return e.join(":")}default:throw new Error("Invalid ip length")}}(this.network)+"/"+e}}var Ln;(function(){var t,e,n,r,s,i,o,a;a=function(t){return[(t&255<<24)>>>24,(t&255<<16)>>>16,(65280&t)>>>8,255&t].join(".")},o=function(t){var n,r,s,i,o,a;for(n=[],s=i=0;i<=3&&0!==t.length;s=++i){if(s>0){if("."!==t[0])throw new Error("Invalid IP");t=t.substring(1)}o=(a=e(t))[0],r=a[1],t=t.substring(r),n.push(o)}if(0!==t.length)throw new Error("Invalid IP");switch(n.length){case 1:if(n[0]>4294967295)throw new Error("Invalid IP");return n[0]>>>0;case 2:if(n[0]>255||n[1]>16777215)throw new Error("Invalid IP");return(n[0]<<24|n[1])>>>0;case 3:if(n[0]>255||n[1]>255||n[2]>65535)throw new Error("Invalid IP");return(n[0]<<24|n[1]<<16|n[2])>>>0;case 4:if(n[0]>255||n[1]>255||n[2]>255||n[3]>255)throw new Error("Invalid IP");return(n[0]<<24|n[1]<<16|n[2]<<8|n[3])>>>0;default:throw new Error("Invalid IP")}},r=(n=function(t){return t.charCodeAt(0)})("0"),i=n("a"),s=n("A"),e=function(t){var e,o,a,l,c;for(l=0,e=10,o="9",a=0,t.length>1&&"0"===t[a]&&("x"===t[a+1]||"X"===t[a+1]?(a+=2,e=16):"0"<=t[a+1]&&t[a+1]<="9"&&(a++,e=8,o="7")),c=a;a<t.length;){if("0"<=t[a]&&t[a]<=o)l=l*e+(n(t[a])-r)>>>0;else{if(16!==e)break;if("a"<=t[a]&&t[a]<="f")l=l*e+(10+n(t[a])-i)>>>0;else{if(!("A"<=t[a]&&t[a]<="F"))break;l=l*e+(10+n(t[a])-s)>>>0}}if(l>4294967295)throw new Error("too large");a++}if(a===c)throw new Error("empty octet");return[l,a]},t=function(){function t(t,e){var n,r,s;if("string"!=typeof t)throw new Error("Missing `net' parameter");if(e||(s=t.split("/",2),t=s[0],e=s[1]),e||(e=32),"string"==typeof e&&e.indexOf(".")>-1){try{this.maskLong=o(e)}catch(i){throw new Error("Invalid mask: "+e)}for(n=r=32;r>=0;n=--r)if(this.maskLong===4294967295<<32-n>>>0){this.bitmask=n;break}}else{if(!e&&0!==e)throw new Error("Invalid mask: empty");this.bitmask=parseInt(e,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0)}try{this.netLong=(o(t)&this.maskLong)>>>0}catch(i){throw new Error("Invalid net address: "+t)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+e);this.size=Math.pow(2,32-this.bitmask),this.base=a(this.netLong),this.mask=a(this.maskLong),this.hostmask=a(~this.maskLong),this.first=this.bitmask<=30?a(this.netLong+1):this.base,this.last=this.bitmask<=30?a(this.netLong+this.size-2):a(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?a(this.netLong+this.size-1):void 0}return t.prototype.contains=function(e){return"string"==typeof e&&(e.indexOf("/")>0||4!==e.split(".").length)&&(e=new t(e)),e instanceof t?this.contains(e.base)&&this.contains(e.broadcast||e.last):(o(e)&this.maskLong)>>>0==(this.netLong&this.maskLong)>>>0},t.prototype.next=function(e){return null==e&&(e=1),new t(a(this.netLong+this.size*e),this.mask)},t.prototype.forEach=function(t){var e,n,r;for(r=o(this.first),n=o(this.last),e=0;r<=n;)t(a(r),r,e),e++,r++},t.prototype.toString=function(){return this.base+"/"+this.bitmask},t}(),Ln=t}).call(Ee);const Fn=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"].map(t=>new Ln(t));function Rn(t){for(const e of Fn)if(e.contains(t))return!0;return!1}function Nn(t){return gt(t)?Rn(t):/^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(t)?function(t){const e=t.split(":");if(e.length<2)return!1;const n=e[e.length-1].padStart(4,"0"),r=e[e.length-2].padStart(4,"0");return Rn(`${parseInt(r.substring(0,2),16)}.${parseInt(r.substring(2),16)}.${parseInt(n.substring(0,2),16)}.${parseInt(n.substring(2),16)}`)}(t):function(t){return/^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(t)}(t)?function(t){const e=t.split(":");return Rn(e[e.length-1])}(t):ft(t)?function(t){return/^::$/.test(t)||/^::1$/.test(t)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(t)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(t)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(t)||/^ff([0-9a-fA-F]{2,2}):/i.test(t)}(t):void 0}function qn(t,e){return null!=t[Symbol.asyncIterator]?async function*(){const n=await Z(t);yield*n.sort(e)}():function*(){const n=Z(t);yield*n.sort(e)}()}class $n{put(t,e,n){return Promise.reject(new Error(".put is not implemented"))}get(t,e){return Promise.reject(new Error(".get is not implemented"))}has(t,e){return Promise.reject(new Error(".has is not implemented"))}delete(t,e){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(t,e={}){for await(const{key:n,value:r}of t)await this.put(n,r,e),yield n}async*getMany(t,e={}){for await(const n of t)yield{key:n,value:await this.get(n,e)}}async*deleteMany(t,e={}){for await(const n of t)await this.delete(n,e),yield n}batch(){let t=[],e=[];return{put(e,n){t.push({key:e,value:n})},delete(t){e.push(t)},commit:async n=>{await Te(this.putMany(t,n)),t=[],await Te(this.deleteMany(e,n)),e=[]}}}async*_all(t,e){throw new Error("._all is not implemented")}async*_allKeys(t,e){throw new Error("._allKeys is not implemented")}query(t,e){let n=this._all(t,e);if(null!=t.prefix){const e=t.prefix;n=tt(n,t=>t.key.toString().startsWith(e))}if(Array.isArray(t.filters)&&(n=t.filters.reduce((t,e)=>tt(t,e),n)),Array.isArray(t.orders)&&(n=t.orders.reduce((t,e)=>qn(t,e),n)),null!=t.offset){let e=0;const r=t.offset;n=tt(n,()=>e++>=r)}return null!=t.limit&&(n=Sn(n,t.limit)),n}queryKeys(t,e){let n=this._allKeys(t,e);if(null!=t.prefix){const e=t.prefix;n=tt(n,t=>t.toString().startsWith(e))}if(Array.isArray(t.filters)&&(n=t.filters.reduce((t,e)=>tt(t,e),n)),Array.isArray(t.orders)&&(n=t.orders.reduce((t,e)=>qn(t,e),n)),null!=t.offset){const e=t.offset;let r=0;n=tt(n,()=>r++>=e)}return null!=t.limit&&(n=Sn(n,t.limit)),n}}class On extends $n{constructor(){super(),k(this,"data"),this.data=new Map}put(t,e,n){var r;return null==(r=null==n?void 0:n.signal)||r.throwIfAborted(),this.data.set(t.toString(),e),t}get(t,e){var n;null==(n=null==e?void 0:e.signal)||n.throwIfAborted();const r=this.data.get(t.toString());if(null==r)throw new an;return r}has(t,e){var n;return null==(n=null==e?void 0:e.signal)||n.throwIfAborted(),this.data.has(t.toString())}delete(t,e){var n;null==(n=null==e?void 0:e.signal)||n.throwIfAborted(),this.data.delete(t.toString())}*_all(t,e){var n,r;null==(n=null==e?void 0:e.signal)||n.throwIfAborted();for(const[s,i]of this.data.entries())yield{key:new rt(s),value:i},null==(r=null==e?void 0:e.signal)||r.throwIfAborted()}*_allKeys(t,e){var n,r;null==(n=null==e?void 0:e.signal)||n.throwIfAborted();for(const s of this.data.keys())yield new rt(s),null==(r=null==e?void 0:e.signal)||r.throwIfAborted()}}const Kn=new class{constructor(){k(this,"dns")}canResolve(t){return t.getComponents().some(({name:t})=>"dnsaddr"===t)}async resolve(t,e){var n,r;const s=null==(n=t.getComponents().find(t=>"dnsaddr"===t.name))?void 0:n.value;if(null==s)return[t];const i=this.getDNS(e),o=await i.query(`_dnsaddr.${s}`,{signal:null==e?void 0:e.signal,types:[st.TXT]}),a=null==(r=t.getComponents().find(t=>"p2p"===t.name))?void 0:r.value,l=[];for(const c of o.Answer){const t=c.data.replace(/["']/g,"").trim().split("=")[1];null!=t&&((null==a||t.includes(a))&&l.push(yt(t)))}return l}getDNS(t){return null!=t.dns?t.dns:(null==this.dns&&(this.dns=it()),this.dns)}},Un={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:t=>t},connectionManager:{resolvers:{dnsaddr:Kn}},transportManager:{faultTolerance:vt.FATAL_ALL}};async function jn(t){var e,n;const r=et(Un,t);if(null===r.connectionProtector&&null!=(null==(n=null==(e=globalThis.process)?void 0:e.env)?void 0:n.LIBP2P_FORCE_PNET))throw new C("Private network is enforced, but no protector was provided");return r}const Vn=Uint8Array.from([3,1]);var zn;!function(t){let e;!function(t){let e;t.codec=()=>(null==e&&(e=me((t,e,n={})=>{!1!==n.lengthDelimited&&e.fork(),null!=t.multiaddr&&t.multiaddr.byteLength>0&&(e.uint32(10),e.bytes(t.multiaddr)),!1!==n.lengthDelimited&&e.ldelim()},(t,e,n={})=>{const r={multiaddr:ye(0)},s=null==e?t.len:t.pos+e;for(;t.pos<s;){const e=t.uint32();if(e>>>3==1)r.multiaddr=t.bytes();else t.skipType(7&e)}return r})),e),t.encode=e=>ge(e,t.codec()),t.decode=(e,n)=>fe(e,t.codec(),n)}(t.AddressInfo||(t.AddressInfo={})),t.codec=()=>(null==e&&(e=me((e,n,r={})=>{if(!1!==r.lengthDelimited&&n.fork(),null!=e.peerId&&e.peerId.byteLength>0&&(n.uint32(10),n.bytes(e.peerId)),null!=e.seq&&0n!==e.seq&&(n.uint32(16),n.uint64(e.seq)),null!=e.addresses)for(const s of e.addresses)n.uint32(26),t.AddressInfo.codec().encode(s,n);!1!==r.lengthDelimited&&n.ldelim()},(e,n,r={})=>{var s,i;const o={peerId:ye(0),seq:0n,addresses:[]},a=null==n?e.len:e.pos+n;for(;e.pos<a;){const n=e.uint32();switch(n>>>3){case 1:o.peerId=e.bytes();break;case 2:o.seq=e.uint64();break;case 3:if(null!=(null==(s=r.limits)?void 0:s.addresses)&&o.addresses.length===r.limits.addresses)throw new wt('Decode error - map field "addresses" had too many elements');o.addresses.push(t.AddressInfo.codec().decode(e,e.uint32(),{limits:null==(i=r.limits)?void 0:i.addresses$}));break;default:e.skipType(7&n)}}return o})),e),t.encode=e=>ge(e,t.codec()),t.decode=(e,n)=>fe(e,t.codec(),n)}(zn||(zn={}));const Wn=class t{constructor(e){k(this,"peerId"),k(this,"multiaddrs"),k(this,"seqNumber"),k(this,"domain",t.DOMAIN),k(this,"codec",t.CODEC),k(this,"marshaled");const{peerId:n,multiaddrs:r,seqNumber:s}=e;this.peerId=n,this.multiaddrs=r??[],this.seqNumber=s??BigInt(Date.now())}marshal(){return null==this.marshaled&&(this.marshaled=zn.encode({peerId:this.peerId.toMultihash().bytes,seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(t=>({multiaddr:t.bytes}))})),this.marshaled}equals(e){return e instanceof t&&(!!this.peerId.equals(e.peerId)&&(this.seqNumber===e.seqNumber&&!!function(t,e){const n=(t,e)=>t.toString().localeCompare(e.toString());return t.length===e.length&&(e.sort(n),t.sort(n).every((t,n)=>e[n].equals(t)))}(this.multiaddrs,e.multiaddrs)))}};k(Wn,"createFromProtobuf",t=>{const e=zn.decode(t),n=M(ve(e.peerId)),r=(e.addresses??[]).map(t=>yt(t.multiaddr)),s=e.seq;return new Wn({peerId:n,multiaddrs:r,seqNumber:s})}),k(Wn,"DOMAIN","libp2p-peer-record"),k(Wn,"CODEC",Vn);let Bn=Wn;var Gn,Qn,Hn;function Yn(t,e){if(null!=t.publicKey||null==e.publicKey)return t;let n;"RSA"===t.type&&(n=t.toMultihash());const r=_(e.publicKey,n);return T(r)}function Xn(t,e,n){const r=new Map,s=BigInt(Date.now());for(const[i,o]of e.tags.entries())null!=o.expiry&&o.expiry<s||r.set(i,o);return{...e,id:Yn(t,e),addresses:e.addresses.filter(({observed:t})=>null!=t&&t>Date.now()-n).map(({multiaddr:t,isCertified:e})=>({multiaddr:yt(t),isCertified:e??!1})),metadata:e.metadata,peerRecordEnvelope:e.peerRecordEnvelope??void 0,tags:r}}function Jn(t,e){return d=t.addresses,u=e.addresses,tr(d,u,(t,e)=>t.isCertified===e.isCertified&&!!we(t.multiaddr,e.multiaddr))&&(l=t.protocols,c=e.protocols,tr(l,c,(t,e)=>t===e))&&(o=t.publicKey,a=e.publicKey,Zn(o,a))&&(s=t.peerRecordEnvelope,i=e.peerRecordEnvelope,Zn(s,i))&&(n=t.metadata,r=e.metadata,er(n,r,(t,e)=>we(t,e)))&&function(t,e){return er(t,e,(t,e)=>t.value===e.value&&t.expiry===e.expiry)}(t.tags,e.tags);var n,r,s,i,o,a,l,c,d,u}function Zn(t,e){return null==t&&null==e||null!=t&&null!=e&&we(t,e)}function tr(t,e,n){if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(!n(t[r],e[r]))return!1;return!0}function er(t,e,n){if(t.size!==e.size)return!1;for(const[r,s]of t.entries()){const t=e.get(r);if(null==t)return!1;if(!n(s,t))return!1}return!0}!function(t){let e;!function(t){let e;t.codec=()=>(null==e&&(e=me((t,e,n={})=>{!1!==n.lengthDelimited&&e.fork(),null!=t.key&&""!==t.key&&(e.uint32(10),e.string(t.key)),null!=t.value&&t.value.byteLength>0&&(e.uint32(18),e.bytes(t.value)),!1!==n.lengthDelimited&&e.ldelim()},(t,e,n={})=>{const r={key:"",value:ye(0)},s=null==e?t.len:t.pos+e;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:r.key=t.string();break;case 2:r.value=t.bytes();break;default:t.skipType(7&e)}}return r})),e),t.encode=e=>ge(e,t.codec()),t.decode=(e,n)=>fe(e,t.codec(),n)}(t.Peer$metadataEntry||(t.Peer$metadataEntry={})),function(t){let e;t.codec=()=>(null==e&&(e=me((t,e,n={})=>{!1!==n.lengthDelimited&&e.fork(),null!=t.key&&""!==t.key&&(e.uint32(10),e.string(t.key)),null!=t.value&&(e.uint32(18),Hn.codec().encode(t.value,e)),!1!==n.lengthDelimited&&e.ldelim()},(t,e,n={})=>{var r;const s={key:""},i=null==e?t.len:t.pos+e;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:s.key=t.string();break;case 2:s.value=Hn.codec().decode(t,t.uint32(),{limits:null==(r=n.limits)?void 0:r.value});break;default:t.skipType(7&e)}}return s})),e),t.encode=e=>ge(e,t.codec()),t.decode=(e,n)=>fe(e,t.codec(),n)}(t.Peer$tagsEntry||(t.Peer$tagsEntry={})),t.codec=()=>(null==e&&(e=me((e,n,r={})=>{if(!1!==r.lengthDelimited&&n.fork(),null!=e.addresses)for(const t of e.addresses)n.uint32(10),Qn.codec().encode(t,n);if(null!=e.protocols)for(const t of e.protocols)n.uint32(18),n.string(t);if(null!=e.publicKey&&(n.uint32(34),n.bytes(e.publicKey)),null!=e.peerRecordEnvelope&&(n.uint32(42),n.bytes(e.peerRecordEnvelope)),null!=e.metadata&&0!==e.metadata.size)for(const[s,i]of e.metadata.entries())n.uint32(50),t.Peer$metadataEntry.codec().encode({key:s,value:i},n);if(null!=e.tags&&0!==e.tags.size)for(const[s,i]of e.tags.entries())n.uint32(58),t.Peer$tagsEntry.codec().encode({key:s,value:i},n);null!=e.updated&&(n.uint32(64),n.uint64Number(e.updated)),!1!==r.lengthDelimited&&n.ldelim()},(e,n,r={})=>{var s,i,o,a,l,c;const d={addresses:[],protocols:[],metadata:new Map,tags:new Map},u=null==n?e.len:e.pos+n;for(;e.pos<u;){const n=e.uint32();switch(n>>>3){case 1:if(null!=(null==(s=r.limits)?void 0:s.addresses)&&d.addresses.length===r.limits.addresses)throw new wt('Decode error - map field "addresses" had too many elements');d.addresses.push(Qn.codec().decode(e,e.uint32(),{limits:null==(i=r.limits)?void 0:i.addresses$}));break;case 2:if(null!=(null==(o=r.limits)?void 0:o.protocols)&&d.protocols.length===r.limits.protocols)throw new wt('Decode error - map field "protocols" had too many elements');d.protocols.push(e.string());break;case 4:d.publicKey=e.bytes();break;case 5:d.peerRecordEnvelope=e.bytes();break;case 6:{if(null!=(null==(a=r.limits)?void 0:a.metadata)&&d.metadata.size===r.limits.metadata)throw new bt('Decode error - map field "metadata" had too many elements');const n=t.Peer$metadataEntry.codec().decode(e,e.uint32());d.metadata.set(n.key,n.value);break}case 7:{if(null!=(null==(l=r.limits)?void 0:l.tags)&&d.tags.size===r.limits.tags)throw new bt('Decode error - map field "tags" had too many elements');const n=t.Peer$tagsEntry.codec().decode(e,e.uint32(),{limits:{value:null==(c=r.limits)?void 0:c.tags$value}});d.tags.set(n.key,n.value);break}case 8:d.updated=e.uint64Number();break;default:e.skipType(7&n)}}return d})),e),t.encode=e=>ge(e,t.codec()),t.decode=(e,n)=>fe(e,t.codec(),n)}(Gn||(Gn={})),function(t){let e;t.codec=()=>(null==e&&(e=me((t,e,n={})=>{!1!==n.lengthDelimited&&e.fork(),null!=t.multiaddr&&t.multiaddr.byteLength>0&&(e.uint32(10),e.bytes(t.multiaddr)),null!=t.isCertified&&(e.uint32(16),e.bool(t.isCertified)),null!=t.observed&&(e.uint32(24),e.uint64Number(t.observed)),!1!==n.lengthDelimited&&e.ldelim()},(t,e,n={})=>{const r={multiaddr:ye(0)},s=null==e?t.len:t.pos+e;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:r.multiaddr=t.bytes();break;case 2:r.isCertified=t.bool();break;case 3:r.observed=t.uint64Number();break;default:t.skipType(7&e)}}return r})),e),t.encode=e=>ge(e,t.codec()),t.decode=(e,n)=>fe(e,t.codec(),n)}(Qn||(Qn={})),function(t){let e;t.codec=()=>(null==e&&(e=me((t,e,n={})=>{!1!==n.lengthDelimited&&e.fork(),null!=t.value&&0!==t.value&&(e.uint32(8),e.uint32(t.value)),null!=t.expiry&&(e.uint32(16),e.uint64(t.expiry)),!1!==n.lengthDelimited&&e.ldelim()},(t,e,n={})=>{const r={value:0},s=null==e?t.len:t.pos+e;for(;t.pos<s;){const e=t.uint32();switch(e>>>3){case 1:r.value=t.uint32();break;case 2:r.expiry=t.uint64();break;default:t.skipType(7&e)}}return r})),e),t.encode=e=>ge(e,t.codec()),t.decode=(e,n)=>fe(e,t.codec(),n)}(Hn||(Hn={}));const nr="/peers/";function rr(t){if(!D(t)||null==t.type)throw new C("Invalid PeerId");const e=t.toCID().toString();return new rt(`${nr}${e}`)}async function sr(t,e,n,r,s){const i=new Map;for(const o of n){if(null==o)continue;if(o.multiaddr instanceof Uint8Array&&(o.multiaddr=yt(o.multiaddr)),!At(o.multiaddr))throw new C("Multiaddr was invalid");if(!(await e(t,o.multiaddr,s)))continue;const n=o.isCertified??!1,r=o.multiaddr.toString(),a=i.get(r);null!=a?o.isCertified=a.isCertified||n:i.set(r,{multiaddr:o.multiaddr,isCertified:n})}return[...i.values()].sort((t,e)=>t.multiaddr.toString().localeCompare(e.multiaddr.toString())).map(({isCertified:e,multiaddr:n})=>{const r=n.getPeerId();return t.equals(r)&&(n=n.decapsulate(yt(`/p2p/${t}`))),{isCertified:e,multiaddr:n.bytes}})}async function ir(t,e,n,r){var s,i;if(null==e)throw new C("Invalid PeerData");if(null!=e.publicKey&&null!=t.publicKey&&!e.publicKey.equals(t.publicKey))throw new C("publicKey bytes do not match peer id publicKey bytes");const o=null==(s=r.existingPeer)?void 0:s.peer;if(null!=o&&!t.equals(o.id))throw new C("peer id did not match existing peer id");let a,l=(null==o?void 0:o.addresses)??[],c=new Set((null==o?void 0:o.protocols)??[]),d=(null==o?void 0:o.metadata)??new Map,u=(null==o?void 0:o.tags)??new Map,h=null==o?void 0:o.peerRecordEnvelope;if("patch"===n){if(null==e.multiaddrs&&null==e.addresses||(l=[],null!=e.multiaddrs&&l.push(...e.multiaddrs.map(t=>({isCertified:!1,multiaddr:t}))),null!=e.addresses&&l.push(...e.addresses)),null!=e.protocols&&(c=new Set(e.protocols)),null!=e.metadata){d=or(e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata),{validate:ar})}if(null!=e.tags){u=or(e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),{validate:lr,map:cr})}null!=e.peerRecordEnvelope&&(h=e.peerRecordEnvelope)}if("merge"===n){if(null!=e.multiaddrs&&l.push(...e.multiaddrs.map(t=>({isCertified:!1,multiaddr:t}))),null!=e.addresses&&l.push(...e.addresses),null!=e.protocols&&(c=new Set([...c,...e.protocols])),null!=e.metadata){const t=e.metadata instanceof Map?[...e.metadata.entries()]:Object.entries(e.metadata);for(const[e,n]of t)null==n?d.delete(e):d.set(e,n);d=or([...d.entries()],{validate:ar})}if(null!=e.tags){const t=e.tags instanceof Map?[...e.tags.entries()]:Object.entries(e.tags),n=new Map(u);for(const[e,r]of t)null==r?n.delete(e):n.set(e,r);u=or([...n.entries()],{validate:lr,map:cr})}null!=e.peerRecordEnvelope&&(h=e.peerRecordEnvelope)}null!=(null==o?void 0:o.id.publicKey)?a=L(o.id.publicKey):null!=e.publicKey?a=L(e.publicKey):null!=t.publicKey&&(a=L(t.publicKey));const p={addresses:await sr(t,r.addressFilter??(async()=>!0),l,null==(i=r.existingPeer)||i.peerPB.addresses,r),protocols:[...c.values()].sort((t,e)=>t.localeCompare(e)),metadata:d,tags:u,publicKey:a,peerRecordEnvelope:h};return p.addresses.forEach(t=>{var e,n,s;t.observed=(null==(s=null==(n=null==(e=r.existingPeer)?void 0:e.peerPB.addresses)?void 0:n.find(t=>we(t.multiaddr,t.multiaddr)))?void 0:s.observed)??Date.now()}),"RSA"!==t.type&&delete p.publicKey,p}function or(t,e){var n;const r=new Map;for(const[s,i]of t)null!=i&&e.validate(s,i);for(const[s,i]of t.sort(([t],[e])=>t.localeCompare(e)))null!=i&&r.set(s,(null==(n=e.map)?void 0:n.call(e,s,i))??i);return r}function ar(t,e){if("string"!=typeof t)throw new C("Metadata key must be a string");if(!(e instanceof Uint8Array))throw new C("Metadata value must be a Uint8Array")}function lr(t,e){if("string"!=typeof t)throw new C("Tag name must be a string");if(null!=e.value){if(parseInt(`${e.value}`,10)!==e.value)throw new C("Tag value must be an integer");if(e.value<0||e.value>100)throw new C("Tag value must be between 0-100")}if(null!=e.ttl){if(parseInt(`${e.ttl}`,10)!==e.ttl)throw new C("Tag ttl must be an integer");if(e.ttl<0)throw new C("Tag ttl must be between greater than 0")}}function cr(t,e){let n;null!=e.expiry&&(n=e.expiry),null!=e.ttl&&(n=BigInt(Date.now()+Number(e.ttl)));const r={value:e.value??0};return null!=n&&(r.expiry=n),r}function dr(t){const e=t.toString().split("/")[2],n=be.parse(e,Ae);return R(n)}function ur(t,e,n){return function(t,e,n){return Xn(t,Gn.decode(e),n)}(dr(t),e,n)}class hr{constructor(e,n={}){E(this,t),k(this,"peerId"),k(this,"datastore"),k(this,"locks"),k(this,"addressFilter"),k(this,"log"),k(this,"maxAddressAge"),k(this,"maxPeerAge"),this.log=e.logger.forComponent("libp2p:peer-store"),this.peerId=e.peerId,this.datastore=e.datastore,this.addressFilter=n.addressFilter,this.locks=St({name:"libp2p_peer_store_locks",metrics:e.metrics}),this.maxAddressAge=n.maxAddressAge??36e5,this.maxPeerAge=n.maxPeerAge??216e5}getLock(t){let e=this.locks.get(t);return null==e&&(e={refs:0,lock:sn({name:t.toString(),singleProcess:!0})},this.locks.set(t,e)),e.refs++,e}maybeRemoveLock(t,e){e.refs--,0===e.refs&&(e.lock.finalize(),this.locks.delete(t))}async getReadLock(t,e){const n=this.getLock(t);try{const r=await n.lock.readLock(e);return()=>{r(),this.maybeRemoveLock(t,n)}}catch(r){throw this.maybeRemoveLock(t,n),r}}async getWriteLock(t,e){const n=this.getLock(t);try{const r=await n.lock.writeLock(e);return()=>{r(),this.maybeRemoveLock(t,n)}}catch(r){throw this.maybeRemoveLock(t,n),r}}async has(t,e){try{return await this.load(t,e),!0}catch(n){if("NotFoundError"!==n.name)throw n}return!1}async delete(t,e){this.peerId.equals(t)||await this.datastore.delete(rr(t),e)}async load(e,n){const s=rr(e),i=await this.datastore.get(s,n),o=Gn.decode(i);if(P(this,t,r).call(this,e,o))throw await this.datastore.delete(s,n),new F;return Xn(e,o,this.peerId.equals(e)?1/0:this.maxAddressAge)}async save(r,s,i){const o=await P(this,t,e).call(this,r,i),a=await ir(r,s,"patch",{...i,addressFilter:this.addressFilter});return P(this,t,n).call(this,r,a,o)}async patch(r,s,i){const o=await P(this,t,e).call(this,r,i),a=await ir(r,s,"patch",{...i,addressFilter:this.addressFilter,existingPeer:o});return P(this,t,n).call(this,r,a,o)}async merge(r,s,i){const o=await P(this,t,e).call(this,r,i),a=await ir(r,s,"merge",{addressFilter:this.addressFilter,existingPeer:o});return P(this,t,n).call(this,r,a,o)}async*all(e){for await(const{key:n,value:s}of this.datastore.query(function(t,e){return{prefix:nr,filters:(t.filters??[]).map(t=>({key:n,value:r})=>t(ur(n,r,e))),orders:(t.orders??[]).map(t=>(n,r)=>t(ur(n.key,n.value,e),ur(r.key,r.value,e)))}}(e??{},this.maxAddressAge),e)){const i=dr(n);if(i.equals(this.peerId))continue;const o=Gn.decode(s);P(this,t,r).call(this,i,o)?await this.datastore.delete(n,e):yield Xn(i,o,this.peerId.equals(i)?1/0:this.maxAddressAge)}}}t=new WeakSet,e=async function(e,n){try{const s=rr(e),i=await this.datastore.get(s,n),o=Gn.decode(i);if(P(this,t,r).call(this,e,o))throw await this.datastore.delete(s,n),new F;return{peerPB:o,peer:Xn(e,o,this.maxAddressAge)}}catch(s){"NotFoundError"!==s.name&&this.log.error("invalid peer data found in peer store - %e",s)}},n=async function(t,e,n,r){e.updated=Date.now();const s=Gn.encode(e);return await this.datastore.put(rr(t),s,r),{peer:Xn(t,e,this.maxAddressAge),previous:null==n?void 0:n.peer,updated:null==n||!Jn(e,n.peerPB)}},r=function(t,e){if(null==e.updated)return!0;if(this.peerId.equals(t))return!1;const n=e.updated<Date.now()-this.maxPeerAge,r=Date.now()-this.maxAddressAge,s=e.addresses.filter(t=>null!=t.observed&&t.observed>r);return n&&0===s.length},s=Symbol.toStringTag;class pr{constructor(t,e={}){E(this,i),k(this,"store"),k(this,"events"),k(this,"peerId"),k(this,"log"),k(this,s,"@libp2p/peer-store"),this.log=t.logger.forComponent("libp2p:peer-store"),this.events=t.events,this.peerId=t.peerId,this.store=new hr(t,e)}async forEach(t,e){for await(const n of this.store.all(e))t(n)}async all(t){return Z(this.store.all(t))}async delete(t,e){const n=await this.store.getReadLock(t,e);try{await this.store.delete(t,e)}finally{n()}}async has(t,e){const n=await this.store.getReadLock(t,e);try{return await this.store.has(t,e)}finally{this.log.trace("has release read lock"),null==n||n()}}async get(t,e){const n=await this.store.getReadLock(t,e);try{return await this.store.load(t,e)}finally{null==n||n()}}async getInfo(t,e){const n=await this.get(t,e);return{id:n.id,multiaddrs:n.addresses.map(({multiaddr:t})=>t)}}async save(t,e,n){const r=await this.store.getWriteLock(t,n);try{const r=await this.store.save(t,e,n);return P(this,i,o).call(this,t,r),r.peer}finally{null==r||r()}}async patch(t,e,n){const r=await this.store.getWriteLock(t,n);try{const r=await this.store.patch(t,e,n);return P(this,i,o).call(this,t,r),r.peer}finally{null==r||r()}}async merge(t,e,n){const r=await this.store.getWriteLock(t,n);try{const r=await this.store.merge(t,e,n);return P(this,i,o).call(this,t,r),r.peer}finally{null==r||r()}}async consumePeerRecord(t,e,n){const r=D(e)?e:D(null==e?void 0:e.expectedPeer)?e.expectedPeer:void 0,s=D(e)||void 0===e?n:e,i=await xt.openAndCertify(t,Bn.DOMAIN,s),o=R(i.publicKey.toCID());if(!1===(null==r?void 0:r.equals(o)))return this.log("envelope peer id was not the expected peer id - expected: %p received: %p",r,o),!1;const a=Bn.createFromProtobuf(i.payload);let l;try{l=await this.get(o,s)}catch(c){if("NotFoundError"!==c.name)throw c}if(null!=(null==l?void 0:l.peerRecordEnvelope)){const t=xt.createFromProtobuf(l.peerRecordEnvelope),e=Bn.createFromProtobuf(t.payload);if(e.seqNumber>=a.seqNumber)return this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",e.seqNumber,a.seqNumber),!1}return await this.patch(a.peerId,{peerRecordEnvelope:t,addresses:a.multiaddrs.map(t=>({isCertified:!0,multiaddr:t}))},s),!0}}i=new WeakSet,o=function(t,e){e.updated&&(this.peerId.equals(t)?this.events.safeDispatchEvent("self:peer:update",{detail:e}):this.events.safeDispatchEvent("peer:update",{detail:e}))};const mr=864e13;class gr{constructor(t,e={}){k(this,"log"),k(this,"mappings"),this.log=t.logger.forComponent("libp2p:address-manager:dns-mappings"),this.mappings=Pn({name:"libp2p_address_manager_dns_mappings",metrics:t.metrics})}has(t){const e=this.findHost(t);for(const n of this.mappings.values())if(n.domain===e)return!0;return!1}add(t,e){e.forEach(e=>{this.log("add DNS mapping %s to %s",e,t);const n=!0===Nn(e);this.mappings.set(e,{domain:t,verified:n,expires:n?mr-Date.now():0,lastVerified:n?mr-Date.now():void 0})})}remove(t){const e=this.findHost(t);let n=!1;for(const[r,s]of this.mappings.entries())s.domain===e&&(this.log("removing %s to %s DNS mapping %e",r,s.domain,new Error("where")),this.mappings.delete(r),n=n||s.verified);return n}getAll(t){const e=[];for(let n=0;n<t.length;n++){const r=t[n].multiaddr.stringTuples(),s=r[0][1];if(null!=s)for(const[i,o]of this.mappings.entries()){if(s!==i)continue;this.maybeAddSNITuple(r,o.domain)&&(t.splice(n,1),n--,e.push({multiaddr:yt(`/${r.map(t=>[kt(t[0]).name,t[1]].join("/")).join("/")}`),verified:o.verified,type:"dns-mapping",expires:o.expires,lastVerified:o.lastVerified}))}}return e}maybeAddSNITuple(t,e){var n;for(let r=0;r<t.length;r++)if(448===t[r][0]&&449!==(null==(n=t[r+1])?void 0:n[0]))return t.splice(r+1,0,[449,e]),!0;return!1}confirm(t,e){const n=this.findHost(t);let r=!1;for(const[s,i]of this.mappings.entries())i.domain===n&&(this.log("marking %s to %s DNS mapping as verified",s,i.domain),r=i.verified,i.verified=!0,i.expires=Date.now()+e,i.lastVerified=Date.now());return r}unconfirm(t,e){const n=this.findHost(t);let r=!1;for(const[s,i]of this.mappings.entries())i.domain===n&&(this.log("removing verification of %s to %s DNS mapping",s,i.domain),r=r||i.verified,i.verified=!1,i.expires=Date.now()+e);return r}findHost(t){for(const e of t.stringTuples()){if(449===e[0])return e[1];if(53===e[0]||54===e[0]||55===e[0]||56===e[0])return e[1]}}}class fr{constructor(t,e={}){k(this,"log"),k(this,"mappings"),this.log=t.logger.forComponent("libp2p:address-manager:ip-mappings"),this.mappings=Pn({name:"libp2p_address_manager_ip_mappings",metrics:t.metrics})}has(t){const e=t.stringTuples();for(const n of this.mappings.values())for(const t of n)if(t.externalIp===e[0][1])return!0;return!1}add(t,e,n,r=e,s="tcp"){const i=`${t}-${e}-${s}`,o=this.mappings.get(i)??[],a={internalIp:t,internalPort:e,externalIp:n,externalPort:r,externalFamily:gt(n)?4:6,protocol:s,verified:!1,expires:0};o.push(a),this.mappings.set(i,o)}remove(t){const e=t.stringTuples(),n=e[0][1]??"",r=6===e[1][0]?"tcp":"udp",s=parseInt(e[1][1]??"0");let i=!1;for(const[o,a]of this.mappings.entries()){for(let t=0;t<a.length;t++){const e=a[t];e.externalIp===n&&e.externalPort===s&&e.protocol===r&&(this.log("removing %s:%s to %s:%s %s IP mapping",e.externalIp,e.externalPort,n,s,r),i=i||e.verified,a.splice(t,1),t--)}0===a.length&&this.mappings.delete(o)}return i}getAll(t){const e=[];for(const{multiaddr:n}of t){const t=n.stringTuples();let r;if(4!==t[0][0]&&41!==t[0][0]||6!==t[1][0]?4!==t[0][0]&&41!==t[0][0]||273!==t[1][0]||(r=`${t[0][1]}-${t[1][1]}-udp`):r=`${t[0][1]}-${t[1][1]}-tcp`,null==r)continue;const s=this.mappings.get(r);if(null!=s)for(const n of s)t[0][0]=4===n.externalFamily?4:41,t[0][1]=n.externalIp,t[1][1]=`${n.externalPort}`,e.push({multiaddr:yt(`/${t.map(t=>[kt(t[0]).name,t[1]].join("/")).join("/")}`),verified:n.verified,type:"ip-mapping",expires:n.expires,lastVerified:n.lastVerified})}return e}confirm(t,e){const n=t.stringTuples()[0][1];let r=!1;for(const s of this.mappings.values())for(const t of s)t.externalIp===n&&(this.log("marking %s to %s IP mapping as verified",t.internalIp,t.externalIp),r=t.verified,t.verified=!0,t.expires=Date.now()+e,t.lastVerified=Date.now());return r}unconfirm(t,e){const n=t.stringTuples(),r=n[0][1]??"",s=6===n[1][0]?"tcp":"udp",i=parseInt(n[1][1]??"0");let o=!1;for(const a of this.mappings.values())for(let t=0;t<a.length;t++){const n=a[t];n.externalIp===r&&n.externalPort===i&&n.protocol===s&&(this.log("removing verification of %s:%s to %s:%s %s IP mapping",n.externalIp,n.externalPort,r,i,s),o=o||n.verified,n.verified=!1,n.expires=Date.now()+e)}return o}}function yr(t){try{for(const{code:e}of t.getComponents())if(e!==Et)return e===Pt||e===Ct}catch{}return!1}function vr(t){try{if(!yr(t))return!1;const[[,e]]=t.stringTuples();return null!=e&&(Nn(e)??!1)}catch{}return!0}const wr=10;class br{constructor(t,e={}){k(this,"log"),k(this,"addresses"),k(this,"maxObservedAddresses"),this.log=t.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Pn({name:"libp2p_address_manager_observed_addresses",metrics:t.metrics}),this.maxObservedAddresses=e.maxObservedAddresses??wr}has(t){return this.addresses.has(t.toString())}removePrefixed(t){for(const e of this.addresses.keys())e.toString().startsWith(t)&&this.addresses.delete(e)}add(t){this.addresses.size!==this.maxObservedAddresses&&(vr(t)||function(t){try{for(const{code:e,value:n}of t.getComponents())if(e!==Et&&null!=n){if(e===Pt)return n.startsWith("169.254.");if(e===Ct)return n.toLowerCase().startsWith("fe80")}}catch{}return!1}(t)||(this.log("adding observed address %a",t),this.addresses.set(t.toString(),{verified:!1,expires:0})))}getAll(){return Array.from(this.addresses).map(([t,e])=>({multiaddr:yt(t),verified:e.verified,type:"observed",expires:e.expires,lastVerified:e.lastVerified}))}remove(t){var e;const n=(null==(e=this.addresses.get(t.toString()))?void 0:e.verified)??!1;return this.log("removing observed address %a",t),this.addresses.delete(t.toString()),n}confirm(t,e){const n=t.toString(),r=this.addresses.get(n)??{verified:!1,expires:Date.now()+e,lastVerified:Date.now()},s=r.verified;return r.verified=!0,r.expires=Date.now()+e,r.lastVerified=Date.now(),this.log("marking observed address %a as verified",n),this.addresses.set(n,r),s}}const Ar=[Pt,Ct,It,Mt,_t,Tt];function Sr(t){try{for(const{code:e}of t.getComponents())if(e!==Et)return Ar.includes(e)}catch{}return!1}const xr=10;class kr{constructor(t,e={}){k(this,"log"),k(this,"addresses"),k(this,"maxObservedAddresses"),this.log=t.logger.forComponent("libp2p:address-manager:observed-addresses"),this.addresses=Pn({name:"libp2p_address_manager_transport_addresses",metrics:t.metrics}),this.maxObservedAddresses=e.maxObservedAddresses??xr}get(t,e){if(vr(t))return{multiaddr:t,verified:!0,type:"transport",expires:Date.now()+e,lastVerified:Date.now()};const n=this.toKey(t);let r=this.addresses.get(n);return null==r&&(r={verified:!Sr(t),expires:0},this.addresses.set(n,r)),{multiaddr:t,verified:r.verified,type:"transport",expires:r.expires,lastVerified:r.lastVerified}}has(t){const e=this.toKey(t);return this.addresses.has(e)}remove(t){var e;const n=this.toKey(t),r=(null==(e=this.addresses.get(n))?void 0:e.verified)??!1;return this.log("removing observed address %a",t),this.addresses.delete(n),r}confirm(t,e){const n=this.toKey(t),r=this.addresses.get(n)??{verified:!1,expires:0,lastVerified:0},s=r.verified;return r.verified=!0,r.expires=Date.now()+e,r.lastVerified=Date.now(),this.addresses.set(n,r),s}unconfirm(t,e){const n=this.toKey(t),r=this.addresses.get(n)??{verified:!1,expires:0},s=r.verified;return r.verified=!1,r.expires=Date.now()+e,this.addresses.set(n,r),s}toKey(t){if(Sr(t)){const e=t.toOptions();return`${e.host}-${e.port}-${e.transport}`}return t.toString()}}const Er={addressVerificationTTL:6e5,addressVerificationRetry:3e5},Pr=t=>t;function Cr(t,e){const n=t.getPeerId();if(null!=n){N(n).equals(e)&&(t=t.decapsulate(yt(`/p2p/${e.toString()}`)))}return t}a=Symbol.toStringTag;class Ir{constructor(t,e={}){k(this,"log"),k(this,"components"),k(this,"listen"),k(this,"announce"),k(this,"appendAnnounce"),k(this,"announceFilter"),k(this,"observed"),k(this,"dnsMappings"),k(this,"ipMappings"),k(this,"transportAddresses"),k(this,"observedAddressFilter"),k(this,"addressVerificationTTL"),k(this,"addressVerificationRetry"),k(this,a,"@libp2p/address-manager");const{listen:n=[],announce:r=[],appendAnnounce:s=[]}=e;this.components=t,this.log=t.logger.forComponent("libp2p:address-manager"),this.listen=n.map(t=>t.toString()),this.announce=new Set(r.map(t=>t.toString())),this.appendAnnounce=new Set(s.map(t=>t.toString())),this.observed=new br(t,e),this.dnsMappings=new gr(t,e),this.ipMappings=new fr(t,e),this.transportAddresses=new kr(t,e),this.announceFilter=e.announceFilter??Pr,this.observedAddressFilter=oe(1024),this.addressVerificationTTL=e.addressVerificationTTL??Er.addressVerificationTTL,this.addressVerificationRetry=e.addressVerificationRetry??Er.addressVerificationRetry,this._updatePeerStoreAddresses=Dt(this._updatePeerStoreAddresses.bind(this),1e3),t.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),t.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}_updatePeerStoreAddresses(){const t=this.getAddresses().map(t=>t.getPeerId()===this.components.peerId.toString()?t.decapsulate(`/p2p/${this.components.peerId.toString()}`):t);this.components.peerStore.patch(this.components.peerId,{multiaddrs:t}).catch(t=>{this.log.error("error updating addresses",t)})}getListenAddrs(){return Array.from(this.listen).map(t=>yt(t))}getAnnounceAddrs(){return Array.from(this.announce).map(t=>yt(t))}getAppendAnnounceAddrs(){return Array.from(this.appendAnnounce).map(t=>yt(t))}getObservedAddrs(){return this.observed.getAll().map(t=>t.multiaddr)}addObservedAddr(t){const e=t.stringTuples(),n=`${e[0][1]}:${e[1][1]}`;this.observedAddressFilter.has(n)||(this.observedAddressFilter.add(n),t=Cr(t,this.components.peerId),this.ipMappings.has(t)||this.dnsMappings.has(t)||this.observed.add(t))}confirmObservedAddr(t,e){t=Cr(t,this.components.peerId);let n=!0;if("transport"===(null==e?void 0:e.type)||this.transportAddresses.has(t)){!this.transportAddresses.confirm(t,(null==e?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1)}if("dns-mapping"===(null==e?void 0:e.type)||this.dnsMappings.has(t)){!this.dnsMappings.confirm(t,(null==e?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1)}if("ip-mapping"===(null==e?void 0:e.type)||this.ipMappings.has(t)){!this.ipMappings.confirm(t,(null==e?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1)}if("observed"===(null==e?void 0:e.type)||this.observed.has(t))if(this.maybeUpgradeToIPMapping(t))this.ipMappings.confirm(t,(null==e?void 0:e.ttl)??this.addressVerificationTTL),n=!1;else{!this.observed.confirm(t,(null==e?void 0:e.ttl)??this.addressVerificationTTL)&&n&&(n=!1)}n||this._updatePeerStoreAddresses()}removeObservedAddr(t,e){t=Cr(t,this.components.peerId),this.observed.has(t)&&this.observed.remove(t),this.transportAddresses.has(t)&&this.transportAddresses.unconfirm(t,(null==e?void 0:e.ttl)??this.addressVerificationRetry),this.dnsMappings.has(t)&&this.dnsMappings.unconfirm(t,(null==e?void 0:e.ttl)??this.addressVerificationRetry),this.ipMappings.has(t)&&this.ipMappings.unconfirm(t,(null==e?void 0:e.ttl)??this.addressVerificationRetry)}getAddresses(){const t=new Set,e=this.getAddressesWithMetadata().filter(e=>{if(!e.verified)return!1;const n=e.multiaddr.toString();return!t.has(n)&&(t.add(n),!0)}).map(t=>t.multiaddr);return this.announceFilter(e.map(t=>{const e=yt(t),n=e.getComponents().pop();return(null==n?void 0:n.value)===this.components.peerId.toString()?e:e.encapsulate(`/p2p/${this.components.peerId.toString()}`)}))}getAddressesWithMetadata(){const t=this.getAnnounceAddrs();if(t.length>0)return this.components.transportManager.getListeners().forEach(e=>{e.updateAnnounceAddrs(t)}),t.map(t=>({multiaddr:t,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()}));let e=[];e=e.concat(this.components.transportManager.getAddrs().map(t=>this.transportAddresses.get(t,this.addressVerificationTTL)));const n=this.getAppendAnnounceAddrs();return n.length>0&&(this.components.transportManager.getListeners().forEach(t=>{t.updateAnnounceAddrs(n)}),e=e.concat(n.map(t=>({multiaddr:t,verified:!0,type:"announce",expires:Date.now()+this.addressVerificationTTL,lastVerified:Date.now()})))),e=e.concat(this.observed.getAll()),e=e.concat(this.ipMappings.getAll(e)),e=e.concat(this.dnsMappings.getAll(e)),e}addDNSMapping(t,e){this.dnsMappings.add(t,e)}removeDNSMapping(t){this.dnsMappings.remove(yt(`/dns/${t}`))&&this._updatePeerStoreAddresses()}addPublicAddressMapping(t,e,n,r=e,s="tcp"){this.ipMappings.add(t,e,n,r,s),this.observed.removePrefixed(`/ip${gt(n)?4:6}/${n}/${s}/${r}`)}removePublicAddressMapping(t,e,n,r=e,s="tcp"){this.ipMappings.remove(yt(`/ip${gt(n)?4:6}/${n}/${s}/${r}`))&&this._updatePeerStoreAddresses()}maybeUpgradeToIPMapping(t){if(this.ipMappings.has(t))return!1;const e=t.toOptions();if(6===e.family||"127.0.0.1"===e.host||!0===Nn(e.host))return!1;const n=this.components.transportManager.getListeners(),r=[t=>Lt.exactMatch(t)||Ft.exactMatch(t),t=>Rt.exactMatch(t),t=>Nt.exactMatch(t)];for(const s of r){if(!s(t))continue;const r=n.filter(t=>t.getAddrs().filter(t=>4===t.toOptions().family&&s(t)).length>0);if(1!==r.length)continue;const i=r[0].getAddrs().filter(t=>"127.0.0.1"!==t.toOptions().host).pop();if(null==i)continue;const o=i.toOptions();return this.observed.remove(t),this.ipMappings.add(o.host,o.port,e.host,e.port,e.transport),!0}return!1}}var Mr,_r;(_r=Mr||(Mr={})).NOT_STARTED_YET="The libp2p node is not started yet",_r.NOT_FOUND="Not found";class Tr extends Error{constructor(t="Missing service"){super(t),this.name="MissingServiceError"}}class Dr extends Error{constructor(t="Unmet service dependencies"){super(t),this.name="UnmetServiceDependenciesError"}}class Lr extends Error{constructor(t="No content routers available"){super(t),this.name="NoContentRoutersError"}}class Fr extends Error{constructor(t="No peer routers available"){super(t),this.name="NoPeerRoutersError"}}class Rr extends Error{constructor(t="Should not try to find self"){super(t),this.name="QueriedForSelfError"}}class Nr extends Error{constructor(t="Unhandled protocol error"){super(t),this.name="UnhandledProtocolError"}}class qr extends Error{constructor(t="Duplicate protocol handler error"){super(t),this.name="DuplicateProtocolHandlerError"}}class $r extends Error{constructor(t="Dial denied error"){super(t),this.name="DialDeniedError"}}class Or extends Error{constructor(t="No transport was configured to listen on this address"){super(t),this.name="UnsupportedListenAddressError"}}class Kr extends Error{constructor(t="Configured listen addresses could not be listened on"){super(t),this.name="UnsupportedListenAddressesError"}}class Ur extends Error{constructor(t="No valid addresses"){super(t),this.name="NoValidAddressesError"}}class jr extends Error{constructor(t="Connection intercepted"){super(t),this.name="ConnectionInterceptedError"}}class Vr extends Error{constructor(t="Connection denied"){super(t),this.name="ConnectionDeniedError"}}class zr extends Error{constructor(t="Stream is not multiplexed"){super(t),this.name="MuxerUnavailableError"}}class Wr extends Error{constructor(t="Encryption failed"){super(t),this.name="EncryptionFailedError"}}class Br extends Error{constructor(t="Transport unavailable"){super(t),this.name="TransportUnavailableError"}}class Gr extends Error{constructor(t="Max recursive depth reached"){super(t),this.name="RecursionLimitError"}}class Qr{constructor(t={}){k(this,"components",{}),k(this,"_started",!1),this.components={};for(const[e,n]of Object.entries(t))this.components[e]=n;null==this.components.logger&&(this.components.logger=re())}isStarted(){return this._started}async _invokeStartableMethod(t){await Promise.all(Object.values(this.components).filter(t=>qt(t)).map(async e=>{var n;await(null==(n=e[t])?void 0:n.call(e))}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const Hr=["metrics","connectionProtector","dns"],Yr=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function Xr(t){return Array.isArray(null==t?void 0:t[$t])?t[$t]:[]}function Jr(t){return Array.isArray(null==t?void 0:t[Ot])?t[Ot]:[]}function Zr(t){return(null==t?void 0:t[Symbol.toStringTag])??(null==t?void 0:t.toString())??"unknown"}function ts(t={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async t=>{if(Lt.matches(t))return!1;const e=t.stringTuples();return(4===e[0][0]||41===e[0][0])&&Boolean(Nn(`${e[0][1]}`))},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...t}}const es=()=>{const t=new Error("Delay aborted");return t.name="AbortError",t},ns=new WeakMap;const rs=function({clearTimeout:t,setTimeout:e}={}){return(n,{value:r,signal:s}={})=>{if(null==s?void 0:s.aborted)return Promise.reject(es());let i,o,a;const l=t??clearTimeout,c=()=>{l(i),a(es())},d=new Promise((t,l)=>{o=()=>{s&&s.removeEventListener("abort",c),t(r)},a=l,i=(e??setTimeout)(o,n)});return s&&s.addEventListener("abort",c,{once:!0}),ns.set(d,()=>{l(i),i=null,o()}),d}}();class ss{constructor(t={}){k(this,"memoryStorage"),k(this,"points"),k(this,"duration"),k(this,"blockDuration"),k(this,"execEvenly"),k(this,"execEvenlyMinDelayMs"),k(this,"keyPrefix"),this.points=t.points??4,this.duration=t.duration??1,this.blockDuration=t.blockDuration??0,this.execEvenly=t.execEvenly??!1,this.execEvenlyMinDelayMs=t.execEvenlyMinDelayMs??1e3*this.duration/this.points,this.keyPrefix=t.keyPrefix??"rlflx",this.memoryStorage=new is}async consume(t,e=1,n={}){const r=this.getKey(t),s=this._getKeySecDuration(n);let i=this.memoryStorage.incrby(r,e,s);if(i.remainingPoints=Math.max(this.points-i.consumedPoints,0),i.consumedPoints>this.points)throw this.blockDuration>0&&i.consumedPoints<=this.points+e&&(i=this.memoryStorage.set(r,i.consumedPoints,this.blockDuration)),new Kt("Rate limit exceeded",i);if(this.execEvenly&&i.msBeforeNext>0&&!i.isFirstInDuration){let t=Math.ceil(i.msBeforeNext/(i.remainingPoints+2));t<this.execEvenlyMinDelayMs&&(t=i.consumedPoints*this.execEvenlyMinDelayMs),await rs(t)}return i}penalty(t,e=1,n={}){const r=this.getKey(t),s=this._getKeySecDuration(n),i=this.memoryStorage.incrby(r,e,s);return i.remainingPoints=Math.max(this.points-i.consumedPoints,0),i}reward(t,e=1,n={}){const r=this.getKey(t),s=this._getKeySecDuration(n),i=this.memoryStorage.incrby(r,-e,s);return i.remainingPoints=Math.max(this.points-i.consumedPoints,0),i}block(t,e){const n=1e3*e,r=this.points+1;return this.memoryStorage.set(this.getKey(t),r,e),{remainingPoints:0,msBeforeNext:0===n?-1:n,consumedPoints:r,isFirstInDuration:!1}}set(t,e,n=0){const r=1e3*(n>=0?n:this.duration);return this.memoryStorage.set(this.getKey(t),e,n),{remainingPoints:0,msBeforeNext:0===r?-1:r,consumedPoints:e,isFirstInDuration:!1}}get(t){const e=this.memoryStorage.get(this.getKey(t));return null!=e&&(e.remainingPoints=Math.max(this.points-e.consumedPoints,0)),e}delete(t){this.memoryStorage.delete(this.getKey(t))}_getKeySecDuration(t){return null!=(null==t?void 0:t.customDuration)&&t.customDuration>=0?t.customDuration:this.duration}getKey(t){return this.keyPrefix.length>0?`${this.keyPrefix}:${t}`:t}parseKey(t){return t.substring(this.keyPrefix.length)}}class is{constructor(){k(this,"storage"),this.storage=new Map}incrby(t,e,n){const r=this.storage.get(t);if(null!=r){const s=null!=r.expiresAt?r.expiresAt.getTime()-(new Date).getTime():-1;return null==r.expiresAt||s>0?(r.value+=e,{remainingPoints:0,msBeforeNext:s,consumedPoints:r.value,isFirstInDuration:!1}):this.set(t,e,n)}return this.set(t,e,n)}set(t,e,n){const r=1e3*n,s=this.storage.get(t);null!=s&&clearTimeout(s.timeoutId);const i={value:e,expiresAt:r>0?new Date(Date.now()+r):void 0};return this.storage.set(t,i),r>0&&(i.timeoutId=setTimeout(()=>{this.storage.delete(t)},r),null!=i.timeoutId.unref&&i.timeoutId.unref()),{remainingPoints:0,msBeforeNext:0===r?-1:r,consumedPoints:i.value,isFirstInDuration:!0}}get(t){const e=this.storage.get(t);if(null!=e){return{remainingPoints:0,msBeforeNext:null!=e.expiresAt?e.expiresAt.getTime()-(new Date).getTime():-1,consumedPoints:e.value,isFirstInDuration:!1}}}delete(t){const e=this.storage.get(t);return null!=e&&(null!=e.timeoutId&&clearTimeout(e.timeoutId),this.storage.delete(t),!0)}}function os(t){if(D(t))return{peerId:t,multiaddrs:[]};let e,n=Array.isArray(t)?t:[t];if(n.length>0){const t=n[0].getPeerId();e=null==t?void 0:N(t),n.forEach(t=>{if(!At(t))throw new q("Invalid multiaddr");const n=t.getPeerId();if(null==n){if(null!=e)throw new C("Multiaddrs must all have the same peer id or have no peer id")}else{const t=N(n);if(!0!==(null==e?void 0:e.equals(t)))throw new C("Multiaddrs must all have the same peer id or have no peer id")}})}return n=n.filter(t=>!Ut.exactMatch(t)),{peerId:e,multiaddrs:n}}const as=["/ipfs/id/1.0.0","/ipfs/id/push/1.0.0","/libp2p/autonat/1.0.0","/libp2p/dcutr"];function ls(t){try{let e;e="string"==typeof t?yt(t):t;const n=new Set([...e.getComponents().map(t=>t.name)]);if(!n.has("ipcidr")){const t=n.has("ip6")?"/ipcidr/128":"/ipcidr/32";e=e.encapsulate(t)}return function(t){let e,n;if(t.getComponents().forEach(t=>{"ip4"!==t.name&&"ip6"!==t.name||(n=t.value),"ipcidr"===t.name&&(e=t.value)}),null==e||null==n)throw new Error("Invalid multiaddr");return new Dn(n,e)}(e)}catch(e){throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${t}`)}}class cs{constructor(t,e={}){k(this,"connectionManager"),k(this,"peerStore"),k(this,"allow"),k(this,"events"),k(this,"log"),this.allow=(e.allow??[]).map(t=>ls(t)),this.connectionManager=t.connectionManager,this.peerStore=t.peerStore,this.events=t.events,this.log=t.logger.forComponent("libp2p:connection-manager:connection-pruner"),this.maybePruneConnections=this.maybePruneConnections.bind(this)}start(){this.events.addEventListener("connection:open",this.maybePruneConnections)}stop(){this.events.removeEventListener("connection:open",this.maybePruneConnections)}maybePruneConnections(){this._maybePruneConnections().catch(t=>{this.log.error("error while pruning connections %e",t)})}async _maybePruneConnections(){const t=this.connectionManager.getConnections(),e=t.length,n=this.connectionManager.getMaxConnections();if(this.log("checking max connections limit %d/%d",e,n),e<=n)return;const r=new jt;for(const l of t){const t=l.remotePeer;if(!r.has(t)){r.set(t,0);try{const e=await this.peerStore.get(t);r.set(t,[...e.tags.values()].reduce((t,e)=>t+e.value,0))}catch(a){"NotFoundError"!==a.name&&this.log.error("error loading peer tags",a)}}}const s=this.sortConnections(t,r),i=Math.max(e-n,0),o=[];for(const l of s){this.log("too many connections open - closing a connection to %p",l.remotePeer);if(this.allow.some(t=>t.contains(l.remoteAddr.nodeAddress().address))||o.push(l),o.length===i)break}await Promise.all(o.map(async t=>{await async function(t,e){var n;const r=(null==(n=null==t?void 0:t.streams)?void 0:n.map(t=>t.protocol))??[],s=(null==e?void 0:e.closableProtocols)??as;if(!(r.filter(t=>null!=t&&!s.includes(t)).length>0))try{await(null==t?void 0:t.close(e))}catch(a){null==t||t.abort(a)}}(t,{signal:AbortSignal.timeout(1e3)})})),this.events.safeDispatchEvent("connection:prune",{detail:o})}sortConnections(t,e){return t.sort((t,e)=>{const n=t.timeline.open,r=e.timeline.open;return n<r?1:n>r?-1:0}).sort((t,e)=>"outbound"===t.direction&&"inbound"===e.direction?1:"inbound"===t.direction&&"outbound"===e.direction?-1:0).sort((t,e)=>t.streams.length>e.streams.length?1:t.streams.length<e.streams.length?-1:0).sort((t,n)=>{const r=e.get(t.remotePeer)??0,s=e.get(n.remotePeer)??0;return r>s?1:r<s?-1:0})}}const ds="last-dial-failure",us="last-dial-success";class hs extends Vt{constructor(t={}){super({...t,sort:(t,e)=>t.options.priority>e.options.priority?-1:t.options.priority<e.options.priority?1:0})}}function ps(t){if(!yr(t))return!1;const{address:e}=t.nodeAddress();return/^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(n=e)||/^::1$/.test(n);var n}function ms(t,e){const n=Rt.exactMatch(t.multiaddr),r=Rt.exactMatch(e.multiaddr);if(n&&!r)return-1;if(!n&&r)return 1;const s=Ft.exactMatch(t.multiaddr),i=Ft.exactMatch(e.multiaddr);if(s&&!i)return-1;if(!s&&i)return 1;const o=Lt.exactMatch(t.multiaddr),a=Lt.exactMatch(e.multiaddr);if(o&&!a)return-1;if(!o&&a)return 1;const l=zt.exactMatch(t.multiaddr),c=zt.exactMatch(e.multiaddr);if(l&&!c)return-1;if(!l&&c)return 1;const d=Wt.exactMatch(t.multiaddr),u=Wt.exactMatch(e.multiaddr);if(d&&!u)return-1;if(!d&&u)return 1;const h=Bt.exactMatch(t.multiaddr),p=Bt.exactMatch(e.multiaddr);return h&&!p?-1:!h&&p?1:0}function gs(t,e){const n=ps(t.multiaddr),r=ps(e.multiaddr);return n&&!r?1:!n&&r?-1:0}function fs(t,e){const n=vr(t.multiaddr),r=vr(e.multiaddr);return n&&!r?1:!n&&r?-1:0}function ys(t,e){return t.isCertified&&!e.isCertified?-1:!t.isCertified&&e.isCertified?1:0}function vs(t,e){const n=Gt.exactMatch(t.multiaddr),r=Gt.exactMatch(e.multiaddr);return n&&!r?1:!n&&r?-1:0}async function ws(t,e,n){const r=n.depth??0;if(r>(n.maxRecursiveDepth??32))throw new Gr("Max recursive depth reached");let s=!1;const i=[];for(const o of Object.values(e))if(o.canResolve(t)){s=!0;const a=await o.resolve(t,n);for(const t of a)i.push(...await ws(t,e,{...n,depth:r+1}))}return!1===s&&i.push(t),i}const bs={maxParallelDials:50,maxDialQueueLength:500,maxPeerAddrsToDial:25,dialTimeout:1e4,resolvers:{dnsaddr:Kn}};class As{constructor(t,e={}){k(this,"queue"),k(this,"components"),k(this,"addressSorter"),k(this,"maxPeerAddrsToDial"),k(this,"maxDialQueueLength"),k(this,"dialTimeout"),k(this,"shutDownController"),k(this,"connections"),k(this,"log"),k(this,"resolvers"),this.addressSorter=e.addressSorter,this.maxPeerAddrsToDial=e.maxPeerAddrsToDial??bs.maxPeerAddrsToDial,this.maxDialQueueLength=e.maxDialQueueLength??bs.maxDialQueueLength,this.dialTimeout=e.dialTimeout??bs.dialTimeout,this.connections=e.connections??new jt,this.log=t.logger.forComponent("libp2p:connection-manager:dial-queue"),this.components=t,this.resolvers=e.resolvers??bs.resolvers,this.shutDownController=new AbortController,at(1/0,this.shutDownController.signal),this.queue=new hs({concurrency:e.maxParallelDials??bs.maxParallelDials,metricName:"libp2p_dial_queue",metrics:t.metrics}),this.queue.addEventListener("error",t=>{var e;(null==(e=t.detail)?void 0:e.name)!==$.name&&this.log.error("error in dial queue - %e",t.detail)})}start(){this.shutDownController=new AbortController,at(1/0,this.shutDownController.signal)}stop(){this.shutDownController.abort(),this.queue.abort()}async dial(t,e={}){var n,r,s;const{peerId:i,multiaddrs:o}=os(t),a=Array.from(this.connections.values()).flat().find(t=>!0!==e.force&&(null==t.limits&&(!!t.remotePeer.equals(i)||o.find(e=>e.equals(t.remoteAddr)))));if("open"===(null==a?void 0:a.status))return this.log("already connected to %a",a.remoteAddr),null==(n=e.onProgress)||n.call(e,new Se("dial-queue:already-connected")),a;const l=this.queue.queue.find(t=>{if(!0===(null==i?void 0:i.equals(t.options.peerId)))return!0;const e=t.options.multiaddrs;if(null==e)return!1;for(const n of o)if(e.has(n.toString()))return!0;return!1});if(null!=l){this.log("joining existing dial target for %p",i);for(const t of o)l.options.multiaddrs.add(t.toString());return null==(r=e.onProgress)||r.call(e,new Se("dial-queue:already-in-dial-queue")),l.join(e)}if(this.queue.size>=this.maxDialQueueLength)throw new O("Dial queue is full");return this.log("creating dial target for %p",i,o.map(t=>t.toString())),null==(s=e.onProgress)||s.call(e,new Se("dial-queue:add-to-dial-queue")),this.queue.add(async t=>{var e;null==(e=t.onProgress)||e.call(t,new Se("dial-queue:start-dial"));const n=Qt([this.shutDownController.signal,t.signal]);try{return await this.dialPeer(t,n)}finally{n.clear()}},{peerId:i,priority:e.priority??Rs,multiaddrs:new Set(o.map(t=>t.toString())),signal:e.signal??AbortSignal.timeout(this.dialTimeout),onProgress:e.onProgress})}async dialPeer(t,e){var n;const r=t.peerId,s=t.multiaddrs,i=new Set;let o=0===t.multiaddrs.size,a=0,l=0;const c=[];for(this.log("starting dial to %p",r);o||s.size>0;){l++,o=!1;const h=[],p=new Set(t.multiaddrs);s.clear(),this.log("calculating addrs to dial %p from %s",r,[...p]);const m=await this.calculateMultiaddrs(r,p,{...t,signal:e});for(const t of m)i.has(t.multiaddr.toString())?this.log.trace("skipping previously failed multiaddr %a while dialing %p",t.multiaddr,r):h.push(t);this.log("%s dial to %p with %s",1===l?"starting":"continuing",r,h.map(t=>t.multiaddr.toString())),null==(n=null==t?void 0:t.onProgress)||n.call(t,new Se("dial-queue:calculated-addresses",h));for(const n of h){if(a===this.maxPeerAddrsToDial)throw this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others",a,t.peerId),new O("Peer had more than maxPeerAddrsToDial");a++;try{const s=await this.components.transportManager.dial(n.multiaddr,{...t,signal:e});this.log("dial to %a succeeded",n.multiaddr);try{await this.components.peerStore.merge(s.remotePeer,{multiaddrs:[s.remoteAddr],metadata:{[us]:xe(Date.now().toString())}})}catch(d){this.log.error("could not update last dial failure key for %p",r,d)}return s}catch(d){if(this.log.error("dial failed to %a",n.multiaddr,d),i.add(n.multiaddr.toString()),null!=r)try{await this.components.peerStore.merge(r,{metadata:{[ds]:xe(Date.now().toString())}})}catch(u){this.log.error("could not update last dial failure key for %p",r,u)}if(e.aborted)throw new K(d.message);c.push(d)}}}if(1===c.length)throw c[0];throw new AggregateError(c,"All multiaddr dials failed")}async calculateMultiaddrs(t,e=new Set,n={}){var r,s;const i=[...e].map(t=>({multiaddr:yt(t),isCertified:!1}));if(null!=t){if(this.components.peerId.equals(t))throw new O("Tried to dial self");if(!0===await(null==(s=(r=this.components.connectionGater).denyDialPeer)?void 0:s.call(r,t)))throw new $r("The dial request is blocked by gater.allowDialPeer");if(0===i.length){this.log("loading multiaddrs for %p",t);try{const e=await this.components.peerStore.get(t);i.push(...e.addresses),this.log("loaded multiaddrs for %p",t,i.map(({multiaddr:t})=>t.toString()))}catch(h){if("NotFoundError"!==h.name)throw h}}if(0===i.length){this.log("looking up multiaddrs for %p in the peer routing",t);try{const e=await this.components.peerRouting.findPeer(t,n);this.log("found multiaddrs for %p in the peer routing",t,i.map(({multiaddr:t})=>t.toString())),i.push(...e.multiaddrs.map(t=>({multiaddr:t,isCertified:!1})))}catch(h){"NoPeerRoutersError"===h.name?this.log("no peer routers configured",t):this.log.error("looking up multiaddrs for %p in the peer routing failed - %e",t,h)}}}let o=(await Promise.all(i.map(async t=>{const e=await ws(t.multiaddr,this.resolvers,{dns:this.components.dns,log:this.log,...n});return 1===e.length&&e[0].equals(t.multiaddr)?t:e.map(t=>({multiaddr:t,isCertified:!1}))}))).flat();if(null!=t){const e=`/p2p/${t.toString()}`;o=o.map(t=>{const n=t.multiaddr.getComponents().pop();return"p2p"!==(null==n?void 0:n.name)?{multiaddr:t.multiaddr.encapsulate(e),isCertified:t.isCertified}:t})}const a=o.filter(e=>{if(null==this.components.transportManager.dialTransportForMultiaddr(e.multiaddr))return!1;const n=e.multiaddr.getPeerId();return null==t||null==n||t.equals(n)}),l=new Map;for(const p of a){const t=p.multiaddr.toString(),e=l.get(t);null==e?l.set(t,p):e.isCertified=e.isCertified||p.isCertified||!1}const c=[...l.values()];if(0===c.length)throw new Ur("The dial request has no valid addresses");const d=[];for(const p of c)null!=this.components.connectionGater.denyDialMultiaddr&&await this.components.connectionGater.denyDialMultiaddr(p.multiaddr)||d.push(p);const u=null==this.addressSorter?d.sort(ms).sort(ys).sort(vs).sort(fs).sort(gs):d.sort(this.addressSorter);if(0===u.length)throw new $r("The connection gater denied all addresses in the dial request");return this.log.trace("addresses for %p before filtering",t??"unknown peer",o.map(({multiaddr:t})=>t.toString())),this.log.trace("addresses for %p after filtering",t??"unknown peer",u.map(({multiaddr:t})=>t.toString())),u}async isDialable(t,e={}){Array.isArray(t)||(t=[t]);try{const n=await this.calculateMultiaddrs(void 0,new Set(t.map(t=>t.toString())),e);return!1!==e.runOnLimitedConnection||null!=n.find(t=>!Gt.matches(t.multiaddr))}catch(n){this.log.trace("error calculating if multiaddr(s) were dialable",n)}return!1}}var Ss={};function xs(t,e){"boolean"==typeof e&&(e={forever:e}),this._originalTimeouts=JSON.parse(JSON.stringify(t)),this._timeouts=t,this._options=e||{},this._maxRetryTime=e&&e.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}var ks,Es,Ps=xs;xs.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)},xs.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null},xs.prototype.retry=function(t){if(this._timeout&&clearTimeout(this._timeout),!t)return!1;var e=(new Date).getTime();if(t&&e-this._operationStart>=this._maxRetryTime)return this._errors.push(t),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(t);var n=this._timeouts.shift();if(void 0===n){if(!this._cachedTimeouts)return!1;this._errors.splice(0,this._errors.length-1),n=this._cachedTimeouts.slice(-1)}var r=this;return this._timer=setTimeout(function(){r._attempts++,r._operationTimeoutCb&&(r._timeout=setTimeout(function(){r._operationTimeoutCb(r._attempts)},r._operationTimeout),r._options.unref&&r._timeout.unref()),r._fn(r._attempts)},n),this._options.unref&&this._timer.unref(),!0},xs.prototype.attempt=function(t,e){this._fn=t,e&&(e.timeout&&(this._operationTimeout=e.timeout),e.cb&&(this._operationTimeoutCb=e.cb));var n=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){n._operationTimeoutCb()},n._operationTimeout)),this._operationStart=(new Date).getTime(),this._fn(this._attempts)},xs.prototype.try=function(t){console.log("Using RetryOperation.try() is deprecated"),this.attempt(t)},xs.prototype.start=function(t){console.log("Using RetryOperation.start() is deprecated"),this.attempt(t)},xs.prototype.start=xs.prototype.try,xs.prototype.errors=function(){return this._errors},xs.prototype.attempts=function(){return this._attempts},xs.prototype.mainError=function(){if(0===this._errors.length)return null;for(var t={},e=null,n=0,r=0;r<this._errors.length;r++){var s=this._errors[r],i=s.message,o=(t[i]||0)+1;t[i]=o,o>=n&&(e=s,n=o)}return e},Es=Ps,(ks=Ss).operation=function(t){var e=ks.timeouts(t);return new Es(e,{forever:t&&(t.forever||t.retries===1/0),unref:t&&t.unref,maxRetryTime:t&&t.maxRetryTime})},ks.timeouts=function(t){if(t instanceof Array)return[].concat(t);var e={retries:10,factor:2,minTimeout:1e3,maxTimeout:1/0,randomize:!1};for(var n in t)e[n]=t[n];if(e.minTimeout>e.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var r=[],s=0;s<e.retries;s++)r.push(this.createTimeout(s,e));return t&&t.forever&&!r.length&&r.push(this.createTimeout(s,e)),r.sort(function(t,e){return t-e}),r},ks.createTimeout=function(t,e){var n=e.randomize?Math.random()+1:1,r=Math.round(n*Math.max(e.minTimeout,1)*Math.pow(e.factor,t));return r=Math.min(r,e.maxTimeout)},ks.wrap=function(t,e,n){if(e instanceof Array&&(n=e,e=null),!n)for(var r in n=[],t)"function"==typeof t[r]&&n.push(r);for(var s=0;s<n.length;s++){var i=n[s],o=t[i];t[i]=function(n){var r=ks.operation(e),s=Array.prototype.slice.call(arguments,1),i=s.pop();s.push(function(t){r.retry(t)||(t&&(arguments[0]=r.mainError()),i.apply(this,arguments))}),r.attempt(function(){n.apply(t,s)})}.bind(t,o),t[i].options=e}};const Cs=Pe(Ss),Is=Object.prototype.toString,Ms=new Set(["network error","Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Load failed","Network request failed","fetch failed","terminated"]);function _s(t){var e;return!(!t||(e=t,"[object Error]"!==Is.call(e))||"TypeError"!==t.name||"string"!=typeof t.message)&&("Load failed"===t.message?void 0===t.stack:Ms.has(t.message))}class Ts extends Error{constructor(t){super(),t instanceof Error?(this.originalError=t,({message:t}=t)):(this.originalError=new Error(t),this.originalError.stack=this.stack),this.name="AbortError",this.message=t}}const Ds=(t,e,n)=>{const r=n.retries-(e-1);return t.attemptNumber=e,t.retriesLeft=r,t};class Ls{constructor(t,e={}){k(this,"log"),k(this,"queue"),k(this,"started"),k(this,"peerStore"),k(this,"retries"),k(this,"retryInterval"),k(this,"backoffFactor"),k(this,"connectionManager"),k(this,"events"),this.log=t.logger.forComponent("libp2p:reconnect-queue"),this.peerStore=t.peerStore,this.connectionManager=t.connectionManager,this.queue=new Ht({concurrency:e.maxParallelReconnects??5,metricName:"libp2p_reconnect_queue",metrics:t.metrics}),this.started=!1,this.retries=e.retries??5,this.backoffFactor=e.backoffFactor,this.retryInterval=e.retryInterval,this.events=t.events,t.events.addEventListener("peer:disconnect",t=>{this.maybeReconnect(t.detail).catch(e=>{this.log.error("failed to maybe reconnect to %p - %e",t.detail,e)})})}async maybeReconnect(t){if(!this.started)return;const e=await this.peerStore.get(t);Fs(e)&&(this.queue.has(t)||this.queue.add(async e=>{await async function(t,e){return new Promise((n,r)=>{(e={...e}).onFailedAttempt??(e.onFailedAttempt=()=>{}),e.shouldRetry??(e.shouldRetry=()=>!0),e.retries??(e.retries=10);const s=Cs.operation(e),i=()=>{var t;s.stop(),r(null==(t=e.signal)?void 0:t.reason)};e.signal&&!e.signal.aborted&&e.signal.addEventListener("abort",i,{once:!0});const o=()=>{var t;null==(t=e.signal)||t.removeEventListener("abort",i),s.stop()};s.attempt(async i=>{try{const e=await t(i);o(),n(e)}catch(a){try{if(!(a instanceof Error))throw new TypeError(`Non-error was thrown: "${a}". You should only throw errors.`);if(a instanceof Ts)throw a.originalError;if(a instanceof TypeError&&!_s(a))throw a;if(Ds(a,i,e),await e.shouldRetry(a)||(s.stop(),r(a)),await e.onFailedAttempt(a),!s.retry(a))throw s.mainError()}catch(l){Ds(l,i,e),o(),r(l)}}})})}(async n=>{if(this.started)try{await this.connectionManager.openConnection(t,{signal:null==e?void 0:e.signal})}catch(r){throw this.log("reconnecting to %p attempt %d of %d failed - %e",t,n,this.retries,r),r}},{signal:null==e?void 0:e.signal,retries:this.retries,factor:this.backoffFactor,minTimeout:this.retryInterval})},{peerId:t}).catch(async n=>{this.log.error("failed to reconnect to %p - %e",t,n);const r={};[...e.tags.keys()].forEach(t=>{t.startsWith(Yt)&&(r[t]=void 0)}),await this.peerStore.merge(t,{tags:r}),this.events.safeDispatchEvent("peer:reconnect-failure",{detail:t})}).catch(async e=>{this.log.error("failed to remove keep-alive tag from %p - %e",t,e)}))}start(){this.started=!0}async afterStart(){Promise.resolve().then(async()=>{const t=await this.peerStore.all({filters:[t=>Fs(t)]});await Promise.all(t.map(async t=>{await this.connectionManager.openConnection(t.id).catch(t=>{this.log.error(t)})}))}).catch(t=>{this.log.error(t)})}stop(){this.started=!1,this.queue.abort()}}function Fs(t){for(const e of t.tags.keys())if(e.startsWith(Yt))return!0;return!1}const Rs=50,Ns=100,qs=5,$s=10;l=Symbol.toStringTag;class Os{constructor(t,e={}){var n;if(k(this,"started"),k(this,"connections"),k(this,"allow"),k(this,"deny"),k(this,"maxIncomingPendingConnections"),k(this,"incomingPendingConnections"),k(this,"outboundPendingConnections"),k(this,"maxConnections"),k(this,"dialQueue"),k(this,"reconnectQueue"),k(this,"connectionPruner"),k(this,"inboundConnectionRateLimiter"),k(this,"peerStore"),k(this,"metrics"),k(this,"events"),k(this,"log"),k(this,"peerId"),k(this,l,"@libp2p/connection-manager"),this.maxConnections=e.maxConnections??Ns,this.maxConnections<1)throw new C("Connection Manager maxConnections must be greater than 0");this.connections=new jt,this.started=!1,this.peerId=t.peerId,this.peerStore=t.peerStore,this.metrics=t.metrics,this.events=t.events,this.log=t.logger.forComponent("libp2p:connection-manager"),this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.allow=(e.allow??[]).map(t=>ls(t)),this.deny=(e.deny??[]).map(t=>ls(t)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=e.maxIncomingPendingConnections??$s,this.outboundPendingConnections=0,this.inboundConnectionRateLimiter=new ss({points:e.inboundConnectionThreshold??qs,duration:1}),this.connectionPruner=new cs({connectionManager:this,peerStore:t.peerStore,events:t.events,logger:t.logger},{allow:null==(n=e.allow)?void 0:n.map(t=>yt(t))}),this.dialQueue=new As(t,{addressSorter:e.addressSorter,maxParallelDials:e.maxParallelDials??50,maxDialQueueLength:e.maxDialQueueLength??500,maxPeerAddrsToDial:e.maxPeerAddrsToDial??25,dialTimeout:e.dialTimeout??1e4,resolvers:e.resolvers??{dnsaddr:Kn},connections:this.connections}),this.reconnectQueue=new Ls({events:t.events,peerStore:t.peerStore,logger:t.logger,connectionManager:this},{retries:e.reconnectRetries,retryInterval:e.reconnectRetryInterval,backoffFactor:e.reconnectBackoffFactor,maxParallelReconnects:e.maxParallelReconnects})}async start(){var t,e,n;null==(t=this.metrics)||t.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const t={inbound:0,"inbound pending":this.incomingPendingConnections,outbound:0,"outbound pending":this.outboundPendingConnections};for(const e of this.connections.values())for(const n of e)t[n.direction]++;return t}}),null==(e=this.metrics)||e.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const t={};for(const e of this.connections.values())for(const n of e)for(const e of n.streams){const n=`${e.direction} ${e.protocol??"unnegotiated"}`;t[n]=(t[n]??0)+1}return t}}),null==(n=this.metrics)||n.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const t={};for(const n of this.connections.values())for(const e of n){const n={};for(const t of e.streams){const e=`${t.direction} ${t.protocol??"unnegotiated"}`;n[e]=(n[e]??0)+1}for(const[e,r]of Object.entries(n))t[e]=t[e]??[],t[e].push(r)}const e={};for(let[n,r]of Object.entries(t)){r=r.sort((t,e)=>t-e);const t=Math.floor(.9*r.length);e[n]=r[t]}return e}}),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),await Xt(this.dialQueue,this.reconnectQueue,this.connectionPruner),this.started=!0,this.log("started")}async stop(){this.events.removeEventListener("connection:open",this.onConnect),this.events.removeEventListener("connection:close",this.onDisconnect),await Jt(this.reconnectQueue,this.dialQueue,this.connectionPruner);const t=[];for(const e of this.connections.values())for(const n of e)t.push((async()=>{try{await n.close()}catch(t){this.log.error(t)}})());this.log("closing %d connections",t.length),await Promise.all(t),this.connections.clear(),this.log("stopped")}getMaxConnections(){return this.maxConnections}setMaxConnections(t){if(this.maxConnections<1)throw new C("Connection Manager maxConnections must be greater than 0");let e=!1;t<this.maxConnections&&(e=!0),this.maxConnections=t,e&&this.connectionPruner.maybePruneConnections()}onConnect(t){this._onConnect(t).catch(t=>{this.log.error(t)})}async _onConnect(t){const{detail:e}=t;if(!this.started)return void(await e.close());if("open"!==e.status)return;const n=e.remotePeer,r=!this.connections.has(n),s=this.connections.get(n)??[];s.push(e),this.connections.set(n,s),null!=n.publicKey&&"RSA"===n.type&&await this.peerStore.patch(n,{publicKey:n.publicKey}),r&&this.events.safeDispatchEvent("peer:connect",{detail:e.remotePeer})}onDisconnect(t){const{detail:e}=t,n=e.remotePeer,r=(this.connections.get(n)??[]).filter(t=>t.id!==e.id);this.connections.set(n,r),0===r.length&&(this.log("onDisconnect remove all connections for peer %p",n),this.connections.delete(n),this.events.safeDispatchEvent("peer:disconnect",{detail:e.remotePeer}))}getConnections(t){if(null!=t)return this.connections.get(t)??[];let e=[];for(const n of this.connections.values())e=e.concat(n);return e}getConnectionsMap(){return this.connections}async openConnection(t,e={}){var n,r;if(!this.started)throw new U("Not started");this.outboundPendingConnections++;try{null==(n=e.signal)||n.throwIfAborted();const{peerId:s}=os(t);if(this.peerId.equals(s))throw new j("Can not dial self");if(null!=s&&!0!==e.force){this.log("dial %p",s);const t=this.getConnections(s).find(t=>null==t.limits);if(null!=t)return this.log("had an existing non-limited connection to %p",s),null==(r=e.onProgress)||r.call(e,new Se("dial-queue:already-connected")),t}const i=await this.dialQueue.dial(t,{...e,priority:e.priority??Rs});if("open"!==i.status)throw new V("Remote closed connection during opening");let o=this.connections.get(i.remotePeer);null==o&&(o=[],this.connections.set(i.remotePeer,o));let a=!1;for(const t of o)if(t.id===i.id&&(a=!0),!0!==e.force&&t.id!==i.id&&t.remoteAddr.equals(i.remoteAddr))return i.abort(new q("Duplicate multiaddr connection")),t;return a||o.push(i),i}finally{this.outboundPendingConnections--}}async closeConnections(t,e={}){const n=this.connections.get(t)??[];await Promise.all(n.map(async t=>{try{await t.close(e)}catch(n){t.abort(n)}}))}async acceptIncomingConnection(t){if(this.deny.some(e=>e.contains(t.remoteAddr.nodeAddress().address)))return this.log("connection from %a refused - connection remote address was in deny list",t.remoteAddr),!1;if(this.allow.some(e=>e.contains(t.remoteAddr.nodeAddress().address)))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return this.log("connection from %a refused - incomingPendingConnections exceeded by host",t.remoteAddr),!1;if(t.remoteAddr.isThinWaistAddress()){const e=t.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(e,1)}catch{return this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s",t.remoteAddr,e),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(this.log("connection from %a refused - maxConnections exceeded",t.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){const t={queued:"queued",running:"active",errored:"error",complete:"success"};return this.dialQueue.queue.queue.map(e=>({id:e.id,status:t[e.status],peerId:e.options.peerId,multiaddrs:[...e.options.multiaddrs].map(t=>yt(t))}))}async isDialable(t,e={}){return this.dialQueue.isDialable(t,e)}}class Ks{constructor(t){k(this,"movingAverage"),k(this,"variance"),k(this,"deviation"),k(this,"forecast"),k(this,"timeSpan"),k(this,"previousTime"),this.timeSpan=t,this.movingAverage=0,this.variance=0,this.deviation=0,this.forecast=0}alpha(t,e){return 1-Math.exp(-(t-e)/this.timeSpan)}push(t,e=Date.now()){if(null!=this.previousTime){const n=this.alpha(e,this.previousTime),r=t-this.movingAverage,s=n*r;this.movingAverage=n*t+(1-n)*this.movingAverage,this.variance=(1-n)*(this.variance+r*s),this.deviation=Math.sqrt(this.variance),this.forecast=this.movingAverage+n*r}else this.movingAverage=t;this.previousTime=e}}class Us{constructor(t={}){var e;k(this,"success"),k(this,"failure"),k(this,"next"),k(this,"metric"),k(this,"timeoutMultiplier"),k(this,"failureMultiplier"),k(this,"minTimeout"),k(this,"maxTimeout");const n=t.interval??5e3;this.success=new Ks(n),this.failure=new Ks(n),this.next=new Ks(n),this.failureMultiplier=t.failureMultiplier??2,this.timeoutMultiplier=t.timeoutMultiplier??1.2,this.minTimeout=t.minTimeout??5e3,this.maxTimeout=t.maxTimeout??6e4,null!=t.metricName&&(this.metric=null==(e=t.metrics)?void 0:e.registerMetricGroup(t.metricName))}getTimeoutSignal(t={}){let e=Math.round(this.next.movingAverage*(t.timeoutFactor??this.timeoutMultiplier));e<this.minTimeout&&(e=this.minTimeout),e>this.maxTimeout&&(e=this.maxTimeout);const n=AbortSignal.timeout(e),r=Qt([t.signal,n]);return r.start=Date.now(),r.timeout=e,r}cleanUp(t){var e,n;const r=Date.now()-t.start;t.aborted?(this.failure.push(r),this.next.push(r*this.failureMultiplier),null==(e=this.metric)||e.update({failureMovingAverage:this.failure.movingAverage,failureDeviation:this.failure.deviation,failureForecast:this.failure.forecast,failureVariance:this.failure.variance,failure:r})):(this.success.push(r),this.next.push(r),null==(n=this.metric)||n.update({successMovingAverage:this.success.movingAverage,successDeviation:this.success.deviation,successForecast:this.success.forecast,successVariance:this.success.variance,success:r}))}}d=Symbol.toStringTag,c=$t;class js{constructor(t,e={}){k(this,"protocol"),k(this,"components"),k(this,"log"),k(this,"heartbeatInterval"),k(this,"pingIntervalMs"),k(this,"abortController"),k(this,"timeout"),k(this,"abortConnectionOnPingFailure"),k(this,d,"@libp2p/connection-monitor"),k(this,c,["@libp2p/connection-monitor"]),this.components=t,this.protocol=`/${e.protocolPrefix??"ipfs"}/ping/1.0.0`,this.log=t.logger.forComponent("libp2p:connection-monitor"),this.pingIntervalMs=e.pingInterval??1e4,this.abortConnectionOnPingFailure=e.abortConnectionOnPingFailure??true,this.timeout=new Us({...e.pingTimeout??{},metrics:t.metrics,metricName:"libp2p_connection_monitor_ping_time_milliseconds"})}start(){this.abortController=new AbortController,at(1/0,this.abortController.signal),this.heartbeatInterval=setInterval(()=>{this.components.connectionManager.getConnections().forEach(t=>{Promise.resolve().then(async()=>{var e;let n=Date.now();try{const r=this.timeout.getTimeoutSignal({signal:null==(e=this.abortController)?void 0:e.signal}),s=await t.newStream(this.protocol,{signal:r,runOnLimitedConnection:!0}),i=Zt(s);n=Date.now(),await Promise.all([i.write(ln(32),{signal:r}),i.read({bytes:32,signal:r})]),t.rtt=Date.now()-n,await i.unwrap().close({signal:r})}catch(r){if("UnsupportedProtocolError"!==r.name)throw r;t.rtt=(Date.now()-n)/2}}).catch(e=>{this.log.error("error during heartbeat",e),this.abortConnectionOnPingFailure?(this.log.error("aborting connection due to ping failure"),t.abort(e)):this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag")})})},this.pingIntervalMs)}stop(){var t;null==(t=this.abortController)||t.abort(),null!=this.heartbeatInterval&&clearInterval(this.heartbeatInterval)}}u=Symbol.toStringTag;class Vs{constructor(t,e){var n,r,s,i,o;k(this,"routers"),k(this,"started"),k(this,"components"),k(this,u,"@libp2p/content-routing"),this.routers=e.routers??[],this.started=!1,this.components=t,this.findProviders=(null==(n=t.metrics)?void 0:n.traceFunction("libp2p.contentRouting.findProviders",this.findProviders.bind(this),{optionsIndex:1,getAttributesFromArgs:([t],e)=>({...e,cid:t.toString()}),getAttributesFromYieldedValue:(t,e)=>({...e,providers:[...Array.isArray(e.providers)?e.providers:[],t.id.toString()]})}))??this.findProviders,this.provide=(null==(r=t.metrics)?void 0:r.traceFunction("libp2p.contentRouting.provide",this.provide.bind(this),{optionsIndex:1,getAttributesFromArgs:([t],e)=>({...e,cid:t.toString()})}))??this.provide,this.cancelReprovide=(null==(s=t.metrics)?void 0:s.traceFunction("libp2p.contentRouting.cancelReprovide",this.cancelReprovide.bind(this),{optionsIndex:1,getAttributesFromArgs:([t],e)=>({...e,cid:t.toString()})}))??this.cancelReprovide,this.put=(null==(i=t.metrics)?void 0:i.traceFunction("libp2p.contentRouting.put",this.put.bind(this),{optionsIndex:2,getAttributesFromArgs:([t])=>({key:z(t,"base36")})}))??this.put,this.get=(null==(o=t.metrics)?void 0:o.traceFunction("libp2p.contentRouting.get",this.get.bind(this),{optionsIndex:1,getAttributesFromArgs:([t])=>({key:z(t,"base36")})}))??this.get}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(t,e={}){if(0===this.routers.length)throw new Lr("No content routers available");const n=this,r=new xn;for await(const s of ae(...n.routers.filter(t=>t.findProviders instanceof Function).map(n=>n.findProviders(t,e))))null!=s&&(s.multiaddrs.length>0&&await this.components.peerStore.merge(s.id,{multiaddrs:s.multiaddrs},e),r.has(s.id)||(r.add(s.id),yield s))}async provide(t,e={}){if(0===this.routers.length)throw new Lr("No content routers available");await Promise.all(this.routers.filter(t=>t.provide instanceof Function).map(async n=>{await n.provide(t,e)}))}async cancelReprovide(t,e={}){if(0===this.routers.length)throw new Lr("No content routers available");await Promise.all(this.routers.filter(t=>t.cancelReprovide instanceof Function).map(async n=>{await n.cancelReprovide(t,e)}))}async put(t,e,n){if(!this.isStarted())throw new U;await Promise.all(this.routers.filter(t=>t.put instanceof Function).map(async r=>{await r.put(t,e,n)}))}async get(t,e){if(!this.isStarted())throw new U;return Promise.any(this.routers.filter(t=>t.get instanceof Function).map(async n=>n.get(t,e)))}}h=Symbol.toStringTag;class zs{constructor(t,e={}){var n,r;k(this,"log"),k(this,"peerId"),k(this,"peerStore"),k(this,"routers"),k(this,h,"@libp2p/peer-routing"),this.log=t.logger.forComponent("libp2p:peer-routing"),this.peerId=t.peerId,this.peerStore=t.peerStore,this.routers=e.routers??[],this.findPeer=(null==(n=t.metrics)?void 0:n.traceFunction("libp2p.peerRouting.findPeer",this.findPeer.bind(this),{optionsIndex:1,getAttributesFromArgs:([t],e)=>({...e,peer:t.toString()})}))??this.findPeer,this.getClosestPeers=(null==(r=t.metrics)?void 0:r.traceFunction("libp2p.peerRouting.getClosestPeers",this.getClosestPeers.bind(this),{optionsIndex:1,getAttributesFromArgs:([t],e)=>({...e,key:z(t,"base36")}),getAttributesFromYieldedValue:(t,e)=>({...e,peers:[...Array.isArray(e.peers)?e.peers:[],t.id.toString()]})}))??this.getClosestPeers}async findPeer(t,e){if(0===this.routers.length)throw new Fr("No peer routers available");if(t.toString()===this.peerId.toString())throw new Rr("Should not try to find self");const n=this,r=ae(...this.routers.filter(t=>t.findPeer instanceof Function).map(r=>async function*(){try{yield await r.findPeer(t,e)}catch(s){n.log.error(s)}}()));for await(const s of r)if(null!=s)return s.multiaddrs.length>0&&await this.peerStore.merge(s.id,{multiaddrs:s.multiaddrs},e),s;throw new F}async*getClosestPeers(t,e={}){if(0===this.routers.length)throw new Fr("No peer routers available");const n=this,r=oe(1024);for await(const s of nt(async function*(){const r=ae(...n.routers.filter(t=>t.getClosestPeers instanceof Function).map(n=>n.getClosestPeers(t,e)));for await(let t of r)yield async()=>{if(0===t.multiaddrs.length)try{t=await n.findPeer(t.id,{...e,useCache:!1})}catch(r){return void n.log.error("could not find peer multiaddrs",r)}return t}}()))null!=s&&(s.multiaddrs.length>0&&await this.peerStore.merge(s.id,{multiaddrs:s.multiaddrs},e),r.has(s.id.toMultihash().bytes)||(r.add(s.id.toMultihash().bytes),yield s))}}class Ws extends(m=lt,p=Symbol.toStringTag,m){constructor(t){super(),k(this,"peerRouting"),k(this,"log"),k(this,"walking"),k(this,"walkers"),k(this,"shutdownController"),k(this,"walkController"),k(this,"needNext"),k(this,p,"@libp2p/random-walk"),this.log=t.logger.forComponent("libp2p:random-walk"),this.peerRouting=t.peerRouting,this.walkers=0,this.walking=!1,this.shutdownController=new AbortController,at(1/0,this.shutdownController.signal)}start(){this.shutdownController=new AbortController,at(1/0,this.shutdownController.signal)}stop(){this.shutdownController.abort()}async*walk(t){var e,n;this.walking||this.startWalk(),this.walkers++;const r=Qt([this.shutdownController.signal,null==t?void 0:t.signal]);try{for(;;){null==(e=this.needNext)||e.resolve(),this.needNext=le();const t=await ct(this,"walk:peer",r,{errorEvent:"walk:error"});yield t.detail}}finally{r.clear(),this.walkers--,0===this.walkers&&(null==(n=this.walkController)||n.abort(),this.walkController=void 0)}}startWalk(){this.walking=!0,this.walkController=new AbortController,at(1/0,this.walkController.signal);const t=Qt([this.walkController.signal,this.shutdownController.signal]),e=Date.now();let n=0;Promise.resolve().then(async()=>{for(this.log("start walk");this.walkers>0;)try{const e=ln(32);let r=Date.now();for await(const s of this.peerRouting.getClosestPeers(e,{signal:t}))t.aborted&&this.log("aborting walk"),t.throwIfAborted(),this.log("found peer %p after %dms for %d walkers",s.id,Date.now()-r,this.walkers),n++,this.safeDispatchEvent("walk:peer",{detail:s}),1===this.walkers&&null!=this.needNext&&(this.log("wait for need next"),await se(this.needNext.promise,t)),r=Date.now();this.log("walk iteration for %b and %d walkers finished, found %d peers",e,this.walkers,n)}catch(e){this.log.error("random walk errored",e),this.safeDispatchEvent("walk:error",{detail:e})}this.log("no walkers left, ended walk")}).catch(t=>{this.log.error("random walk errored",t)}).finally(()=>{this.log("finished walk, found %d peers after %dms",n,Date.now()-e),this.walking=!1})}}g=Symbol.toStringTag;class Bs{constructor(t){var e;k(this,"log"),k(this,"topologies"),k(this,"handlers"),k(this,"components"),k(this,g,"@libp2p/registrar"),this.components=t,this.log=t.logger.forComponent("libp2p:registrar"),this.topologies=new Map,null==(e=t.metrics)||e.registerMetricGroup("libp2p_registrar_topologies",{calculate:()=>{const t={};for(const[e,n]of this.topologies)t[e]=n.size;return t}}),this.handlers=Pn({name:"libp2p_registrar_protocol_handlers",metrics:t.metrics}),this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onPeerIdentify=this._onPeerIdentify.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate),this.components.events.addEventListener("peer:identify",this._onPeerIdentify)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(t){const e=this.handlers.get(t);if(null==e)throw new Nr(`No handler registered for protocol ${t}`);return e}getTopologies(t){const e=this.topologies.get(t);return null==e?[]:[...e.values()]}async handle(t,e,n){if(this.handlers.has(t)&&!0!==(null==n?void 0:n.force))throw new qr(`Handler already registered for protocol ${t}`);const r=et.bind({ignoreUndefined:!0})({maxInboundStreams:32,maxOutboundStreams:64},n);this.handlers.set(t,{handler:e,options:r}),await this.components.peerStore.merge(this.components.peerId,{protocols:[t]},n)}async unhandle(t,e){(Array.isArray(t)?t:[t]).forEach(t=>{this.handlers.delete(t)}),await this.components.peerStore.patch(this.components.peerId,{protocols:this.getProtocols()},e)}async register(t,e){if(null==e)throw new C("invalid topology");const n=`${(1e9*Math.random()).toString(36)}${Date.now()}`;let r=this.topologies.get(t);return null==r&&(r=new Map,this.topologies.set(t,r)),r.set(n,e),n}unregister(t){for(const[e,n]of this.topologies.entries())n.has(t)&&(n.delete(t),0===n.size&&this.topologies.delete(e))}_onDisconnect(t){const e=t.detail,n={signal:AbortSignal.timeout(5e3)};this.components.peerStore.get(e,n).then(t=>{var n,r,s;for(const i of t.protocols){const t=this.topologies.get(i);if(null!=t)for(const i of t.values())!1!==(null==(n=i.filter)?void 0:n.has(e))&&(null==(r=i.filter)||r.remove(e),null==(s=i.onDisconnect)||s.call(i,e))}}).catch(t=>{"NotFoundError"!==t.name&&this.log.error("could not inform topologies of disconnecting peer %p",e,t)})}_onPeerUpdate(t){var e,n,r;const{peer:s,previous:i}=t.detail,o=((null==i?void 0:i.protocols)??[]).filter(t=>!s.protocols.includes(t));for(const a of o){const t=this.topologies.get(a);if(null!=t)for(const i of t.values())!1!==(null==(e=i.filter)?void 0:e.has(s.id))&&(null==(n=i.filter)||n.remove(s.id),null==(r=i.onDisconnect)||r.call(i,s.id))}}_onPeerIdentify(t){var e,n,r;const s=t.detail.protocols,i=t.detail.connection,o=t.detail.peerId;for(const a of s){const t=this.topologies.get(a);if(null!=t)for(const s of t.values())null!=i.limits&&!0!==s.notifyOnLimitedConnection||!0!==(null==(e=s.filter)?void 0:e.has(o))&&(null==(n=s.filter)||n.add(o),null==(r=s.onConnect)||r.call(s,o,i))}}}f=Symbol.toStringTag;class Gs{constructor(t,e={}){k(this,"log"),k(this,"components"),k(this,"transports"),k(this,"listeners"),k(this,"faultTolerance"),k(this,"started"),k(this,f,"@libp2p/transport-manager"),this.log=t.logger.forComponent("libp2p:transports"),this.components=t,this.started=!1,this.transports=Pn({name:"libp2p_transport_manager_transports",metrics:this.components.metrics}),this.listeners=Pn({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=e.faultTolerance??vt.FATAL_ALL}add(t){const e=t[Symbol.toStringTag];if(null==e)throw new C("Transport must have a valid tag");if(this.transports.has(e))throw new C(`There is already a transport with the tag ${e}`);this.log("adding transport %s",e),this.transports.set(e,t),this.listeners.has(e)||this.listeners.set(e,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const t=this.components.addressManager.getListenAddrs();await this.listen(t)}async stop(){const t=[];for(const[e,n]of this.listeners)for(this.log("closing listeners for %s",e);n.length>0;){const e=n.pop();null!=e&&t.push(e.close())}await Promise.all(t),this.log("all listeners closed");for(const e of this.listeners.keys())this.listeners.set(e,[]);this.started=!1}async dial(t,e){var n;const r=this.dialTransportForMultiaddr(t);if(null==r)throw new Br(`No transport available for address ${String(t)}`);return null==(n=null==e?void 0:e.onProgress)||n.call(e,new Se("transport-manager:selected-transport",r[Symbol.toStringTag])),r.dial(t,{...e,upgrader:this.components.upgrader})}getAddrs(){let t=[];for(const e of this.listeners.values())for(const n of e)t=[...t,...n.getAddrs()];return t}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}dialTransportForMultiaddr(t){for(const e of this.transports.values()){if(e.dialFilter([t]).length>0)return e}}listenTransportForMultiaddr(t){for(const e of this.transports.values()){if(e.listenFilter([t]).length>0)return e}}async listen(t){if(!this.isStarted())throw new U("Not started");if(null==t||0===t.length)return void this.log("no addresses were provided for listening, this node is dial only");const e={errors:new Map,ipv4:{success:0,attempts:0},ipv6:{success:0,attempts:0}};t.forEach(t=>{e.errors.set(t.toString(),new Or)});const n=[];for(const[s,i]of this.transports.entries()){const r=i.listenFilter(t);for(const t of r){this.log("creating listener for %s on %a",s,t);const r=i.createListener({upgrader:this.components.upgrader});let o=this.listeners.get(s)??[];null==o&&(o=[],this.listeners.set(s,o)),o.push(r),r.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:r})}),r.addEventListener("close",()=>{const t=o.findIndex(t=>t===r);o.splice(t,1),this.components.events.safeDispatchEvent("transport:close",{detail:r})}),te.matches(t)?e.ipv4.attempts++:ee.matches(t)&&e.ipv6.attempts++,n.push(r.listen(t).then(()=>{e.errors.delete(t.toString()),te.matches(t)&&e.ipv4.success++,ee.matches(t)&&e.ipv6.success++},n=>{throw this.log.error("transport %s could not listen on address %a - %e",s,t,n),e.errors.set(t.toString(),n),n}))}}const r=await Promise.allSettled(n);if(!(r.length>0&&r.every(t=>"fulfilled"===t.status)))if(this.ipv6Unsupported(e))this.log("all IPv4 addresses succeed but all IPv6 failed");else{if(this.faultTolerance!==vt.NO_FATAL)throw new Kr(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:\n${[...e.errors.entries()].map(([t,e])=>`\n  ${t}: ${`${e.stack??e}`.split("\n").join("\n  ")}\n`).join("")}`);this.log("failed to listen on any address but fault tolerance allows this")}}ipv6Unsupported(t){if(0===t.ipv4.attempts||0===t.ipv6.attempts)return!1;const e=t.ipv4.attempts===t.ipv4.success,n=0===t.ipv6.success;return e&&n}async remove(t){const e=this.listeners.get(t)??[];this.log.trace("removing transport %s",t);const n=[];for(this.log.trace("closing listeners for %s",t);e.length>0;){const t=e.pop();null!=t&&n.push(t.close())}await Promise.all(n),this.transports.delete(t),this.listeners.delete(t)}async removeAll(){const t=[];for(const e of this.transports.keys())t.push(this.remove(e));await Promise.all(t)}}const Qs="/multistream/1.0.0",Hs=1024,Ys=xe("\n");async function Xs(t,e,n){await t.write(e,n)}async function Js(t,e){const n=await async function(t,e){const n=await t.read(e);if(0===n.byteLength||n.get(n.byteLength-1)!==Ys[0])throw e.log.error("Invalid mss message - missing newline",n),new W("Missing newline");return n.sublist(0,-1)}(t,e);return z(n.subarray())}async function Zs(t,e,n){if(1===(e=Array.isArray(e)?[...e]:[e]).length&&!1===n.negotiateFully)return function(t,e,n){const r=t.sink.bind(t),s=t.source;let i=!1,o=!1;const a=le();let l=!1,c=!1;const d=le();let u=!1,h=!1;const p=le(),m=ne({sink:r,source:s},{...n,maxDataLength:Hs});async function g(){if(o)return n.log.trace("optimistic: already negotiating %s stream",e),void(await a.promise);o=!0;try{l||(n.log.trace("optimistic: doing send protocol for %s stream",e),await f()),u||(n.log.trace("optimistic: doing read protocol for %s stream",e),await y())}finally{o=!1,i=!0,a.resolve()}}async function f(){if(c)await d.promise;else{c=!0;try{n.log.trace('optimistic: write ["%s", "%s", data] in source',Qs,e),await m.writeV([xe(`${Qs}\n`),xe(`${e}\n`)]),n.log.trace('optimistic: wrote ["%s", "%s", data] in source',Qs,e)}finally{l=!0,c=!1,d.resolve()}}}async function y(){if(h)await p.promise;else{h=!0;try{n.log.trace("optimistic: reading multistream select header");let t=await Js(m,n);if(n.log.trace('optimistic: read multistream select header "%s"',t),t===Qs&&(t=await Js(m,n)),n.log.trace('optimistic: read protocol "%s", expecting "%s"',t,e),t!==e)throw new B("protocol selection failed")}finally{u=!0,h=!1,p.resolve()}}}if(t.sink=async t=>{const{sink:r}=m.unwrap();await r(async function*(){let r=!1;for await(const s of t){if(c&&await d.promise,l)yield s;else{c=!0,n.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink',Qs,e,s.byteLength);const t=`${e}\n`;yield new he(Uint8Array.from([19]),xe(`${Qs}\n`),de(t.length),xe(t),s).subarray(),n.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink',Qs,e,s.byteLength),l=!0,c=!1,d.resolve(),g().catch(t=>{n.log.error("could not finish optimistic protocol negotiation of %s",e,t)})}r=!0}r||await g()}())},t.source=async function*(){await g(),n.log.trace('optimistic: reading data from "%s" stream',e),yield*m.unwrap().source}(),null!=t.closeRead){const e=t.closeRead.bind(t);t.closeRead=async t=>{i||await g().catch(t=>{n.log.error("could not negotiate protocol before close read",t)}),await e(t)}}if(null!=t.closeWrite){const e=t.closeWrite.bind(t);t.closeWrite=async t=>{i||await g().catch(t=>{n.log.error("could not negotiate protocol before close write",t)}),await e(t)}}if(null!=t.close){const e=t.close.bind(t);t.close=async t=>{const n=[];c&&n.push(d.promise),h&&n.push(p.promise),n.length>0?await se(Promise.all(n),null==t?void 0:t.signal):(i=!0,o=!1,a.resolve()),await e(t)}}return{stream:t,protocol:e}}(t,e[0],n);const r=ne(t,{...n,maxDataLength:Hs}),s=e.shift();if(null==s)throw new Error("At least one protocol must be specified");n.log.trace('select: write ["%s", "%s"]',Qs,s);const i=xe(`${Qs}\n`),o=xe(`${s}\n`);await async function(t,e,n){await t.writeV(e,n)}(r,[i,o],n),n.log.trace("select: reading multistream-select header");let a=await Js(r,n);if(n.log.trace('select: read "%s"',a),a===Qs&&(n.log.trace("select: reading protocol response"),a=await Js(r,n),n.log.trace('select: read "%s"',a)),a===s)return{stream:r.unwrap(),protocol:s};for(const l of e){n.log.trace('select: write "%s"',l),await Xs(r,xe(`${l}\n`),n),n.log.trace("select: reading protocol response");const t=await Js(r,n);if(n.log.trace('select: read "%s" for "%s"',t,l),t===l)return{stream:r.unwrap(),protocol:l}}throw new B("protocol selection failed")}async function ti(t,e,n){e=Array.isArray(e)?e:[e],n.log.trace("handle: available protocols %s",e);const r=ne(t,{...n,maxDataLength:Hs,maxLengthLength:2});for(;;){n.log.trace("handle: reading incoming string");const t=await Js(r,n);if(n.log.trace('handle: read "%s"',t),t!==Qs){if(e.includes(t))return n.log.trace('handle: respond with "%s" for "%s"',t,t),await Xs(r,xe(`${t}\n`),n),n.log.trace('handle: responded with "%s" for "%s"',t,t),{stream:r.unwrap(),protocol:t};if("ls"===t){const s=new he(...e.map(t=>yn.single(xe(`${t}\n`))),xe("\n"));n.log.trace('handle: respond with "%s" for %s',e,t),await Xs(r,s,n),n.log.trace('handle: responded with "%s" for %s',e,t);continue}n.log.trace('handle: respond with "na" for "%s"',t),await Xs(r,xe("na\n"),n),n.log('handle: responded with "na" for "%s"',t)}else n.log.trace('handle: respond with "%s" for "%s"',Qs,t),await Xs(r,xe(`${Qs}\n`),n),n.log.trace('handle: responded with "%s" for "%s"',Qs,t)}}v=Symbol.toStringTag,y=Ce;class ei{constructor(t){k(this,"id"),k(this,"remoteAddr"),k(this,"remotePeer"),k(this,"direction"),k(this,"timeline"),k(this,"multiplexer"),k(this,"encryption"),k(this,"status"),k(this,"limits"),k(this,"log"),k(this,"tags"),k(this,"_newStream"),k(this,"_close"),k(this,"_abort"),k(this,"_getStreams"),k(this,v,"Connection"),k(this,y,!0);const{remoteAddr:e,remotePeer:n,newStream:r,close:s,abort:i,getStreams:o}=t;this.id=`${parseInt(String(1e9*Math.random())).toString(36)}${Date.now()}`,this.remoteAddr=e,this.remotePeer=n,this.direction=t.direction,this.status="open",this.timeline=t.timeline,this.multiplexer=t.multiplexer,this.encryption=t.encryption,this.limits=t.limits,this.log=t.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`),null==this.remoteAddr.getPeerId()&&(this.remoteAddr=this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)),this._newStream=r,this._close=s,this._abort=i,this._getStreams=o,this.tags=[]}get streams(){return this._getStreams()}async newStream(t,e){if("closing"===this.status)throw new G("the connection is being closed");if("closed"===this.status)throw new V("the connection is closed");if(Array.isArray(t)||(t=[t]),null!=this.limits&&!0!==(null==e?void 0:e.runOnLimitedConnection))throw new Q("Cannot open protocol stream on limited connection");const n=await this._newStream(t,e);return n.direction="outbound",n}async close(t={}){if("closed"!==this.status&&"closing"!==this.status){if(this.log("closing connection to %a",this.remoteAddr),this.status="closing",null==t.signal){const e=AbortSignal.timeout(500);t={...t,signal:e}}try{this.log.trace("closing underlying transport"),await this._close(t),this.log.trace("updating timeline with close time"),this.status="closed",this.timeline.close=Date.now()}catch(e){this.log.error("error encountered during graceful close of connection to %a",this.remoteAddr,e),this.abort(e)}}}abort(t){"closed"!==this.status&&(this.log.error("aborting connection to %a due to error",this.remoteAddr,t),this.status="closing",this._abort(t),this.status="closed",this.timeline.close=Date.now())}}function ni(t,e,n){let r=0;return n.streams.forEach(n=>{n.direction===e&&n.protocol===t&&r++}),r}w=Symbol.toStringTag;class ri{constructor(t,e){var n,r,s,i;k(this,"components"),k(this,"connectionEncrypters"),k(this,"streamMuxers"),k(this,"inboundUpgradeTimeout"),k(this,"inboundStreamProtocolNegotiationTimeout"),k(this,"outboundStreamProtocolNegotiationTimeout"),k(this,"events"),k(this,"metrics"),k(this,w,"@libp2p/upgrader"),this.components=t,this.connectionEncrypters=Pn({name:"libp2p_upgrader_connection_encrypters",metrics:this.components.metrics}),e.connectionEncrypters.forEach(t=>{this.connectionEncrypters.set(t.protocol,t)}),this.streamMuxers=Pn({name:"libp2p_upgrader_stream_multiplexers",metrics:this.components.metrics}),e.streamMuxers.forEach(t=>{this.streamMuxers.set(t.protocol,t)}),this.inboundUpgradeTimeout=e.inboundUpgradeTimeout??1e4,this.inboundStreamProtocolNegotiationTimeout=e.inboundStreamProtocolNegotiationTimeout??1e4,this.outboundStreamProtocolNegotiationTimeout=e.outboundStreamProtocolNegotiationTimeout??1e4,this.events=t.events,this.metrics={dials:null==(n=t.metrics)?void 0:n.registerCounterGroup("libp2p_connection_manager_dials_total"),errors:null==(r=t.metrics)?void 0:r.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),inboundErrors:null==(s=t.metrics)?void 0:s.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),outboundErrors:null==(i=t.metrics)?void 0:i.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")}}async shouldBlockConnection(t,...e){const n=this.components.connectionGater[t];if(null==n)return;if(!0===await n.apply(this.components.connectionGater,e))throw new jr(`The multiaddr connection is blocked by gater.${t}`)}createInboundAbortSignal(t){return Qt([AbortSignal.timeout(this.inboundUpgradeTimeout),t])}async upgradeInbound(t,e){var n,r,s;let i=!1;const o=this.createInboundAbortSignal(e.signal);try{if(null==(n=this.metrics.dials)||n.increment({inbound:!0}),i=await se(this.components.connectionManager.acceptIncomingConnection(t),o),!i)throw new Vr("Connection denied");await se(this.shouldBlockConnection("denyInboundConnection",t),o),await this._performUpgrade(t,"inbound",{...e,signal:o})}catch(a){throw null==(r=this.metrics.errors)||r.increment({inbound:!0}),null==(s=this.metrics.inboundErrors)||s.increment({[a.name??"Error"]:!0}),a}finally{o.clear(),i&&this.components.connectionManager.afterUpgradeInbound()}}async upgradeOutbound(t,e){var n,r,s;try{null==(n=this.metrics.dials)||n.increment({outbound:!0});const r=t.remoteAddr.getPeerId();let s;null!=r&&(s=N(r),await se(this.shouldBlockConnection("denyOutboundConnection",s,t),e.signal));let i="outbound";return!1===e.initiator&&(i="inbound"),await this._performUpgrade(t,i,e)}catch(i){throw null==(r=this.metrics.errors)||r.increment({outbound:!0}),null==(s=this.metrics.outboundErrors)||s.increment({[i.name??"Error"]:!0}),i}}async _performUpgrade(t,e,n){var r,s,i;let o,a,l,c,d;null==(r=this.components.metrics)||r.trackMultiaddrConnection(t),t.log.trace("starting the %s connection upgrade",e);let u=t;if(!0!==(null==n?void 0:n.skipProtection)){const r=this.components.connectionProtector;null!=r&&(t.log("protecting the %s connection",e),u=await r.protect(t,n))}try{if(o=u,!0!==(null==n?void 0:n.skipEncryption)){null==(s=null==n?void 0:n.onProgress)||s.call(n,new Se(`upgrader:encrypt-${e}-connection`)),({conn:o,remotePeer:a,protocol:d,streamMuxer:c}=await("inbound"===e?this._encryptInbound(u,n):this._encryptOutbound(u,n)));const t={...u,...o};await this.shouldBlockConnection("inbound"===e?"denyInboundEncryptedConnection":"denyOutboundEncryptedConnection",a,t)}else{const n=t.remoteAddr.getPeerId();if(null==n)throw new q(`${e} connection that skipped encryption must have a peer id`);const r=N(n);d="native",a=r}if(a.equals(this.components.peerId)){const e=new j("Can not dial self");throw t.abort(e),e}if(l=o,null!=(null==n?void 0:n.muxerFactory))c=n.muxerFactory;else if(null==c&&this.streamMuxers.size>0){null==(i=null==n?void 0:n.onProgress)||i.call(n,new Se(`upgrader:multiplex-${e}-connection`));const t=await("inbound"===e?this._multiplexInbound({...u,...o},this.streamMuxers,n):this._multiplexOutbound({...u,...o},this.streamMuxers,n));c=t.muxerFactory,l=t.stream}}catch(h){throw t.log.error("failed to upgrade inbound connection %s %a - %e","inbound"===e?"from":"to",t.remoteAddr,h),h}return await this.shouldBlockConnection("inbound"===e?"denyInboundUpgradedConnection":"denyOutboundUpgradedConnection",a,t),t.log("successfully upgraded %s connection",e),this._createConnection({cryptoProtocol:d,direction:e,maConn:t,upgradedConn:l,muxerFactory:c,remotePeer:a,limits:null==n?void 0:n.limits})}_createConnection(t){const{cryptoProtocol:e,direction:n,maConn:r,upgradedConn:s,remotePeer:i,muxerFactory:o,limits:a}=t;let l,c,d;null!=o&&(l=o.createStreamMuxer({direction:n,onIncomingStream:t=>{if(null==d)return;const e=AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);Promise.resolve().then(async()=>{var n;const r=this.components.registrar.getProtocols(),{stream:s,protocol:o}=await ti(t,r,{signal:e,log:t.log,yieldBytes:!1});if(null==d)return;d.log("incoming stream opened on %s",o);const a=function(t,e){try{const{options:n}=e.getHandler(t);return n.maxInboundStreams}catch(n){if("UnhandledProtocolError"!==n.name)throw n}return 32}(o,this.components.registrar);if(ni(o,"inbound",d)===a){const e=new H(`Too many inbound protocol streams for protocol "${o}" - limit ${a}`);throw t.abort(e),e}t.source=s.source,t.sink=s.sink,t.protocol=o,null!=s.closeWrite&&(t.closeWrite=s.closeWrite),null!=s.closeRead&&(t.closeRead=s.closeRead),null!=s.close&&(t.close=s.close),await this.components.peerStore.merge(i,{protocols:[o]},{signal:e}),null==(n=this.components.metrics)||n.trackProtocolStream(t,d),this._onStream({connection:d,stream:t,protocol:o})}).catch(async n=>{d.log.error("error handling incoming stream id %s - %e",t.id,n),null==t.timeline.close&&await t.close({signal:e}).catch(e=>t.abort(e))})}}),c=async(e,r={})=>{var s;if(null==l)throw new zr("Connection is not multiplexed");d.log.trace("starting new stream for protocols %s",e);const o=await l.newStream();d.log.trace("started new stream %s for protocols %s",o.id,e);try{if(null==r.signal){o.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout",e);const t=AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);at(1/0,t),r={...r,signal:t}}o.log.trace("selecting protocol from protocols %s",e);const{stream:t,protocol:n}=await Zs(o,e,{...r,log:o.log,yieldBytes:!0});o.log.trace("selected protocol %s",n);const a=function(t,e,n={}){try{const{options:n}=e.getHandler(t);if(null!=n.maxOutboundStreams)return n.maxOutboundStreams}catch(r){if("UnhandledProtocolError"!==r.name)throw r}return n.maxOutboundStreams??64}(n,this.components.registrar,r),l=ni(n,"outbound",d);if(l>=a){const t=new Y(`Too many outbound protocol streams for protocol "${n}" - ${l}/${a}`);throw o.abort(t),t}return await this.components.peerStore.merge(i,{protocols:[n]}),o.source=t.source,o.sink=t.sink,o.protocol=n,null!=t.closeWrite&&(o.closeWrite=t.closeWrite),null!=t.closeRead&&(o.closeRead=t.closeRead),null!=t.close&&(o.close=t.close),null==(s=this.components.metrics)||s.trackProtocolStream(o,d),o}catch(a){throw d.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e","inbound"===n?"from":"to",t.maConn.remoteAddr,e,a),null==o.timeline.close&&o.abort(a),a}},Promise.all([l.sink(s.source),s.sink(l.source)]).catch(t=>{d.log.error("error piping data through muxer - %e",t)}));const u=r.timeline;r.timeline=new Proxy(u,{set:(...t)=>("close"===t[1]&&null!=t[2]&&null==u.close&&(async()=>{try{"open"===d.status&&await d.close()}catch(t){d.log.error("error closing connection after timeline close %e",t)}finally{this.events.safeDispatchEvent("connection:close",{detail:d})}})().catch(t=>{d.log.error("error thrown while dispatching connection:close event %e",t)}),Reflect.set(...t))}),r.timeline.upgraded=Date.now();var h;return h={remoteAddr:r.remoteAddr,remotePeer:i,status:"open",direction:n,timeline:r.timeline,multiplexer:null==l?void 0:l.protocol,encryption:e,limits:a,logger:this.components.logger,newStream:c??(()=>{throw new zr("Connection is not multiplexed")}),getStreams:()=>(null==l?void 0:l.streams)??[],close:async t=>{await(null==l?void 0:l.close(t)),await r.close(t)},abort:t=>{r.abort(t),null==l||l.abort(t)}},d=new ei(h),this.events.safeDispatchEvent("connection:open",{detail:d}),d.__maConnTimeline=u,d}_onStream(t){const{connection:e,stream:n,protocol:r}=t,{handler:s,options:i}=this.components.registrar.getHandler(r);if(null!=e.limits&&!0!==i.runOnLimitedConnection)throw new Q("Cannot open protocol stream on limited connection");s({connection:e,stream:n})}async _encryptInbound(t,e){const n=Array.from(this.connectionEncrypters.keys());try{const{stream:r,protocol:s}=await ti(t,n,{...e,log:t.log}),i=this.connectionEncrypters.get(s);if(null==i)throw new Wr(`no crypto module found for ${s}`);return t.log("encrypting inbound connection to %a using %s",t.remoteAddr,s),{...await i.secureInbound(r,e),protocol:s}}catch(r){throw t.log.error("encrypting inbound connection from %a failed",t.remoteAddr,r),new Wr(r.message)}}async _encryptOutbound(t,e){const n=Array.from(this.connectionEncrypters.keys());try{t.log.trace("selecting encrypter from %s",n);const{stream:r,protocol:s}=await Zs(t,n,{...e,log:t.log,yieldBytes:!0}),i=this.connectionEncrypters.get(s);if(null==i)throw new Wr(`no crypto module found for ${s}`);return t.log("encrypting outbound connection to %a using %s",t.remoteAddr,s),{...await i.secureOutbound(r,e),protocol:s}}catch(r){throw t.log.error("encrypting outbound connection to %a failed",t.remoteAddr,r),new Wr(r.message)}}async _multiplexOutbound(t,e,n){const r=Array.from(e.keys());t.log("outbound selecting muxer %s",r);try{t.log.trace("selecting stream muxer from %s",r);const{stream:s,protocol:i}=await Zs(t,r,{...n,log:t.log,yieldBytes:!0});t.log("selected %s as muxer protocol",i);return{stream:s,muxerFactory:e.get(i)}}catch(s){throw t.log.error("error multiplexing outbound connection",s),new zr(String(s))}}async _multiplexInbound(t,e,n){const r=Array.from(e.keys());t.log("inbound handling muxers %s",r);try{const{stream:s,protocol:i}=await ti(t,r,{...n,log:t.log});return{stream:s,muxerFactory:e.get(i)}}catch(s){throw t.log.error("error multiplexing inbound connection",s),new zr(String(s))}}getConnectionEncrypters(){return this.connectionEncrypters}getStreamMuxers(){return this.streamMuxers}}const si="2.9.0",ii="js-libp2p";function oi(t,e){return`${t??ii}/${e??si} browser/${globalThis.navigator.userAgent}`}class ai extends lt{constructor(t){var e,n,r,s,i,o,a,l,c,d,u,h;super(),E(this,b),k(this,"peerId"),k(this,"peerStore"),k(this,"contentRouting"),k(this,"peerRouting"),k(this,"metrics"),k(this,"services"),k(this,"logger"),k(this,"status"),k(this,"components"),k(this,"log"),this.status="stopped";const p=new lt,m=p.dispatchEvent.bind(p);p.dispatchEvent=t=>{const e=m(t),n=this.dispatchEvent(new CustomEvent(t.type,{detail:t.detail}));return e||n},this.peerId=t.peerId,this.logger=t.logger??re(),this.log=this.logger.forComponent("libp2p"),this.services={};const g=(null==(e=t.nodeInfo)?void 0:e.name)??ii,f=(null==(n=t.nodeInfo)?void 0:n.version)??si,y=this.components=function(t={}){const e=new Qr(t);return new Proxy(e,{get(t,n,r){if("string"==typeof n&&!Yr.includes(n)){const t=e.components[n];if(null==t&&!Hr.includes(n))throw new Tr(`${n} not set`);return t}return Reflect.get(t,n,r)},set:(t,n,r)=>("string"==typeof n?e.components[n]=r:Reflect.set(t,n,r),!0)})}({peerId:t.peerId,privateKey:t.privateKey,nodeInfo:{name:g,version:f,userAgent:(null==(r=t.nodeInfo)?void 0:r.userAgent)??oi(g,f)},logger:this.logger,events:p,datastore:t.datastore??new On,connectionGater:ts(t.connectionGater),dns:t.dns});null!=t.metrics&&(this.metrics=this.configureComponent("metrics",t.metrics(this.components))),this.peerStore=this.configureComponent("peerStore",function(t,e={}){return new pr(t,e)}(y,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...t.peerStore})),y.events.addEventListener("peer:update",t=>{if(null==t.detail.previous){const e={id:t.detail.peer.id,multiaddrs:t.detail.peer.addresses.map(t=>t.multiaddr)};y.events.safeDispatchEvent("peer:discovery",{detail:e})}}),null!=t.connectionProtector&&this.configureComponent("connectionProtector",t.connectionProtector(y)),this.components.upgrader=new ri(this.components,{connectionEncrypters:(t.connectionEncrypters??[]).map((t,e)=>this.configureComponent(`connection-encryption-${e}`,t(this.components))),streamMuxers:(t.streamMuxers??[]).map((t,e)=>this.configureComponent(`stream-muxers-${e}`,t(this.components))),inboundUpgradeTimeout:null==(s=t.connectionManager)?void 0:s.inboundUpgradeTimeout,inboundStreamProtocolNegotiationTimeout:(null==(i=t.connectionManager)?void 0:i.inboundStreamProtocolNegotiationTimeout)??(null==(o=t.connectionManager)?void 0:o.protocolNegotiationTimeout),outboundStreamProtocolNegotiationTimeout:(null==(a=t.connectionManager)?void 0:a.outboundStreamProtocolNegotiationTimeout)??(null==(l=t.connectionManager)?void 0:l.protocolNegotiationTimeout)}),this.configureComponent("transportManager",new Gs(this.components,t.transportManager)),this.configureComponent("connectionManager",new Os(this.components,t.connectionManager)),!1!==(null==(c=t.connectionMonitor)?void 0:c.enabled)&&this.configureComponent("connectionMonitor",new js(this.components,t.connectionMonitor)),this.configureComponent("registrar",new Bs(this.components)),this.configureComponent("addressManager",new Ir(this.components,t.addresses));const v=(t.peerRouters??[]).map((t,e)=>this.configureComponent(`peer-router-${e}`,t(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new zs(this.components,{routers:v}));const w=(t.contentRouters??[]).map((t,e)=>this.configureComponent(`content-router-${e}`,t(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new Vs(this.components,{routers:w})),this.configureComponent("randomWalk",new Ws(this.components)),(t.peerDiscovery??[]).forEach((t,e)=>{this.configureComponent(`peer-discovery-${e}`,t(this.components)).addEventListener("peer",t=>{P(this,b,A).call(this,t)})}),null==(d=t.transports)||d.forEach((t,e)=>{this.components.transportManager.add(this.configureComponent(`transport-${e}`,t(this.components)))}),null!=t.services)for(const S of Object.keys(t.services)){const e=(0,t.services[S])(this.components);null!=e?(this.services[S]=e,this.configureComponent(S,e),null!=e[Ie]&&(this.log("registering service %s for content routing",S),w.push(e[Ie])),null!=e[_e]&&(this.log("registering service %s for peer routing",S),v.push(e[_e])),null!=e[Me]&&(this.log("registering service %s for peer discovery",S),null==(h=(u=e[Me]).addEventListener)||h.call(u,"peer",t=>{P(this,b,A).call(this,t)}))):this.log.error("service factory %s returned null or undefined instance",S)}!function(t){const e={};for(const n of Object.values(t.components))for(const t of Xr(n))e[t]=!0;for(const n of Object.values(t.components))for(const t of Jr(n))if(!0!==e[t])throw new Dr(`Service "${Zr(n)}" required capability "${t}" but it was not provided by any component, you may need to add additional configuration when creating your node.`)}(y)}configureComponent(t,e){return null==e&&this.log.error("component %s was null or undefined",t),this.components[t]=e,e}async start(){var t,e,n,r;if("stopped"===this.status){this.status="starting",this.log("libp2p is starting");try{await(null==(e=(t=this.components).beforeStart)?void 0:e.call(t)),await this.components.start(),await(null==(r=(n=this.components).afterStart)?void 0:r.call(n)),this.status="started",this.safeDispatchEvent("start",{detail:this}),this.log("libp2p has started")}catch(s){throw this.log.error("An error occurred starting libp2p",s),this.status="started",await this.stop(),s}}}async stop(){var t,e,n,r;"started"===this.status&&(this.log("libp2p is stopping"),this.status="stopping",await(null==(e=(t=this.components).beforeStop)?void 0:e.call(t)),await this.components.stop(),await(null==(r=(n=this.components).afterStop)?void 0:r.call(n)),this.status="stopped",this.safeDispatchEvent("stop",{detail:this}),this.log("libp2p has stopped"))}getConnections(t){return this.components.connectionManager.getConnections(t)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const t=new xn;for(const e of this.components.connectionManager.getConnections())t.add(e.remotePeer);return Array.from(t)}async dial(t,e={}){return this.components.connectionManager.openConnection(t,{priority:75,...e})}async dialProtocol(t,e,n={}){if(null==e)throw new C("no protocols were provided to open a stream");if(0===(e=Array.isArray(e)?e:[e]).length)throw new C("no protocols were provided to open a stream");return(await this.dial(t,n)).newStream(e,n)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(t,e={}){At(t)&&(t=N(t.getPeerId()??"")),await this.components.connectionManager.closeConnections(t,e)}async getPublicKey(t,e={}){if(this.log("getPublicKey %p",t),null!=t.publicKey)return t.publicKey;try{const n=await this.peerStore.get(t,e);if(null!=n.id.publicKey)return n.id.publicKey}catch(i){if("NotFoundError"!==i.name)throw i}const n=ke([xe("/pk/"),t.toMultihash().bytes]),r=await this.contentRouting.get(n,e),s=_(r);return await this.peerStore.patch(t,{publicKey:s},e),s}async handle(t,e,n){Array.isArray(t)||(t=[t]),await Promise.all(t.map(async t=>{await this.components.registrar.handle(t,e,n)}))}async unhandle(t,e){Array.isArray(t)||(t=[t]),await Promise.all(t.map(async t=>{await this.components.registrar.unhandle(t,e)}))}async register(t,e,n){return this.components.registrar.register(t,e,n)}unregister(t){this.components.registrar.unregister(t)}async isDialable(t,e={}){return this.components.connectionManager.isDialable(t,e)}}async function li(t={}){t.privateKey??(t.privateKey=await X("Ed25519"));const e=new ai({...await jn(t),peerId:J(t.privateKey)});return!1!==t.start&&await e.start(),e}b=new WeakSet,A=function(t){const{detail:e}=t;e.id.toString()!==this.peerId.toString()?this.components.peerStore.merge(e.id,{multiaddrs:e.multiaddrs}).catch(t=>{this.log.error(t)}):this.log.error("peer discovery mechanism discovered self")};const ci=["dial","dialProtocol","hangUp","handle","unhandle","getMultiaddrs","getProtocols"];function di(t){return null!=t&&(t instanceof ai||ci.every(e=>"function"==typeof t[e]))}const ui=Object.freeze(Object.defineProperty({__proto__:null,createLibp2p:li,dnsaddrResolver:Kn,isLibp2p:di},Symbol.toStringTag,{value:"Module"}));export{Us as A,Dn as I,On as M,an as N,xn as P,ss as R,Ie as a,An as b,sn as c,Te as d,yn as e,Pn as f,vr as g,kn as h,Nn as i,rs as j,Me as k,li as l,di as m,ui as n,_e as p,ln as r,Sn as t,oi as u};
