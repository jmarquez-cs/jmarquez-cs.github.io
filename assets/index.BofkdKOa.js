var t,e,r,n=Object.defineProperty,o=(t,e,r)=>((t,e,r)=>e in t?n(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r)(t,"symbol"!=typeof e?e+"":e,r);import{B as s,U as i,f as a,p as c,C as u,b as f,e as l,g as h,m as d,h as y,i as p,q as w,s as b,d as g}from"./message.Ve-2rN-7.js";const m=Symbol.for("@libp2p/peer-id");function E(t){return Boolean(null==t?void 0:t[m])}class v extends Error{constructor(t="The operation was aborted"){super(t),this.name="AbortError"}}o(v,"name","AbortError");class x extends Error{constructor(t="Invalid parameters"){super(t),this.name="InvalidParametersError"}}o(x,"name","InvalidParametersError");class B extends Error{constructor(t="Invalid public key"){super(t),this.name="InvalidPublicKeyError"}}o(B,"name","InvalidPublicKeyError");class A extends Error{constructor(t="Invalid private key"){super(t),this.name="InvalidPrivateKeyError"}}o(A,"name","InvalidPrivateKeyError");class S extends Error{constructor(t="The connection is closing"){super(t),this.name="ConnectionClosingError"}}o(S,"name","ConnectionClosingError");class I extends Error{constructor(t="The connection is closed"){super(t),this.name="ConnectionClosedError"}}o(I,"name","ConnectionClosedError");class R extends Error{constructor(t="The muxer is closed"){super(t),this.name="MuxerClosedError"}}o(R,"name","MuxerClosedError");class U extends Error{constructor(t="The stream has been reset"){super(t),this.name="StreamResetError"}}o(U,"name","StreamResetError");class K extends Error{constructor(t="The stream is in an invalid state"){super(t),this.name="StreamStateError"}}o(K,"name","StreamStateError");class k extends Error{constructor(t="Not found"){super(t),this.name="NotFoundError"}}o(k,"name","NotFoundError");class O extends Error{constructor(t="Invalid PeerID"){super(t),this.name="InvalidPeerIdError"}}o(O,"name","InvalidPeerIdError");class C extends Error{constructor(t="Invalid multiaddr"){super(t),this.name="InvalidMultiaddrError"}}o(C,"name","InvalidMultiaddrError");class P extends Error{constructor(t="Invalid CID"){super(t),this.name="InvalidCIDError"}}o(P,"name","InvalidCIDError");class D extends Error{constructor(t="Invalid Multihash"){super(t),this.name="InvalidMultihashError"}}o(D,"name","InvalidMultihashError");class F extends Error{constructor(t="Unsupported protocol error"){super(t),this.name="UnsupportedProtocolError"}}o(F,"name","UnsupportedProtocolError");class q extends Error{constructor(t="Invalid message"){super(t),this.name="InvalidMessageError"}}o(q,"name","InvalidMessageError");class T extends Error{constructor(t="Protocol error"){super(t),this.name="ProtocolError"}}o(T,"name","ProtocolError");class L extends Error{constructor(t="Timed out"){super(t),this.name="TimeoutError"}}o(L,"name","TimeoutError");class N extends Error{constructor(t="Not started"){super(t),this.name="NotStartedError"}}o(N,"name","NotStartedError");class j extends Error{constructor(t="Dial error"){super(t),this.name="DialError"}}o(j,"name","DialError");class H extends Error{constructor(t="Listen error"){super(t),this.name="ListenError"}}o(H,"name","ListenError");class V extends Error{constructor(t="Limited connection"){super(t),this.name="LimitedConnectionError"}}o(V,"name","LimitedConnectionError");class _ extends Error{constructor(t="Too many inbound protocol streams"){super(t),this.name="TooManyInboundProtocolStreamsError"}}o(_,"name","TooManyInboundProtocolStreamsError");class Z extends Error{constructor(t="Too many outbound protocol streams"){super(t),this.name="TooManyOutboundProtocolStreamsError"}}o(Z,"name","TooManyOutboundProtocolStreamsError");class M extends Error{constructor(t="Unsupported key type"){super(t),this.name="UnsupportedKeyTypeError"}}function G(t,e="utf8"){const r=s[e];if(null==r)throw new Error(`Unsupported encoding "${e}"`);return r.encoder.encode(t).substring(1)}o(M,"name","UnsupportedKeyTypeError");class z extends Error{constructor(t="An error occurred while signing a message"){super(t),this.name="SigningError"}}class Y extends Error{constructor(t="An error occurred while verifying a message"){super(t),this.name="VerificationError"}}class $ extends Error{constructor(t="Missing Web Crypto API"){super(t),this.name="WebCryptoMissingError"}}const X={get(t=globalThis){const e=t.crypto;if(null==(null==e?void 0:e.subtle))throw new $("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");return e}},W=parseInt("11111",2),J=parseInt("10000000",2),Q=parseInt("01111111",2),tt={0:nt,1:nt,2:function(t,e){const r=rt(t,e),n=e.offset,o=e.offset+r,s=[];for(let i=n;i<o;i++)i===n&&0===t[i]||s.push(t[i]);return e.offset+=r,Uint8Array.from(s)},3:function(t,e){const r=rt(t,e),n=t[e.offset];e.offset++;const o=t.subarray(e.offset,e.offset+r-1);if(e.offset+=r,0!==n)throw new Error("Unused bits in bit string is unimplemented");return o},4:function(t,e){const r=rt(t,e),n=t.subarray(e.offset,e.offset+r);return e.offset+=r,n},5:function(t,e){return e.offset++,null},6:function(t,e){const r=rt(t,e),n=e.offset+r,o=t[e.offset];e.offset++;let s=0,i=0;o<40?(s=0,i=o):o<80?(s=1,i=o-40):(s=2,i=o-80);let a=`${s}.${i}`,c=[];for(;e.offset<n;){const r=t[e.offset];if(e.offset++,c.push(127&r),r<128){c.reverse();let t=0;for(let e=0;e<c.length;e++)t+=c[e]<<7*e;a+=`.${t}`,c=[]}}return a},16:nt,22:nt,48:nt};function et(t,e={offset:0}){const r=t[e.offset]&W;if(e.offset++,null!=tt[r])return tt[r](t,e);throw new Error("No decoder for tag "+r)}function rt(t,e){let r=0;if((t[e.offset]&J)===J){const n=t[e.offset]&Q;let o="0x";e.offset++;for(let r=0;r<n;r++,e.offset++)o+=t[e.offset].toString(16).padStart(2,"0");r=parseInt(o,16)}else r=t[e.offset],e.offset++;return r}function nt(t,e){rt(t,e);const r=[];for(;!(e.offset>=t.byteLength);){const n=et(t,e);if(null===n)break;r.push(n)}return r}function ot(t){if(t.byteLength<128)return Uint8Array.from([t.byteLength]);const e=function(t){let e=t.toString(16);e.length%2==1&&(e="0"+e);const r=new i;for(let n=0;n<e.length;n+=2)r.append(Uint8Array.from([parseInt(`${e[n]}${e[n+1]}`,16)]));return r}(t.byteLength);return new i(Uint8Array.from([e.byteLength|J]),e)}function st(t){const e=new i;return!(128&~t.subarray()[0])&&e.append(Uint8Array.from([0])),e.append(t),new i(Uint8Array.from([2]),ot(e),e)}function it(t){const e=Uint8Array.from([0]),r=new i(e,t);return new i(Uint8Array.from([3]),ot(r),r)}function at(t,e=48){const r=new i;for(const n of t)r.append(n);return new i(Uint8Array.from([e]),ot(r),r)}const ct=Uint8Array.from([6,8,42,134,72,206,61,3,1,7]),ut=Uint8Array.from([6,5,43,129,4,0,34]),ft=Uint8Array.from([6,5,43,129,4,0,35]),lt={ext:!0,kty:"EC",crv:"P-256"},ht={ext:!0,kty:"EC",crv:"P-384"},dt={ext:!0,kty:"EC",crv:"P-521"},yt=32,pt=48,wt=66;function bt(t){const e=t[1],r=G(e,"base64url"),n=t[2][1][0];let o,s;if(e.byteLength===yt)return o=G(n.subarray(1,33),"base64url"),s=G(n.subarray(33),"base64url"),new xt({...lt,key_ops:["sign"],d:r,x:o,y:s});if(e.byteLength===pt)return o=G(n.subarray(1,49),"base64url"),s=G(n.subarray(49),"base64url"),new xt({...ht,key_ops:["sign"],d:r,x:o,y:s});if(e.byteLength===wt)return o=G(n.subarray(1,67),"base64url"),s=G(n.subarray(67),"base64url"),new xt({...dt,key_ops:["sign"],d:r,x:o,y:s});throw new x(`Private key length was wrong length, got ${e.byteLength}, expected 32, 48 or 66`)}function gt(t){return function(t){const e=t[1][1][0],r=1;let n,o;if(65===e.byteLength)return n=G(e.subarray(r,r+yt),"base64url"),o=G(e.subarray(r+yt),"base64url"),new vt({...lt,key_ops:["verify"],x:n,y:o});if(97===e.byteLength)return n=G(e.subarray(r,r+pt),"base64url"),o=G(e.subarray(r+pt),"base64url"),new vt({...ht,key_ops:["verify"],x:n,y:o});if(133===e.byteLength)return n=G(e.subarray(r,r+wt),"base64url"),o=G(e.subarray(r+wt),"base64url"),new vt({...dt,key_ops:["verify"],x:n,y:o});throw new x(`coordinates were wrong length, got ${e.byteLength}, expected 65, 97 or 133`)}(et(t))}function mt(t){if("P-256"===t)return ct;if("P-384"===t)return ut;if("P-521"===t)return ft;throw new x(`Invalid curve ${t}`)}async function Et(t="P-256"){const e=await async function(t="P-256"){const e=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:t},!0,["sign","verify"]);return{publicKey:await crypto.subtle.exportKey("jwk",e.publicKey),privateKey:await crypto.subtle.exportKey("jwk",e.privateKey)}}(t);return new xt(e.privateKey)}class vt{constructor(t){o(this,"type","ECDSA"),o(this,"jwk"),o(this,"_raw"),this.jwk=t}get raw(){var t;return null==this._raw&&(this._raw=(t=this.jwk,at([st(Uint8Array.from([1])),at([mt(t.crv)],160),at([it(new i(Uint8Array.from([4]),a(t.x??"","base64url"),a(t.y??"","base64url")))],161)]).subarray())),this._raw}toMultihash(){return c.digest(ao(this))}toCID(){return u.createV1(114,this.toMultihash())}toString(){return f.encode(this.toMultihash().bytes).substring(1)}equals(t){return null!=t&&t.raw instanceof Uint8Array&&l(this.raw,t.raw)}async verify(t,e,r){return async function(t,e,r,n){var o,s;const i=await crypto.subtle.importKey("jwk",t,{name:"ECDSA",namedCurve:t.crv??"P-256"},!1,["verify"]);null==(o=null==n?void 0:n.signal)||o.throwIfAborted();const a=await crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},i,e,r.subarray());return null==(s=null==n?void 0:n.signal)||s.throwIfAborted(),a}(this.jwk,e,t,r)}}class xt{constructor(t){o(this,"type","ECDSA"),o(this,"jwk"),o(this,"publicKey"),o(this,"_raw"),this.jwk=t,this.publicKey=new vt({crv:t.crv,ext:t.ext,key_ops:["verify"],kty:"EC",x:t.x,y:t.y})}get raw(){var t,e;return null==this._raw&&(this._raw=(t=this.jwk,at([st(Uint8Array.from([1])),(e=a(t.d??"","base64url"),new i(Uint8Array.from([4]),ot(e),e)),at([mt(t.crv)],160),at([it(new i(Uint8Array.from([4]),a(t.x??"","base64url"),a(t.y??"","base64url")))],161)]).subarray())),this._raw}equals(t){return null!=t&&t.raw instanceof Uint8Array&&l(this.raw,t.raw)}async sign(t,e){return async function(t,e,r){var n,o;const s=await crypto.subtle.importKey("jwk",t,{name:"ECDSA",namedCurve:t.crv??"P-256"},!1,["sign"]);null==(n=null==r?void 0:r.signal)||n.throwIfAborted();const i=await crypto.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},s,e.subarray());return null==(o=null==r?void 0:r.signal)||o.throwIfAborted(),new Uint8Array(i,0,i.byteLength)}(this.jwk,t,e)}}const Bt="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function At(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function St(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function It(t,...e){if(!At(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function Rt(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.createHasher");St(t.outputLen),St(t.blockLen)}function Ut(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function Kt(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function kt(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function Ot(t,e){return t<<32-e|t>>>e}function Ct(t,e){return t<<e|t>>>32-e>>>0}const Pt=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)(),Dt=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Ft(t){if(It(t),Pt)return t.toHex();let e="";for(let r=0;r<t.length;r++)e+=Dt[t[r]];return e}const qt=48,Tt=57,Lt=65,Nt=70,jt=97,Ht=102;function Vt(t){return t>=qt&&t<=Tt?t-qt:t>=Lt&&t<=Nt?t-(Lt-10):t>=jt&&t<=Ht?t-(jt-10):void 0}function _t(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if(Pt)return Uint8Array.fromHex(t);const e=t.length,r=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let o=0,s=0;o<r;o++,s+=2){const e=Vt(t.charCodeAt(s)),r=Vt(t.charCodeAt(s+1));if(void 0===e||void 0===r){const e=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+s)}n[o]=16*e+r}return n}const Zt=async()=>{};async function Mt(t,e,r){let n=Date.now();for(let o=0;o<t;o++){r(o);const t=Date.now()-n;t>=0&&t<e||(await Zt(),n+=t)}}function Gt(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}function zt(t){return"string"==typeof t&&(t=Gt(t)),It(t),t}function Yt(t){return"string"==typeof t&&(t=Gt(t)),It(t),t}function $t(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];It(r),e+=r.length}const r=new Uint8Array(e);for(let n=0,o=0;n<t.length;n++){const e=t[n];r.set(e,o),o+=e.length}return r}function Xt(t,e){if(void 0!==e&&"[object Object]"!=={}.toString.call(e))throw new Error("options should be object or undefined");return Object.assign(t,e)}class Wt{}function Jt(t){const e=e=>t().update(zt(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function Qt(t=32){if(Bt&&"function"==typeof Bt.getRandomValues)return Bt.getRandomValues(new Uint8Array(t));if(Bt&&"function"==typeof Bt.randomBytes)return Uint8Array.from(Bt.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}function te(t,e,r){return t&e^~t&r}function ee(t,e,r){return t&e^t&r^e&r}class re extends Wt{constructor(t,e,r,n){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.buffer=new Uint8Array(t),this.view=kt(this.buffer)}update(t){Ut(this),It(t=zt(t));const{view:e,buffer:r,blockLen:n}=this,o=t.length;for(let s=0;s<o;){const i=Math.min(n-this.pos,o-s);if(i===n){const e=kt(t);for(;n<=o-s;s+=n)this.process(e,s);continue}r.set(t.subarray(s,s+i),this.pos),this.pos+=i,s+=i,this.pos===n&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Ut(this),function(t,e){It(t);const r=e.outputLen;if(t.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:n,isLE:o}=this;let{pos:s}=this;e[s++]=128,Kt(this.buffer.subarray(s)),this.padOffset>n-s&&(this.process(r,0),s=0);for(let f=s;f<n;f++)e[f]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const o=BigInt(32),s=BigInt(4294967295),i=Number(r>>o&s),a=Number(r&s),c=n?4:0,u=n?0:4;t.setUint32(e+c,i,n),t.setUint32(e+u,a,n)}(r,n-8,BigInt(8*this.length),o),this.process(r,0);const i=kt(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=a/4,u=this.get();if(c>u.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<c;f++)i.setUint32(4*f,u[f],o)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:o,destroyed:s,pos:i}=this;return t.destroyed=s,t.finished=o,t.length=n,t.pos=i,n%e&&t.buffer.set(r),t}clone(){return this._cloneInto()}}const ne=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),oe=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),se=BigInt(2**32-1),ie=BigInt(32);function ae(t,e=!1){return e?{h:Number(t&se),l:Number(t>>ie&se)}:{h:0|Number(t>>ie&se),l:0|Number(t&se)}}const ce=(t,e,r)=>t>>>r,ue=(t,e,r)=>t<<32-r|e>>>r,fe=(t,e,r)=>t>>>r|e<<32-r,le=(t,e,r)=>t<<32-r|e>>>r,he=(t,e,r)=>t<<64-r|e>>>r-32,de=(t,e,r)=>t>>>r-32|e<<64-r;function ye(t,e,r,n){const o=(e>>>0)+(n>>>0);return{h:t+r+(o/2**32|0)|0,l:0|o}}const pe=(t,e,r)=>(t>>>0)+(e>>>0)+(r>>>0),we=(t,e,r,n)=>e+r+n+(t/2**32|0)|0,be=(t,e,r,n)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0),ge=(t,e,r,n,o)=>e+r+n+o+(t/2**32|0)|0,me=(t,e,r,n,o)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0)+(o>>>0),Ee=(t,e,r,n,o,s)=>e+r+n+o+s+(t/2**32|0)|0,ve=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),xe=new Uint32Array(64);class Be extends re{constructor(t=32){super(64,t,8,!1),this.A=0|ne[0],this.B=0|ne[1],this.C=0|ne[2],this.D=0|ne[3],this.E=0|ne[4],this.F=0|ne[5],this.G=0|ne[6],this.H=0|ne[7]}get(){const{A:t,B:e,C:r,D:n,E:o,F:s,G:i,H:a}=this;return[t,e,r,n,o,s,i,a]}set(t,e,r,n,o,s,i,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|o,this.F=0|s,this.G=0|i,this.H=0|a}process(t,e){for(let f=0;f<16;f++,e+=4)xe[f]=t.getUint32(e,!1);for(let f=16;f<64;f++){const t=xe[f-15],e=xe[f-2],r=Ot(t,7)^Ot(t,18)^t>>>3,n=Ot(e,17)^Ot(e,19)^e>>>10;xe[f]=n+xe[f-7]+r+xe[f-16]|0}let{A:r,B:n,C:o,D:s,E:i,F:a,G:c,H:u}=this;for(let f=0;f<64;f++){const t=u+(Ot(i,6)^Ot(i,11)^Ot(i,25))+te(i,a,c)+ve[f]+xe[f]|0,e=(Ot(r,2)^Ot(r,13)^Ot(r,22))+ee(r,n,o)|0;u=c,c=a,a=i,i=s+t|0,s=o,o=n,n=r,r=t+e|0}r=r+this.A|0,n=n+this.B|0,o=o+this.C|0,s=s+this.D|0,i=i+this.E|0,a=a+this.F|0,c=c+this.G|0,u=u+this.H|0,this.set(r,n,o,s,i,a,c,u)}roundClean(){Kt(xe)}destroy(){this.set(0,0,0,0,0,0,0,0),Kt(this.buffer)}}const Ae=(()=>function(t,e=!1){const r=t.length;let n=new Uint32Array(r),o=new Uint32Array(r);for(let s=0;s<r;s++){const{h:r,l:i}=ae(t[s],e);[n[s],o[s]]=[r,i]}return[n,o]}(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))))(),Se=(()=>Ae[0])(),Ie=(()=>Ae[1])(),Re=new Uint32Array(80),Ue=new Uint32Array(80);class Ke extends re{constructor(t=64){super(128,t,16,!1),this.Ah=0|oe[0],this.Al=0|oe[1],this.Bh=0|oe[2],this.Bl=0|oe[3],this.Ch=0|oe[4],this.Cl=0|oe[5],this.Dh=0|oe[6],this.Dl=0|oe[7],this.Eh=0|oe[8],this.El=0|oe[9],this.Fh=0|oe[10],this.Fl=0|oe[11],this.Gh=0|oe[12],this.Gl=0|oe[13],this.Hh=0|oe[14],this.Hl=0|oe[15]}get(){const{Ah:t,Al:e,Bh:r,Bl:n,Ch:o,Cl:s,Dh:i,Dl:a,Eh:c,El:u,Fh:f,Fl:l,Gh:h,Gl:d,Hh:y,Hl:p}=this;return[t,e,r,n,o,s,i,a,c,u,f,l,h,d,y,p]}set(t,e,r,n,o,s,i,a,c,u,f,l,h,d,y,p){this.Ah=0|t,this.Al=0|e,this.Bh=0|r,this.Bl=0|n,this.Ch=0|o,this.Cl=0|s,this.Dh=0|i,this.Dl=0|a,this.Eh=0|c,this.El=0|u,this.Fh=0|f,this.Fl=0|l,this.Gh=0|h,this.Gl=0|d,this.Hh=0|y,this.Hl=0|p}process(t,e){for(let g=0;g<16;g++,e+=4)Re[g]=t.getUint32(e),Ue[g]=t.getUint32(e+=4);for(let g=16;g<80;g++){const t=0|Re[g-15],e=0|Ue[g-15],r=fe(t,e,1)^fe(t,e,8)^ce(t,0,7),n=le(t,e,1)^le(t,e,8)^ue(t,e,7),o=0|Re[g-2],s=0|Ue[g-2],i=fe(o,s,19)^he(o,s,61)^ce(o,0,6),a=le(o,s,19)^de(o,s,61)^ue(o,s,6),c=be(n,a,Ue[g-7],Ue[g-16]),u=ge(c,r,i,Re[g-7],Re[g-16]);Re[g]=0|u,Ue[g]=0|c}let{Ah:r,Al:n,Bh:o,Bl:s,Ch:i,Cl:a,Dh:c,Dl:u,Eh:f,El:l,Fh:h,Fl:d,Gh:y,Gl:p,Hh:w,Hl:b}=this;for(let g=0;g<80;g++){const t=fe(f,l,14)^fe(f,l,18)^he(f,l,41),e=le(f,l,14)^le(f,l,18)^de(f,l,41),m=f&h^~f&y,E=me(b,e,l&d^~l&p,Ie[g],Ue[g]),v=Ee(E,w,t,m,Se[g],Re[g]),x=0|E,B=fe(r,n,28)^he(r,n,34)^he(r,n,39),A=le(r,n,28)^de(r,n,34)^de(r,n,39),S=r&o^r&i^o&i,I=n&s^n&a^s&a;w=0|y,b=0|p,y=0|h,p=0|d,h=0|f,d=0|l,({h:f,l:l}=ye(0|c,0|u,0|v,0|x)),c=0|i,u=0|a,i=0|o,a=0|s,o=0|r,s=0|n;const R=pe(x,A,I);r=we(R,v,B,S),n=0|R}({h:r,l:n}=ye(0|this.Ah,0|this.Al,0|r,0|n)),({h:o,l:s}=ye(0|this.Bh,0|this.Bl,0|o,0|s)),({h:i,l:a}=ye(0|this.Ch,0|this.Cl,0|i,0|a)),({h:c,l:u}=ye(0|this.Dh,0|this.Dl,0|c,0|u)),({h:f,l:l}=ye(0|this.Eh,0|this.El,0|f,0|l)),({h:h,l:d}=ye(0|this.Fh,0|this.Fl,0|h,0|d)),({h:y,l:p}=ye(0|this.Gh,0|this.Gl,0|y,0|p)),({h:w,l:b}=ye(0|this.Hh,0|this.Hl,0|w,0|b)),this.set(r,n,o,s,i,a,c,u,f,l,h,d,y,p,w,b)}roundClean(){Kt(Re,Ue)}destroy(){Kt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const ke=Jt(()=>new Be),Oe=Jt(()=>new Ke),Ce=BigInt(0),Pe=BigInt(1);function De(t,e=""){if("boolean"!=typeof t){throw new Error((e&&`"${e}"`)+"expected boolean, got type="+typeof t)}return t}function Fe(t,e,r=""){const n=At(t),o=null==t?void 0:t.length,s=void 0!==e;if(!n||s&&o!==e){throw new Error((r&&`"${r}" `)+"expected Uint8Array"+(s?` of length ${e}`:"")+", got "+(n?`length=${o}`:"type="+typeof t))}return t}function qe(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function Te(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?Ce:BigInt("0x"+t)}function Le(t){return Te(Ft(t))}function Ne(t){return It(t),Te(Ft(Uint8Array.from(t).reverse()))}function je(t,e){return _t(t.toString(16).padStart(2*e,"0"))}function He(t,e){return je(t,e).reverse()}function Ve(t,e,r){let n;if("string"==typeof e)try{n=_t(e)}catch(s){throw new Error(t+" must be hex string or Uint8Array, cause: "+s)}else{if(!At(e))throw new Error(t+" must be hex string or Uint8Array");n=Uint8Array.from(e)}const o=n.length;if("number"==typeof r&&o!==r)throw new Error(t+" of length "+r+" expected, got "+o);return n}function _e(t){return Uint8Array.from(t)}const Ze=t=>"bigint"==typeof t&&Ce<=t;function Me(t,e,r,n){if(!function(t,e,r){return Ze(t)&&Ze(e)&&Ze(r)&&e<=t&&t<r}(e,r,n))throw new Error("expected valid "+t+": "+r+" <= n < "+n+", got "+e)}function Ge(t){let e;for(e=0;t>Ce;t>>=Pe,e+=1);return e}const ze=t=>(Pe<<BigInt(t))-Pe;function Ye(t,e,r={}){if(!t||"object"!=typeof t)throw new Error("expected valid options object");function n(e,r,n){const o=t[e];if(n&&void 0===o)return;const s=typeof o;if(s!==r||null===o)throw new Error(`param "${e}" is invalid: expected ${r}, got ${s}`)}Object.entries(e).forEach(([t,e])=>n(t,e,!1)),Object.entries(r).forEach(([t,e])=>n(t,e,!0))}function $e(t){const e=new WeakMap;return(r,...n)=>{const o=e.get(r);if(void 0!==o)return o;const s=t(r,...n);return e.set(r,s),s}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xe=BigInt(0),We=BigInt(1),Je=BigInt(2),Qe=BigInt(3),tr=BigInt(4),er=BigInt(5),rr=BigInt(7),nr=BigInt(8),or=BigInt(9),sr=BigInt(16);function ir(t,e){const r=t%e;return r>=Xe?r:e+r}function ar(t,e,r){let n=t;for(;e-- >Xe;)n*=n,n%=r;return n}function cr(t,e){if(t===Xe)throw new Error("invert: expected non-zero number");if(e<=Xe)throw new Error("invert: expected positive modulus, got "+e);let r=ir(t,e),n=e,o=Xe,s=We;for(;r!==Xe;){const t=n%r,e=o-s*(n/r);n=r,r=t,o=s,s=e}if(n!==We)throw new Error("invert: does not exist");return ir(o,e)}function ur(t,e,r){if(!t.eql(t.sqr(e),r))throw new Error("Cannot find square root")}function fr(t,e){const r=(t.ORDER+We)/tr,n=t.pow(e,r);return ur(t,n,e),n}function lr(t,e){const r=(t.ORDER-er)/nr,n=t.mul(e,Je),o=t.pow(n,r),s=t.mul(e,o),i=t.mul(t.mul(s,Je),o),a=t.mul(s,t.sub(i,t.ONE));return ur(t,a,e),a}function hr(t){if(t<Qe)throw new Error("sqrt is not defined for small field");let e=t-We,r=0;for(;e%Je===Xe;)e/=Je,r++;let n=Je;const o=gr(t);for(;1===wr(o,n);)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===r)return fr;let s=o.pow(n,e);const i=(e+We)/Je;return function(t,n){if(t.is0(n))return n;if(1!==wr(t,n))throw new Error("Cannot find square root");let o=r,a=t.mul(t.ONE,s),c=t.pow(n,e),u=t.pow(n,i);for(;!t.eql(c,t.ONE);){if(t.is0(c))return t.ZERO;let e=1,r=t.sqr(c);for(;!t.eql(r,t.ONE);)if(e++,r=t.sqr(r),e===o)throw new Error("Cannot find square root");const n=We<<BigInt(o-e-1),s=t.pow(a,n);o=e,a=t.sqr(s),c=t.mul(c,a),u=t.mul(u,s)}return u}}function dr(t){return t%tr===Qe?fr:t%nr===er?lr:t%sr===or?function(t){const e=gr(t),r=hr(t),n=r(e,e.neg(e.ONE)),o=r(e,n),s=r(e,e.neg(n)),i=(t+rr)/sr;return(t,e)=>{let r=t.pow(e,i),a=t.mul(r,n);const c=t.mul(r,o),u=t.mul(r,s),f=t.eql(t.sqr(a),e),l=t.eql(t.sqr(c),e);r=t.cmov(r,a,f),a=t.cmov(u,c,l);const h=t.eql(t.sqr(a),e),d=t.cmov(r,a,h);return ur(t,d,e),d}}(t):hr(t)}const yr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function pr(t,e,r=!1){const n=new Array(e.length).fill(r?t.ZERO:void 0),o=e.reduce((e,r,o)=>t.is0(r)?e:(n[o]=e,t.mul(e,r)),t.ONE),s=t.inv(o);return e.reduceRight((e,r,o)=>t.is0(r)?e:(n[o]=t.mul(e,n[o]),t.mul(e,r)),s),n}function wr(t,e){const r=(t.ORDER-We)/Je,n=t.pow(e,r),o=t.eql(n,t.ONE),s=t.eql(n,t.ZERO),i=t.eql(n,t.neg(t.ONE));if(!o&&!s&&!i)throw new Error("invalid Legendre symbol result");return o?1:s?0:-1}function br(t,e){void 0!==e&&St(e);const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function gr(t,e,r=!1,n={}){if(t<=Xe)throw new Error("invalid field: expected ORDER > 0, got "+t);let o,s,i,a=!1;if("object"==typeof e&&null!=e){if(n.sqrt||r)throw new Error("cannot specify opts in two arguments");const t=e;t.BITS&&(o=t.BITS),t.sqrt&&(s=t.sqrt),"boolean"==typeof t.isLE&&(r=t.isLE),"boolean"==typeof t.modFromBytes&&(a=t.modFromBytes),i=t.allowedLengths}else"number"==typeof e&&(o=e),n.sqrt&&(s=n.sqrt);const{nBitLength:c,nByteLength:u}=br(t,o);if(u>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let f;const l=Object.freeze({ORDER:t,isLE:r,BITS:c,BYTES:u,MASK:ze(c),ZERO:Xe,ONE:We,allowedLengths:i,create:e=>ir(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("invalid field element: expected bigint, got "+typeof e);return Xe<=e&&e<t},is0:t=>t===Xe,isValidNot0:t=>!l.is0(t)&&l.isValid(t),isOdd:t=>(t&We)===We,neg:e=>ir(-e,t),eql:(t,e)=>t===e,sqr:e=>ir(e*e,t),add:(e,r)=>ir(e+r,t),sub:(e,r)=>ir(e-r,t),mul:(e,r)=>ir(e*r,t),pow:(t,e)=>function(t,e,r){if(r<Xe)throw new Error("invalid exponent, negatives unsupported");if(r===Xe)return t.ONE;if(r===We)return e;let n=t.ONE,o=e;for(;r>Xe;)r&We&&(n=t.mul(n,o)),o=t.sqr(o),r>>=We;return n}(l,t,e),div:(e,r)=>ir(e*cr(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>cr(e,t),sqrt:s||(e=>(f||(f=dr(t)),f(l,e))),toBytes:t=>r?He(t,u):je(t,u),fromBytes:(e,n=!0)=>{if(i){if(!i.includes(e.length)||e.length>u)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+e.length);const t=new Uint8Array(u);t.set(e,r?0:t.length-e.length),e=t}if(e.length!==u)throw new Error("Field.fromBytes: expected "+u+" bytes, got "+e.length);let o=r?Ne(e):Le(e);if(a&&(o=ir(o,t)),!n&&!l.isValid(o))throw new Error("invalid field element: outside of range 0..ORDER");return o},invertBatch:t=>pr(l,t),cmov:(t,e,r)=>r?e:t});return Object.freeze(l)}function mr(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Er(t){const e=mr(t);return e+Math.ceil(e/2)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const vr=BigInt(0),xr=BigInt(1);function Br(t,e){const r=e.negate();return t?r:e}function Ar(t,e){const r=pr(t.Fp,e.map(t=>t.Z));return e.map((e,n)=>t.fromAffine(e.toAffine(r[n])))}function Sr(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function Ir(t,e){Sr(t,e);const r=2**t;return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1),mask:ze(t),maxNumber:r,shiftBy:BigInt(t)}}function Rr(t,e,r){const{windowSize:n,mask:o,maxNumber:s,shiftBy:i}=r;let a=Number(t&o),c=t>>i;a>n&&(a-=s,c+=xr);const u=e*n;return{nextN:c,offset:u+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:e%2!=0,offsetF:u}}const Ur=new WeakMap,Kr=new WeakMap;function kr(t){return Kr.get(t)||1}function Or(t){if(t!==vr)throw new Error("invalid wNAF")}class Cr{constructor(t,e){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,r=this.ZERO){let n=t;for(;e>vr;)e&xr&&(r=r.add(n)),n=n.double(),e>>=xr;return r}precomputeWindow(t,e){const{windows:r,windowSize:n}=Ir(e,this.bits),o=[];let s=t,i=s;for(let a=0;a<r;a++){i=s,o.push(i);for(let t=1;t<n;t++)i=i.add(s),o.push(i);s=i.double()}return o}wNAF(t,e,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let n=this.ZERO,o=this.BASE;const s=Ir(t,this.bits);for(let i=0;i<s.windows;i++){const{nextN:t,offset:a,isZero:c,isNeg:u,isNegF:f,offsetF:l}=Rr(r,i,s);r=t,c?o=o.add(Br(f,e[l])):n=n.add(Br(u,e[a]))}return Or(r),{p:n,f:o}}wNAFUnsafe(t,e,r,n=this.ZERO){const o=Ir(t,this.bits);for(let s=0;s<o.windows&&r!==vr;s++){const{nextN:t,offset:i,isZero:a,isNeg:c}=Rr(r,s,o);if(r=t,!a){const t=e[i];n=n.add(c?t.negate():t)}}return Or(r),n}getPrecomputes(t,e,r){let n=Ur.get(e);return n||(n=this.precomputeWindow(e,t),1!==t&&("function"==typeof r&&(n=r(n)),Ur.set(e,n))),n}cached(t,e,r){const n=kr(t);return this.wNAF(n,this.getPrecomputes(n,t,r),e)}unsafe(t,e,r,n){const o=kr(t);return 1===o?this._unsafeLadder(t,e,n):this.wNAFUnsafe(o,this.getPrecomputes(o,t,r),e,n)}createCache(t,e){Sr(e,this.bits),Kr.set(t,e),Ur.delete(t)}hasCache(t){return 1!==kr(t)}}function Pr(t,e,r,n){!function(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((t,r)=>{if(!(t instanceof e))throw new Error("invalid point at index "+r)})}(r,t),function(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((t,r)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+r)})}(n,e);const o=r.length,s=n.length;if(o!==s)throw new Error("arrays of points and scalars must have equal length");const i=t.ZERO,a=Ge(BigInt(o));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const u=ze(c),f=new Array(Number(u)+1).fill(i);let l=i;for(let h=Math.floor((e.BITS-1)/c)*c;h>=0;h-=c){f.fill(i);for(let e=0;e<s;e++){const t=n[e],o=Number(t>>BigInt(h)&u);f[o]=f[o].add(r[e])}let t=i;for(let e=f.length-1,r=i;e>0;e--)r=r.add(f[e]),t=t.add(r);if(l=l.add(t),0!==h)for(let e=0;e<c;e++)l=l.double()}return l}function Dr(t,e,r){if(e){if(e.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return function(t){Ye(t,yr.reduce((t,e)=>(t[e]="function",t),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"}))}(e),e}return gr(t,{isLE:r})}function Fr(t,e,r={},n){if(void 0===n&&(n="edwards"===t),!e||"object"!=typeof e)throw new Error(`expected valid ${t} CURVE object`);for(const a of["p","n","h"]){const t=e[a];if(!("bigint"==typeof t&&t>vr))throw new Error(`CURVE.${a} must be positive bigint`)}const o=Dr(e.p,r.Fp,n),s=Dr(e.n,r.Fn,n),i=["Gx","Gy","a","weierstrass"===t?"b":"d"];for(const a of i)if(!o.isValid(e[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return{CURVE:e=Object.freeze(Object.assign({},e)),Fp:o,Fn:s}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qr=BigInt(0),Tr=BigInt(1),Lr=BigInt(2),Nr=BigInt(8);function jr(t,e,r={}){if("function"!=typeof e)throw new Error('"hash" function param is required');Ye(r,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:n}=r,{BASE:o,Fp:s,Fn:i}=t,a=r.randomBytes||Qt,c=r.adjustScalarBytes||(t=>t),u=r.domain||((t,e,r)=>{if(De(r,"phflag"),e.length||r)throw new Error("Contexts/pre-hash are not supported");return t});function f(t){return i.create(Ne(t))}function l(t){const{head:r,prefix:n,scalar:s}=function(t){const r=w.secretKey;t=Ve("private key",t,r);const n=Ve("hashed private key",e(t),2*r),o=c(n.slice(0,r));return{head:o,prefix:n.slice(r,2*r),scalar:f(o)}}(t),i=o.multiply(s),a=i.toBytes();return{head:r,prefix:n,scalar:s,point:i,pointBytes:a}}function h(t){return l(t).pointBytes}function d(t=Uint8Array.of(),...r){const o=$t(...r);return f(e(u(o,Ve("context",t),!!n)))}const y={zip215:!0};const p=s.BYTES,w={secretKey:p,publicKey:p,signature:2*p,seed:p};function b(t=a(w.seed)){return Fe(t,w.seed,"seed")}const g={getExtendedPublicKey:l,randomSecretKey:b,isValidSecretKey:function(t){return At(t)&&t.length===i.BYTES},isValidPublicKey:function(e,r){try{return!!t.fromBytes(e,r)}catch(n){return!1}},toMontgomery(e){const{y:r}=t.fromBytes(e),n=w.publicKey,o=32===n;if(!o&&57!==n)throw new Error("only defined for 25519 and 448");const i=o?s.div(Tr+r,Tr-r):s.div(r-Tr,r+Tr);return s.toBytes(i)},toMontgomeryPriv(t){const r=w.secretKey;Fe(t,r);const n=e(t.subarray(0,r));return c(n).subarray(0,r)},randomPrivateKey:b,precompute:(e=8,r=t.BASE)=>r.precompute(e,!1)};return Object.freeze({keygen:function(t){const e=g.randomSecretKey(t);return{secretKey:e,publicKey:h(e)}},getPublicKey:h,sign:function(t,e,r={}){t=Ve("message",t),n&&(t=n(t));const{prefix:s,scalar:a,pointBytes:c}=l(e),u=d(r.context,s,t),f=o.multiply(u).toBytes(),h=d(r.context,f,c,t),y=i.create(u+h*a);if(!i.isValid(y))throw new Error("sign failed: invalid s");return Fe($t(f,i.toBytes(y)),w.signature,"result")},verify:function(e,r,s,i=y){const{context:a,zip215:c}=i,u=w.signature;e=Ve("signature",e,u),r=Ve("message",r),s=Ve("publicKey",s,w.publicKey),void 0!==c&&De(c,"zip215"),n&&(r=n(r));const f=u/2,l=e.subarray(0,f),h=Ne(e.subarray(f,u));let p,b,g;try{p=t.fromBytes(s,c),b=t.fromBytes(l,c),g=o.multiplyUnsafe(h)}catch(E){return!1}if(!c&&p.isSmallOrder())return!1;const m=d(a,b.toBytes(),p.toBytes(),r);return b.add(p.multiplyUnsafe(m)).subtract(g).clearCofactor().is0()},utils:g,Point:t,lengths:w})}function Hr(t){const{CURVE:e,curveOpts:r,hash:n,eddsaOpts:o}=function(t){const e={a:t.a,d:t.d,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},r={Fp:t.Fp,Fn:gr(e.n,t.nBitLength,!0),uvRatio:t.uvRatio},n={randomBytes:t.randomBytes,adjustScalarBytes:t.adjustScalarBytes,domain:t.domain,prehash:t.prehash,mapToCurve:t.mapToCurve};return{CURVE:e,curveOpts:r,hash:t.hash,eddsaOpts:n}}(t),s=function(t,e={}){const r=Fr("edwards",t,e,e.FpFnLE),{Fp:n,Fn:o}=r;let s=r.CURVE;const{h:i}=s;Ye(e,{},{uvRatio:"function"});const a=Lr<<BigInt(8*o.BYTES)-Tr,c=t=>n.create(t),u=e.uvRatio||((t,e)=>{try{return{isValid:!0,value:n.sqrt(n.div(t,e))}}catch(r){return{isValid:!1,value:qr}}});if(!function(t,e,r,n){const o=t.sqr(r),s=t.sqr(n),i=t.add(t.mul(e.a,o),s),a=t.add(t.ONE,t.mul(e.d,t.mul(o,s)));return t.eql(i,a)}(n,s,s.Gx,s.Gy))throw new Error("bad curve params: generator point");function f(t,e,r=!1){return Me("coordinate "+t,e,r?Tr:qr,a),e}function l(t){if(!(t instanceof y))throw new Error("ExtendedPoint expected")}const h=$e((t,e)=>{const{X:r,Y:o,Z:s}=t,i=t.is0();null==e&&(e=i?Nr:n.inv(s));const a=c(r*e),u=c(o*e),f=n.mul(s,e);if(i)return{x:qr,y:Tr};if(f!==Tr)throw new Error("invZ was invalid");return{x:a,y:u}}),d=$e(t=>{const{a:e,d:r}=s;if(t.is0())throw new Error("bad point: ZERO");const{X:n,Y:o,Z:i,T:a}=t,u=c(n*n),f=c(o*o),l=c(i*i),h=c(l*l),d=c(u*e);if(c(l*c(d+f))!==c(h+c(r*c(u*f))))throw new Error("bad point: equation left != right (1)");if(c(n*o)!==c(i*a))throw new Error("bad point: equation left != right (2)");return!0});class y{constructor(t,e,r,n){this.X=f("x",t),this.Y=f("y",e),this.Z=f("z",r,!0),this.T=f("t",n),Object.freeze(this)}static CURVE(){return s}static fromAffine(t){if(t instanceof y)throw new Error("extended point not allowed");const{x:e,y:r}=t||{};return f("x",e),f("y",r),new y(e,r,Tr,c(e*r))}static fromBytes(t,e=!1){const r=n.BYTES,{a:o,d:i}=s;t=_e(Fe(t,r,"point")),De(e,"zip215");const f=_e(t),l=t[r-1];f[r-1]=-129&l;const h=Ne(f),d=e?a:n.ORDER;Me("point.y",h,qr,d);const p=c(h*h),w=c(p-Tr),b=c(i*p-o);let{isValid:g,value:m}=u(w,b);if(!g)throw new Error("bad point: invalid y coordinate");const E=(m&Tr)===Tr,v=!!(128&l);if(!e&&m===qr&&v)throw new Error("bad point: x=0 and x_0=1");return v!==E&&(m=c(-m)),y.fromAffine({x:m,y:h})}static fromHex(t,e=!1){return y.fromBytes(Ve("point",t),e)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(t=8,e=!0){return p.createCache(this,t),e||this.multiply(Lr),this}assertValidity(){d(this)}equals(t){l(t);const{X:e,Y:r,Z:n}=this,{X:o,Y:s,Z:i}=t,a=c(e*i),u=c(o*n),f=c(r*i),h=c(s*n);return a===u&&f===h}is0(){return this.equals(y.ZERO)}negate(){return new y(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:t}=s,{X:e,Y:r,Z:n}=this,o=c(e*e),i=c(r*r),a=c(Lr*c(n*n)),u=c(t*o),f=e+r,l=c(c(f*f)-o-i),h=u+i,d=h-a,p=u-i,w=c(l*d),b=c(h*p),g=c(l*p),m=c(d*h);return new y(w,b,m,g)}add(t){l(t);const{a:e,d:r}=s,{X:n,Y:o,Z:i,T:a}=this,{X:u,Y:f,Z:h,T:d}=t,p=c(n*u),w=c(o*f),b=c(a*r*d),g=c(i*h),m=c((n+o)*(u+f)-p-w),E=g-b,v=g+b,x=c(w-e*p),B=c(m*E),A=c(v*x),S=c(m*x),I=c(E*v);return new y(B,A,I,S)}subtract(t){return this.add(t.negate())}multiply(t){if(!o.isValidNot0(t))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:e,f:r}=p.cached(this,t,t=>Ar(y,t));return Ar(y,[e,r])[0]}multiplyUnsafe(t,e=y.ZERO){if(!o.isValid(t))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return t===qr?y.ZERO:this.is0()||t===Tr?this:p.unsafe(this,t,t=>Ar(y,t),e)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}isTorsionFree(){return p.unsafe(this,s.n).is0()}toAffine(t){return h(this,t)}clearCofactor(){return i===Tr?this:this.multiplyUnsafe(i)}toBytes(){const{x:t,y:e}=this.toAffine(),r=n.toBytes(e);return r[r.length-1]|=t&Tr?128:0,r}toHex(){return Ft(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(t){return Ar(y,t)}static msm(t,e){return Pr(y,o,t,e)}_setWindowSize(t){this.precompute(t)}toRawBytes(){return this.toBytes()}}y.BASE=new y(s.Gx,s.Gy,Tr,c(s.Gx*s.Gy)),y.ZERO=new y(qr,Tr,Tr,qr),y.Fp=n,y.Fn=o;const p=new Cr(y,o.BITS);return y.BASE.precompute(8),y}(e,r);return function(t,e){const r=e.Point;return Object.assign({},e,{ExtendedPoint:r,CURVE:t,nBitLength:r.Fn.BITS,nByteLength:r.Fn.BYTES})}(t,jr(s,n,o))}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Vr=BigInt(1),_r=BigInt(2);BigInt(3);const Zr=BigInt(5),Mr=BigInt(8),Gr=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),zr=(()=>({p:Gr,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:Mr,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")}))();function Yr(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}const $r=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function Xr(t,e){const r=Gr,n=ir(e*e*e,r),o=function(t){const e=BigInt(10),r=BigInt(20),n=BigInt(40),o=BigInt(80),s=Gr,i=t*t%s*t%s,a=ar(i,_r,s)*i%s,c=ar(a,Vr,s)*t%s,u=ar(c,Zr,s)*c%s,f=ar(u,e,s)*u%s,l=ar(f,r,s)*f%s,h=ar(l,n,s)*l%s,d=ar(h,o,s)*h%s,y=ar(d,o,s)*h%s,p=ar(y,e,s)*u%s;return{pow_p_5_8:ar(p,_r,s)*t%s,b2:i}}(t*ir(n*n*e,r)).pow_p_5_8;let s=ir(t*n*o,r);const i=ir(e*s*s,r),a=s,c=ir(s*$r,r),u=i===t,f=i===ir(-t,r),l=i===ir(-t*$r,r);return u&&(s=a),(f||l)&&(s=c),(ir(s,r)&We)===We&&(s=ir(-s,r)),{isValid:u||f,value:s}}const Wr=(()=>gr(zr.p,{isLE:!0}))(),Jr=(()=>({...zr,Fp:Wr,hash:Oe,adjustScalarBytes:Yr,uvRatio:Xr}))(),Qr=(()=>Hr(Jr))(),tn=64;let en;const rn=(async()=>{try{return await X.get().subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),!0}catch{return!1}})();function nn(){const t=Qr.utils.randomPrivateKey(),e=Qr.getPublicKey(t),r=function(t,e){const r=new Uint8Array(tn);for(let n=0;n<32;n++)r[n]=t[n],r[32+n]=e[n];return r}(t,e);return{privateKey:r,publicKey:e}}async function on(t,e){return null==en&&(en=await rn),en?async function(t,e){let r;r=t.length===tn?t.subarray(0,32):t;const n={crv:"Ed25519",kty:"OKP",x:G(t.subarray(32),"base64url"),d:G(r,"base64url"),ext:!0,key_ops:["sign"]},o=await X.get().subtle.importKey("jwk",n,{name:"Ed25519"},!0,["sign"]),s=await X.get().subtle.sign({name:"Ed25519"},o,e instanceof Uint8Array?e:e.subarray());return new Uint8Array(s,0,s.byteLength)}(t,e):function(t,e){const r=t.subarray(0,32);return Qr.sign(e instanceof Uint8Array?e:e.subarray(),r)}(t,e)}async function sn(t,e,r){return null==en&&(en=await rn),en?async function(t,e,r){if(t.buffer instanceof ArrayBuffer){const n=await X.get().subtle.importKey("raw",t.buffer,{name:"Ed25519"},!1,["verify"]);return await X.get().subtle.verify({name:"Ed25519"},n,e,r instanceof Uint8Array?r:r.subarray())}throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys")}(t,e,r):function(t,e,r){return Qr.verify(e,r instanceof Uint8Array?r:r.subarray(),t)}(t,e,r)}function an(t){return null!=t&&("function"==typeof t.then&&"function"==typeof t.catch&&"function"==typeof t.finally)}class cn{constructor(t){o(this,"type","Ed25519"),o(this,"raw"),this.raw=hn(t,32)}toMultihash(){return c.digest(ao(this))}toCID(){return u.createV1(114,this.toMultihash())}toString(){return f.encode(this.toMultihash().bytes).substring(1)}equals(t){return null!=t&&t.raw instanceof Uint8Array&&l(this.raw,t.raw)}verify(t,e,r){var n;null==(n=null==r?void 0:r.signal)||n.throwIfAborted();const o=sn(this.raw,e,t);return an(o)?o.then(t=>{var e;return null==(e=null==r?void 0:r.signal)||e.throwIfAborted(),t}):o}}class un{constructor(t,e){o(this,"type","Ed25519"),o(this,"raw"),o(this,"publicKey"),this.raw=hn(t,tn),this.publicKey=new cn(e)}equals(t){return null!=t&&t.raw instanceof Uint8Array&&l(this.raw,t.raw)}sign(t,e){var r,n;null==(r=null==e?void 0:e.signal)||r.throwIfAborted();const o=on(this.raw,t);return an(o)?o.then(t=>{var r;return null==(r=null==e?void 0:e.signal)||r.throwIfAborted(),t}):(null==(n=null==e?void 0:e.signal)||n.throwIfAborted(),o)}}function fn(t){if(t.length>tn){const e=(t=hn(t,96)).subarray(0,tn),r=t.subarray(tn,t.length);return new un(e,r)}const e=(t=hn(t,tn)).subarray(0,tn),r=t.subarray(32);return new un(e,r)}function ln(t){return t=hn(t,32),new cn(t)}function hn(t,e){if((t=Uint8Array.from(t??[])).length!==e)throw new x(`Key must be a Uint8Array of length ${e}, got ${t.length}`);return t}var dn,yn,pn,wn,bn,gn;(yn=dn||(dn={})).RSA="RSA",yn.Ed25519="Ed25519",yn.secp256k1="secp256k1",yn.ECDSA="ECDSA",(wn=pn||(pn={}))[wn.RSA=0]="RSA",wn[wn.Ed25519=1]="Ed25519",wn[wn.secp256k1=2]="secp256k1",wn[wn.ECDSA=3]="ECDSA",(dn||(dn={})).codec=()=>h(pn),function(t){let e;t.codec=()=>(null==e&&(e=d((t,e,r={})=>{!1!==r.lengthDelimited&&e.fork(),null!=t.Type&&(e.uint32(8),dn.codec().encode(t.Type,e)),null!=t.Data&&(e.uint32(18),e.bytes(t.Data)),!1!==r.lengthDelimited&&e.ldelim()},(t,e,r={})=>{const n={},o=null==e?t.len:t.pos+e;for(;t.pos<o;){const e=t.uint32();switch(e>>>3){case 1:n.Type=dn.codec().decode(t);break;case 2:n.Data=t.bytes();break;default:t.skipType(7&e)}}return n})),e),t.encode=e=>y(e,t.codec()),t.decode=(e,r)=>p(e,t.codec(),r)}(bn||(bn={})),function(t){let e;t.codec=()=>(null==e&&(e=d((t,e,r={})=>{!1!==r.lengthDelimited&&e.fork(),null!=t.Type&&(e.uint32(8),dn.codec().encode(t.Type,e)),null!=t.Data&&(e.uint32(18),e.bytes(t.Data)),!1!==r.lengthDelimited&&e.ldelim()},(t,e,r={})=>{const n={},o=null==e?t.len:t.pos+e;for(;t.pos<o;){const e=t.uint32();switch(e>>>3){case 1:n.Type=dn.codec().decode(t);break;case 2:n.Data=t.bytes();break;default:t.skipType(7&e)}}return n})),e),t.encode=e=>y(e,t.codec()),t.decode=(e,r)=>p(e,t.codec(),r)}(gn||(gn={}));const mn=ke;class En{constructor(t,e){o(this,"type","RSA"),o(this,"jwk"),o(this,"_raw"),o(this,"_multihash"),this.jwk=t,this._multihash=e}get raw(){return null==this._raw&&(this._raw=An(this.jwk)),this._raw}toMultihash(){return this._multihash}toCID(){return u.createV1(114,this._multihash)}toString(){return f.encode(this.toMultihash().bytes).substring(1)}equals(t){return null!=t&&t.raw instanceof Uint8Array&&l(this.raw,t.raw)}verify(t,e,r){return async function(t,e,r,n){var o,s;const i=await X.get().subtle.importKey("jwk",t,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);null==(o=null==n?void 0:n.signal)||o.throwIfAborted();const a=await X.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},i,e,r instanceof Uint8Array?r:r.subarray());return null==(s=null==n?void 0:n.signal)||s.throwIfAborted(),a}(this.jwk,e,t,r)}}class vn{constructor(t,e){o(this,"type","RSA"),o(this,"jwk"),o(this,"_raw"),o(this,"publicKey"),this.jwk=t,this.publicKey=e}get raw(){return null==this._raw&&(this._raw=function(t){if(null==t.n||null==t.e||null==t.d||null==t.p||null==t.q||null==t.dp||null==t.dq||null==t.qi)throw new x("JWK was missing components");return at([st(Uint8Array.from([0])),st(a(t.n,"base64url")),st(a(t.e,"base64url")),st(a(t.d,"base64url")),st(a(t.p,"base64url")),st(a(t.q,"base64url")),st(a(t.dp,"base64url")),st(a(t.dq,"base64url")),st(a(t.qi,"base64url"))]).subarray()}(this.jwk)),this._raw}equals(t){return null!=t&&t.raw instanceof Uint8Array&&l(this.raw,t.raw)}sign(t,e){return async function(t,e,r){var n,o;const s=await X.get().subtle.importKey("jwk",t,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]);null==(n=null==r?void 0:r.signal)||n.throwIfAborted();const i=await X.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},s,e instanceof Uint8Array?e:e.subarray());return null==(o=null==r?void 0:r.signal)||o.throwIfAborted(),new Uint8Array(i,0,i.byteLength)}(this.jwk,t,e)}}const xn=8192,Bn=Uint8Array.from([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);function An(t){if(null==t.n||null==t.e)throw new x("JWK was missing components");return at([Bn,it(at([st(a(t.n,"base64url")),st(a(t.e,"base64url"))]))]).subarray()}function Sn(t){const e=function(t){return{n:G(t[1],"base64url"),e:G(t[2],"base64url"),d:G(t[3],"base64url"),p:G(t[4],"base64url"),q:G(t[5],"base64url"),dp:G(t[6],"base64url"),dq:G(t[7],"base64url"),qi:G(t[8],"base64url"),kty:"RSA"}}(t);return function(t){if(function(t){if("RSA"!==t.kty)throw new x("invalid key type");if(null==t.n)throw new x("invalid key modulus");const e=a(t.n,"base64url");return 8*e.length}(t)>xn)throw new x("Key size is too large");const e=function(t){if(null==t)throw new x("Missing key parameter");return{privateKey:t,publicKey:{kty:t.kty,n:t.n,e:t.e}}}(t),r=mn(bn.encode({Type:dn.RSA,Data:An(e.publicKey)})),n=w(18,r);return new vn(e.privateKey,new En(e.publicKey,n))}(e)}function In(t,e){if(t.byteLength>=1062)throw new B("Key size is too large");return function(t,e,r){const n=function(t){const e=et(t[1],{offset:0});return{kty:"RSA",n:G(e[0],"base64url"),e:G(e[1],"base64url")}}(t);if(null==r){const t=mn(bn.encode({Type:dn.RSA,Data:e}));r=w(18,t)}return new En(n,r)}(et(t,{offset:0}),t,e)}async function Rn(t){if(t>xn)throw new x("Key size is too large");const e=await async function(t){const e=await X.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:t,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),r=await async function(t){if(null==t.privateKey||null==t.publicKey)throw new x("Private and public key are required");const e=await Promise.all([X.get().subtle.exportKey("jwk",t.privateKey),X.get().subtle.exportKey("jwk",t.publicKey)]);return e}(e);return{privateKey:r[0],publicKey:r[1]}}(t),r=mn(bn.encode({Type:dn.RSA,Data:An(e.publicKey)})),n=w(18,r);return new vn(e.privateKey,new En(e.publicKey,n))}class Un extends Wt{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,Rt(t);const r=zt(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,o=new Uint8Array(n);o.set(r.length>n?t.create().update(r).digest():r);for(let s=0;s<o.length;s++)o[s]^=54;this.iHash.update(o),this.oHash=t.create();for(let s=0;s<o.length;s++)o[s]^=106;this.oHash.update(o),Kt(o)}update(t){return Ut(this),this.iHash.update(t),this}digestInto(t){Ut(this),It(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:o,blockLen:s,outputLen:i}=this;return t.finished=n,t.destroyed=o,t.blockLen=s,t.outputLen=i,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Kn=(t,e,r)=>new Un(t,e).update(r).digest();Kn.create=(t,e)=>new Un(t,e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const kn=(t,e)=>(t+(t>=0?e:-e)/Tn)/e;function On(t){if(!["compact","recovered","der"].includes(t))throw new Error('Signature format must be "compact", "recovered", or "der"');return t}function Cn(t,e){const r={};for(let n of Object.keys(e))r[n]=void 0===t[n]?e[n]:t[n];return De(r.lowS,"lowS"),De(r.prehash,"prehash"),void 0!==r.format&&On(r.format),r}class Pn extends Error{constructor(t=""){super(t)}}const Dn={Err:Pn,_tlv:{encode:(t,e)=>{const{Err:r}=Dn;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(1&e.length)throw new r("tlv.encode: unpadded data");const n=e.length/2,o=qe(n);if(o.length/2&128)throw new r("tlv.encode: long form length too big");const s=n>127?qe(o.length/2|128):"";return qe(t)+s+o+e},decode(t,e){const{Err:r}=Dn;let n=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new r("tlv.decode: wrong tlv");const o=e[n++];let s=0;if(!!(128&o)){const t=127&o;if(!t)throw new r("tlv.decode(long): indefinite length not supported");if(t>4)throw new r("tlv.decode(long): byte length is too big");const i=e.subarray(n,n+t);if(i.length!==t)throw new r("tlv.decode: length bytes not complete");if(0===i[0])throw new r("tlv.decode(long): zero leftmost byte");for(const e of i)s=s<<8|e;if(n+=t,s<128)throw new r("tlv.decode(long): not minimal encoding")}else s=o;const i=e.subarray(n,n+s);if(i.length!==s)throw new r("tlv.decode: wrong value length");return{v:i,l:e.subarray(n+s)}}},_int:{encode(t){const{Err:e}=Dn;if(t<Fn)throw new e("integer: negative integers are not allowed");let r=qe(t);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:e}=Dn;if(128&t[0])throw new e("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("invalid signature integer: unnecessary leading zero");return Le(t)}},toSig(t){const{Err:e,_int:r,_tlv:n}=Dn,o=Ve("signature",t),{v:s,l:i}=n.decode(48,o);if(i.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,s),{v:u,l:f}=n.decode(2,c);if(f.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(u)}},hexFromSig(t){const{_tlv:e,_int:r}=Dn,n=e.encode(2,r.encode(t.r))+e.encode(2,r.encode(t.s));return e.encode(48,n)}},Fn=BigInt(0),qn=BigInt(1),Tn=BigInt(2),Ln=BigInt(3),Nn=BigInt(4);function jn(t,e){const{BYTES:r}=t;let n;if("bigint"==typeof e)n=e;else{let s=Ve("private key",e);try{n=t.fromBytes(s)}catch(o){throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof e}`)}}if(!t.isValidNot0(n))throw new Error("invalid private key: out of range [1..N-1]");return n}function Hn(t,e={}){const r=Fr("weierstrass",t,e),{Fp:n,Fn:o}=r;let s=r.CURVE;const{h:i,n:a}=s;Ye(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:c}=e;if(c&&(!n.is0(s.a)||"bigint"!=typeof c.beta||!Array.isArray(c.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const u=_n(n,o);function f(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}const l=e.toBytes||function(t,e,r){const{x:o,y:s}=e.toAffine(),i=n.toBytes(o);if(De(r,"isCompressed"),r){f();return $t(Vn(!n.isOdd(s)),i)}return $t(Uint8Array.of(4),i,n.toBytes(s))},h=e.fromBytes||function(t){Fe(t,void 0,"Point");const{publicKey:e,publicKeyUncompressed:r}=u,o=t.length,s=t[0],i=t.subarray(1);if(o!==e||2!==s&&3!==s){if(o===r&&4===s){const t=n.BYTES,e=n.fromBytes(i.subarray(0,t)),r=n.fromBytes(i.subarray(t,2*t));if(!y(e,r))throw new Error("bad point: is not on curve");return{x:e,y:r}}throw new Error(`bad point: got length ${o}, expected compressed=${e} or uncompressed=${r}`)}{const t=n.fromBytes(i);if(!n.isValid(t))throw new Error("bad point: is not on curve, wrong x");const e=d(t);let r;try{r=n.sqrt(e)}catch(a){const t=a instanceof Error?": "+a.message:"";throw new Error("bad point: is not on curve, sqrt error"+t)}f();return!(1&~s)!==n.isOdd(r)&&(r=n.neg(r)),{x:t,y:r}}};function d(t){const e=n.sqr(t),r=n.mul(e,t);return n.add(n.add(r,n.mul(t,s.a)),s.b)}function y(t,e){const r=n.sqr(e),o=d(t);return n.eql(r,o)}if(!y(s.Gx,s.Gy))throw new Error("bad curve params: generator point");const p=n.mul(n.pow(s.a,Ln),Nn),w=n.mul(n.sqr(s.b),BigInt(27));if(n.is0(n.add(p,w)))throw new Error("bad curve params: a or b");function b(t,e,r=!1){if(!n.isValid(e)||r&&n.is0(e))throw new Error(`bad point coordinate ${t}`);return e}function g(t){if(!(t instanceof B))throw new Error("ProjectivePoint expected")}function m(t){if(!c||!c.basises)throw new Error("no endo");return function(t,e,r){const[[n,o],[s,i]]=e,a=kn(i*t,r),c=kn(-o*t,r);let u=t-a*n-c*s,f=-a*o-c*i;const l=u<Fn,h=f<Fn;l&&(u=-u),h&&(f=-f);const d=ze(Math.ceil(Ge(r)/2))+qn;if(u<Fn||u>=d||f<Fn||f>=d)throw new Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:l,k1:u,k2neg:h,k2:f}}(t,c.basises,o.ORDER)}const E=$e((t,e)=>{const{X:r,Y:o,Z:s}=t;if(n.eql(s,n.ONE))return{x:r,y:o};const i=t.is0();null==e&&(e=i?n.ONE:n.inv(s));const a=n.mul(r,e),c=n.mul(o,e),u=n.mul(s,e);if(i)return{x:n.ZERO,y:n.ZERO};if(!n.eql(u,n.ONE))throw new Error("invZ was invalid");return{x:a,y:c}}),v=$e(t=>{if(t.is0()){if(e.allowInfinityPoint&&!n.is0(t.Y))return;throw new Error("bad point: ZERO")}const{x:r,y:o}=t.toAffine();if(!n.isValid(r)||!n.isValid(o))throw new Error("bad point: x or y not field elements");if(!y(r,o))throw new Error("bad point: equation left != right");if(!t.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function x(t,e,r,o,s){return r=new B(n.mul(r.X,t),r.Y,r.Z),e=Br(o,e),r=Br(s,r),e.add(r)}class B{constructor(t,e,r){this.X=b("x",t),this.Y=b("y",e,!0),this.Z=b("z",r),Object.freeze(this)}static CURVE(){return s}static fromAffine(t){const{x:e,y:r}=t||{};if(!t||!n.isValid(e)||!n.isValid(r))throw new Error("invalid affine point");if(t instanceof B)throw new Error("projective point not allowed");return n.is0(e)&&n.is0(r)?B.ZERO:new B(e,r,n.ONE)}static fromBytes(t){const e=B.fromAffine(h(Fe(t,void 0,"point")));return e.assertValidity(),e}static fromHex(t){return B.fromBytes(Ve("pointHex",t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(t=8,e=!0){return S.createCache(this,t),e||this.multiply(Ln),this}assertValidity(){v(this)}hasEvenY(){const{y:t}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(t)}equals(t){g(t);const{X:e,Y:r,Z:o}=this,{X:s,Y:i,Z:a}=t,c=n.eql(n.mul(e,a),n.mul(s,o)),u=n.eql(n.mul(r,a),n.mul(i,o));return c&&u}negate(){return new B(this.X,n.neg(this.Y),this.Z)}double(){const{a:t,b:e}=s,r=n.mul(e,Ln),{X:o,Y:i,Z:a}=this;let c=n.ZERO,u=n.ZERO,f=n.ZERO,l=n.mul(o,o),h=n.mul(i,i),d=n.mul(a,a),y=n.mul(o,i);return y=n.add(y,y),f=n.mul(o,a),f=n.add(f,f),c=n.mul(t,f),u=n.mul(r,d),u=n.add(c,u),c=n.sub(h,u),u=n.add(h,u),u=n.mul(c,u),c=n.mul(y,c),f=n.mul(r,f),d=n.mul(t,d),y=n.sub(l,d),y=n.mul(t,y),y=n.add(y,f),f=n.add(l,l),l=n.add(f,l),l=n.add(l,d),l=n.mul(l,y),u=n.add(u,l),d=n.mul(i,a),d=n.add(d,d),l=n.mul(d,y),c=n.sub(c,l),f=n.mul(d,h),f=n.add(f,f),f=n.add(f,f),new B(c,u,f)}add(t){g(t);const{X:e,Y:r,Z:o}=this,{X:i,Y:a,Z:c}=t;let u=n.ZERO,f=n.ZERO,l=n.ZERO;const h=s.a,d=n.mul(s.b,Ln);let y=n.mul(e,i),p=n.mul(r,a),w=n.mul(o,c),b=n.add(e,r),m=n.add(i,a);b=n.mul(b,m),m=n.add(y,p),b=n.sub(b,m),m=n.add(e,o);let E=n.add(i,c);return m=n.mul(m,E),E=n.add(y,w),m=n.sub(m,E),E=n.add(r,o),u=n.add(a,c),E=n.mul(E,u),u=n.add(p,w),E=n.sub(E,u),l=n.mul(h,m),u=n.mul(d,w),l=n.add(u,l),u=n.sub(p,l),l=n.add(p,l),f=n.mul(u,l),p=n.add(y,y),p=n.add(p,y),w=n.mul(h,w),m=n.mul(d,m),p=n.add(p,w),w=n.sub(y,w),w=n.mul(h,w),m=n.add(m,w),y=n.mul(p,m),f=n.add(f,y),y=n.mul(E,m),u=n.mul(b,u),u=n.sub(u,y),y=n.mul(b,p),l=n.mul(E,l),l=n.add(l,y),new B(u,f,l)}subtract(t){return this.add(t.negate())}is0(){return this.equals(B.ZERO)}multiply(t){const{endo:r}=e;if(!o.isValidNot0(t))throw new Error("invalid scalar: out of range");let n,s;const i=t=>S.cached(this,t,t=>Ar(B,t));if(r){const{k1neg:e,k1:o,k2neg:a,k2:c}=m(t),{p:u,f:f}=i(o),{p:l,f:h}=i(c);s=f.add(h),n=x(r.beta,u,l,e,a)}else{const{p:e,f:r}=i(t);n=e,s=r}return Ar(B,[n,s])[0]}multiplyUnsafe(t){const{endo:r}=e,n=this;if(!o.isValid(t))throw new Error("invalid scalar: out of range");if(t===Fn||n.is0())return B.ZERO;if(t===qn)return n;if(S.hasCache(this))return this.multiply(t);if(r){const{k1neg:e,k1:o,k2neg:s,k2:i}=m(t),{p1:a,p2:c}=function(t,e,r,n){let o=e,s=t.ZERO,i=t.ZERO;for(;r>vr||n>vr;)r&xr&&(s=s.add(o)),n&xr&&(i=i.add(o)),o=o.double(),r>>=xr,n>>=xr;return{p1:s,p2:i}}(B,n,o,i);return x(r.beta,a,c,e,s)}return S.unsafe(n,t)}multiplyAndAddUnsafe(t,e,r){const n=this.multiplyUnsafe(e).add(t.multiplyUnsafe(r));return n.is0()?void 0:n}toAffine(t){return E(this,t)}isTorsionFree(){const{isTorsionFree:t}=e;return i===qn||(t?t(B,this):S.unsafe(this,a).is0())}clearCofactor(){const{clearCofactor:t}=e;return i===qn?this:t?t(B,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(t=!0){return De(t,"isCompressed"),this.assertValidity(),l(B,this,t)}toHex(t=!0){return Ft(this.toBytes(t))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(t=!0){return this.toBytes(t)}_setWindowSize(t){this.precompute(t)}static normalizeZ(t){return Ar(B,t)}static msm(t,e){return Pr(B,o,t,e)}static fromPrivateKey(t){return B.BASE.multiply(jn(o,t))}}B.BASE=new B(s.Gx,s.Gy,n.ONE),B.ZERO=new B(n.ZERO,n.ONE,n.ZERO),B.Fp=n,B.Fn=o;const A=o.BITS,S=new Cr(B,e.endo?Math.ceil(A/2):A);return B.BASE.precompute(8),B}function Vn(t){return Uint8Array.of(t?2:3)}function _n(t,e){return{secretKey:e.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function Zn(t,e={}){const{Fn:r}=t,n=e.randomBytes||Qt,o=Object.assign(_n(t.Fp,r),{seed:Er(r.ORDER)});function s(t){try{return!!jn(r,t)}catch(e){return!1}}function i(t=n(o.seed)){return function(t,e,r=!1){const n=t.length,o=mr(e),s=Er(e);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);const i=ir(r?Ne(t):Le(t),e-We)+We;return r?He(i,o):je(i,o)}(Fe(t,o.seed,"seed"),r.ORDER)}function a(e,n=!0){return t.BASE.multiply(jn(r,e)).toBytes(n)}function c(e){if("bigint"==typeof e)return!1;if(e instanceof t)return!0;const{secretKey:n,publicKey:s,publicKeyUncompressed:i}=o;if(r.allowedLengths||n===s)return;const a=Ve("key",e).length;return a===s||a===i}const u={isValidSecretKey:s,isValidPublicKey:function(e,r){const{publicKey:n,publicKeyUncompressed:s}=o;try{const o=e.length;return(!0!==r||o===n)&&((!1!==r||o===s)&&!!t.fromBytes(e))}catch(i){return!1}},randomSecretKey:i,isValidPrivateKey:s,randomPrivateKey:i,normPrivateKeyToScalar:t=>jn(r,t),precompute:(e=8,r=t.BASE)=>r.precompute(e,!1)};return Object.freeze({getPublicKey:a,getSharedSecret:function(e,n,o=!0){if(!0===c(e))throw new Error("first arg must be private key");if(!1===c(n))throw new Error("second arg must be public key");const s=jn(r,e);return t.fromHex(n).multiply(s).toBytes(o)},keygen:function(t){const e=i(t);return{secretKey:e,publicKey:a(e)}},Point:t,utils:u,lengths:o})}function Mn(t,e,r={}){Rt(e),Ye(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const n=r.randomBytes||Qt,o=r.hmac||((t,...r)=>Kn(e,t,$t(...r))),{Fp:s,Fn:i}=t,{ORDER:a,BITS:c}=i,{keygen:u,getPublicKey:f,getSharedSecret:l,utils:h,lengths:d}=Zn(t,r),y={prehash:!1,lowS:"boolean"==typeof r.lowS&&r.lowS,format:void 0,extraEntropy:!1},p="compact";function w(t){return t>a>>qn}function b(t,e){if(!i.isValidNot0(e))throw new Error(`invalid signature ${t}: out of range 1..Point.Fn.ORDER`);return e}class g{constructor(t,e,r){this.r=b("r",t),this.s=b("s",e),null!=r&&(this.recovery=r),Object.freeze(this)}static fromBytes(t,e=p){let r;if(function(t,e){On(e);const r=d.signature;Fe(t,"compact"===e?r:"recovered"===e?r+1:void 0,`${e} signature`)}(t,e),"der"===e){const{r:e,s:r}=Dn.toSig(Fe(t));return new g(e,r)}"recovered"===e&&(r=t[0],e="compact",t=t.subarray(1));const n=i.BYTES,o=t.subarray(0,n),s=t.subarray(n,2*n);return new g(i.fromBytes(o),i.fromBytes(s),r)}static fromHex(t,e){return this.fromBytes(_t(t),e)}addRecoveryBit(t){return new g(this.r,this.s,t)}recoverPublicKey(e){const r=s.ORDER,{r:n,s:o,recovery:c}=this;if(null==c||![0,1,2,3].includes(c))throw new Error("recovery id invalid");if(a*Tn<r&&c>1)throw new Error("recovery id is ambiguous for h>1 curve");const u=2===c||3===c?n+a:n;if(!s.isValid(u))throw new Error("recovery id 2 or 3 invalid");const f=s.toBytes(u),l=t.fromBytes($t(Vn(!(1&c)),f)),h=i.inv(u),d=E(Ve("msgHash",e)),y=i.create(-d*h),p=i.create(o*h),w=t.BASE.multiplyUnsafe(y).add(l.multiplyUnsafe(p));if(w.is0())throw new Error("point at infinify");return w.assertValidity(),w}hasHighS(){return w(this.s)}toBytes(t=p){if(On(t),"der"===t)return _t(Dn.hexFromSig(this));const e=i.toBytes(this.r),r=i.toBytes(this.s);if("recovered"===t){if(null==this.recovery)throw new Error("recovery bit must be present");return $t(Uint8Array.of(this.recovery),e,r)}return $t(e,r)}toHex(t){return Ft(this.toBytes(t))}assertValidity(){}static fromCompact(t){return g.fromBytes(Ve("sig",t),"compact")}static fromDER(t){return g.fromBytes(Ve("sig",t),"der")}normalizeS(){return this.hasHighS()?new g(this.r,i.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return Ft(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return Ft(this.toBytes("compact"))}}const m=r.bits2int||function(t){if(t.length>8192)throw new Error("input is too large");const e=Le(t),r=8*t.length-c;return r>0?e>>BigInt(r):e},E=r.bits2int_modN||function(t){return i.create(m(t))},v=ze(c);function x(t){return Me("num < 2^"+c,t,Fn,v),i.toBytes(t)}function B(t,r){return Fe(t,void 0,"message"),r?Fe(e(t),void 0,"prehashed message"):t}return Object.freeze({keygen:u,getPublicKey:f,getSharedSecret:l,utils:h,lengths:d,Point:t,sign:function(r,s,a={}){r=Ve("message",r);const{seed:c,k2sig:u}=function(e,r,o){if(["recovered","canonical"].some(t=>t in o))throw new Error("sign() legacy options not supported");const{lowS:s,prehash:a,extraEntropy:c}=Cn(o,y);e=B(e,a);const u=E(e),f=jn(i,r),l=[x(f),x(u)];if(null!=c&&!1!==c){const t=!0===c?n(d.secretKey):c;l.push(Ve("extraEntropy",t))}const h=$t(...l),p=u;return{seed:h,k2sig:function(e){const r=m(e);if(!i.isValidNot0(r))return;const n=i.inv(r),o=t.BASE.multiply(r).toAffine(),a=i.create(o.x);if(a===Fn)return;const c=i.create(n*i.create(p+a*f));if(c===Fn)return;let u=(o.x===a?0:2)|Number(o.y&qn),l=c;return s&&w(c)&&(l=i.neg(c),u^=1),new g(a,l,u)}}}(r,s,a);return function(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");const n=t=>new Uint8Array(t),o=t=>Uint8Array.of(t);let s=n(t),i=n(t),a=0;const c=()=>{s.fill(1),i.fill(0),a=0},u=(...t)=>r(i,s,...t),f=(t=n(0))=>{i=u(o(0),t),s=u(),0!==t.length&&(i=u(o(1),t),s=u())},l=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){s=u();const e=s.slice();r.push(e),t+=s.length}return $t(...r)};return(t,e)=>{let r;for(c(),f(t);!(r=e(l()));)f();return c(),r}}(e.outputLen,i.BYTES,o)(c,u)},verify:function(e,r,n,o={}){const{lowS:s,prehash:a,format:c}=Cn(o,y);if(n=Ve("publicKey",n),r=B(Ve("message",r),a),"strict"in o)throw new Error("options.strict was renamed to lowS");const u=void 0===c?function(t){let e;const r="string"==typeof t||At(t),n=!r&&null!==t&&"object"==typeof t&&"bigint"==typeof t.r&&"bigint"==typeof t.s;if(!r&&!n)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(n)e=new g(t.r,t.s);else if(r){try{e=g.fromBytes(Ve("sig",t),"der")}catch(o){if(!(o instanceof Dn.Err))throw o}if(!e)try{e=g.fromBytes(Ve("sig",t),"compact")}catch(s){return!1}}return e||!1}(e):g.fromBytes(Ve("sig",e),c);if(!1===u)return!1;try{const e=t.fromBytes(n);if(s&&u.hasHighS())return!1;const{r:o,s:a}=u,c=E(r),f=i.inv(a),l=i.create(c*f),h=i.create(o*f),d=t.BASE.multiplyUnsafe(l).add(e.multiplyUnsafe(h));if(d.is0())return!1;return i.create(d.x)===o}catch(f){return!1}},recoverPublicKey:function(t,e,r={}){const{prehash:n}=Cn(r,y);return e=B(e,n),g.fromBytes(t,"recovered").recoverPublicKey(e).toBytes()},Signature:g,hash:e})}function Gn(t){const{CURVE:e,curveOpts:r}=function(t){const e={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},r=t.Fp;let n=t.allowedPrivateKeyLengths?Array.from(new Set(t.allowedPrivateKeyLengths.map(t=>Math.ceil(t/2)))):void 0;return{CURVE:e,curveOpts:{Fp:r,Fn:gr(e.n,{BITS:t.nBitLength,allowedLengths:n,modFromBytes:t.wrapPrivateKey}),allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes}}}(t),n={hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN};return{CURVE:e,curveOpts:r,hash:t.hash,ecdsaOpts:n}}function zn(t){const{CURVE:e,curveOpts:r,hash:n,ecdsaOpts:o}=Gn(t);return function(t,e){const r=e.Point;return Object.assign({},e,{ProjectivePoint:r,CURVE:Object.assign({},t,br(r.Fn.ORDER,r.Fn.BITS))})}(t,Mn(Hn(e,r),n,o))}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Yn={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},$n={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Xn=BigInt(2);const Wn=gr(Yn.p,{sqrt:function(t){const e=Yn.p,r=BigInt(3),n=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),a=BigInt(44),c=BigInt(88),u=t*t*t%e,f=u*u*t%e,l=ar(f,r,e)*f%e,h=ar(l,r,e)*f%e,d=ar(h,Xn,e)*u%e,y=ar(d,o,e)*d%e,p=ar(y,s,e)*y%e,w=ar(p,a,e)*p%e,b=ar(w,c,e)*w%e,g=ar(b,a,e)*p%e,m=ar(g,r,e)*f%e,E=ar(m,i,e)*y%e,v=ar(E,n,e)*u%e,x=ar(v,Xn,e);if(!Wn.eql(Wn.sqr(x),t))throw new Error("Cannot find square root");return x}}),Jn=function(t,e){const r=e=>zn({...t,hash:e});return{...r(e),create:r}}({...Yn,Fp:Wn,lowS:!0,endo:$n},ke);class Qn{constructor(t){o(this,"type","secp256k1"),o(this,"raw"),o(this,"_key"),this._key=function(t){try{return Jn.ProjectivePoint.fromHex(t),t}catch(e){throw new B(String(e))}}(t),this.raw=function(t){const e=Jn.ProjectivePoint.fromHex(t).toRawBytes(!0);return e}(this._key)}toMultihash(){return c.digest(ao(this))}toCID(){return u.createV1(114,this.toMultihash())}toString(){return f.encode(this.toMultihash().bytes).substring(1)}equals(t){return null!=t&&t.raw instanceof Uint8Array&&l(this.raw,t.raw)}verify(t,e,r){return function(t,e,r,n){var o;const s=b.digest(r instanceof Uint8Array?r:r.subarray());if(an(s))return s.then(({digest:r})=>{var o;return null==(o=null==n?void 0:n.signal)||o.throwIfAborted(),Jn.verify(e,r,t)}).catch(t=>{if("AbortError"===t.name)throw t;throw new Y(String(t))});try{return null==(o=null==n?void 0:n.signal)||o.throwIfAborted(),Jn.verify(e,s.digest,t)}catch(i){throw new Y(String(i))}}(this._key,e,t,r)}}class to{constructor(t,e){o(this,"type","secp256k1"),o(this,"raw"),o(this,"publicKey"),this.raw=function(t){try{return Jn.getPublicKey(t,!0),t}catch(e){throw new A(String(e))}}(t),this.publicKey=new Qn(e??function(t){try{return Jn.getPublicKey(t,!0)}catch(e){throw new A(String(e))}}(t))}equals(t){return null!=t&&t.raw instanceof Uint8Array&&l(this.raw,t.raw)}sign(t,e){return function(t,e,r){const n=b.digest(e instanceof Uint8Array?e:e.subarray());if(an(n))return n.then(({digest:e})=>{var n;return null==(n=null==r?void 0:r.signal)||n.throwIfAborted(),Jn.sign(e,t).toDERRawBytes()}).catch(t=>{if("AbortError"===t.name)throw t;throw new z(String(t))});try{return Jn.sign(n.digest,t).toDERRawBytes()}catch(o){throw new z(String(o))}}(this.raw,t,e)}}function eo(t){return new to(t)}function ro(t){return new Qn(t)}async function no(){const t=Jn.utils.randomPrivateKey();return new to(t)}async function oo(t,e){if("Ed25519"===t)return async function(){const{privateKey:t,publicKey:e}=nn();return new un(t,e)}();if("secp256k1"===t)return no();if("RSA"===t)return Rn(2048);if("ECDSA"===t)return Et("P-256");throw new M}function so(t,e){const{Type:r,Data:n}=bn.decode(t),o=n??new Uint8Array;switch(r){case dn.RSA:return In(o,e);case dn.Ed25519:return ln(o);case dn.secp256k1:return ro(o);case dn.ECDSA:return gt(o);default:throw new M}}function io(t){const{Type:e,Data:r}=bn.decode(t.digest),n=r??new Uint8Array;switch(e){case dn.Ed25519:return ln(n);case dn.secp256k1:return ro(n);case dn.ECDSA:return gt(n);default:throw new M}}function ao(t){return bn.encode({Type:dn[t.type],Data:t.raw})}function co(t){const e=gn.decode(t),r=e.Data??new Uint8Array;switch(e.Type){case dn.RSA:return Sn(et(r));case dn.Ed25519:return fn(r);case dn.secp256k1:return eo(r);case dn.ECDSA:return function(t){return bt(et(t))}(r);default:throw new M}}function uo(t){var e;if(t.byteLength===tn)return fn(t);if(32===t.byteLength)return eo(t);const r=et(t),n=null==(e=r[2])?void 0:e[0];if("1.2.840.10045.3.1.7"===n||"1.3.132.0.34"===n||"1.3.132.0.35"===n)return bt(r);if(r.length>8)return Sn(r);throw new x("Could not extract private key from raw bytes")}function fo(t){return gn.encode({Type:dn[t.type],Data:t.raw})}const lo=Symbol.for("nodejs.util.inspect.custom");class ho{constructor(e){o(this,"type"),o(this,"multihash"),o(this,"publicKey"),o(this,"string"),o(this,t,!0),this.type=e.type,this.multihash=e.multihash,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}toString(){return null==this.string&&(this.string=f.encode(this.multihash.bytes).slice(1)),this.string}toMultihash(){return this.multihash}toCID(){return u.createV1(114,this.multihash)}toJSON(){return this.toString()}equals(t){var e;if(null==t)return!1;if(t instanceof Uint8Array)return l(this.multihash.bytes,t);if("string"==typeof t)return this.toString()===t;if(null!=(null==(e=null==t?void 0:t.toMultihash())?void 0:e.bytes))return l(this.multihash.bytes,t.toMultihash().bytes);throw new Error("not valid Id")}[(t=m,lo)](){return`PeerId(${this.toString()})`}}class yo extends ho{constructor(t){super({...t,type:"RSA"}),o(this,"type","RSA"),o(this,"publicKey"),this.publicKey=t.publicKey}}class po extends ho{constructor(t){super({...t,type:"Ed25519"}),o(this,"type","Ed25519"),o(this,"publicKey"),this.publicKey=t.publicKey}}class wo extends ho{constructor(t){super({...t,type:"secp256k1"}),o(this,"type","secp256k1"),o(this,"publicKey"),this.publicKey=t.publicKey}}class bo{constructor(t){o(this,"type","url"),o(this,"multihash"),o(this,"publicKey"),o(this,"url"),o(this,e,!0),this.url=t.toString(),this.multihash=c.digest(a(this.url))}[(r=lo,e=m,r)](){return`PeerId(${this.url})`}toString(){return this.toCID().toString()}toMultihash(){return this.multihash}toCID(){return u.createV1(2336,this.toMultihash())}toJSON(){return this.toString()}equals(t){return null!=t&&(t instanceof Uint8Array&&(t=G(t)),t.toString()===this.toString())}}function go(t,e){let r;if("1"!==t.charAt(0)&&"Q"!==t.charAt(0)){if(t.startsWith("k51qzi5uqu5")||t.startsWith("kzwfwjn5ji4")||t.startsWith("k2k4r8")||t.startsWith("bafz"))return xo(u.parse(t));throw new x('Please pass a multibase decoder for strings that do not start with "1" or "Q"')}return r=g(f.decode(`z${t}`)),vo(r)}function mo(t){if("Ed25519"===t.type)return new po({multihash:t.toCID().multihash,publicKey:t});if("secp256k1"===t.type)return new wo({multihash:t.toCID().multihash,publicKey:t});if("RSA"===t.type)return new yo({multihash:t.toCID().multihash,publicKey:t});throw new M}function Eo(t){return mo(t.publicKey)}function vo(t){if(function(t){return t.code===b.code}(t))return new yo({multihash:t});if(function(t){return t.code===c.code}(t))try{const e=io(t);if("Ed25519"===e.type)return new po({multihash:t,publicKey:e});if("secp256k1"===e.type)return new wo({multihash:t,publicKey:e})}catch(e){const r=G(t.digest);return new bo(new URL(r))}throw new D("Supplied PeerID Multihash is invalid")}function xo(t){if(null==(null==t?void 0:t.multihash)||null==t.version||1===t.version&&114!==t.code&&2336!==t.code)throw new P("Supplied PeerID CID is invalid");if(2336===t.code){const e=G(t.multihash.digest);return new bo(new URL(e))}return vo(t.multihash)}export{T as $,v as A,Kn as B,I as C,j as D,Kt as E,Mt as F,Jt as G,re as H,D as I,Ct as J,te as K,H as L,ee as M,k as N,Oe as O,mn as P,X as Q,M as R,fo as S,L as T,F as U,co as V,uo as W,K as X,U as Y,R as Z,B as _,vo as a,go as b,xo as c,so as d,io as e,q as f,x as g,mo as h,E as i,C as j,N as k,O as l,S as m,V as n,_ as o,ao as p,Z as q,Qt as r,oo as s,G as t,Eo as u,kt as v,Rt as w,Xt as x,St as y,Yt as z};
