var t,r,e,n=Object.defineProperty,o=t=>{throw TypeError(t)},a=(t,r,e)=>((t,r,e)=>r in t?n(t,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[r]=e)(t,"symbol"!=typeof r?r+"":r,e),s=(t,r,e)=>(((t,r,e)=>{r.has(t)||o("Cannot "+e)})(t,r,"access private method"),e);import{l as i}from"./index.DnnBcP15.js";import{p as c,b as l,c as u,t as d,N as h}from"./index.BofkdKOa.js";import{N as p,I as f,n as w,c as y,i as g,a as m,S as v,L as b,m as E,u as N,b as k,d as S,e as T,f as D}from"./selector.BiFyX8Ct.js";import{f as x,C as P,a as C,e as $,b as L,c as A,d as M}from"./message.Ve-2rN-7.js";import{R as I,K as R}from"./key.PHAHNoTJ.js";import"./mermaid-core.CmyEpniE.js";import"./decode.9RDMYjMh.js";const j=i("ipns"),U=3e11,V={v1Compatible:!0,ttlNs:U};const F=async(t,r,e,n,o,a,s=V)=>{e=BigInt(e);const i=x(o),l=w(r),u=x(l),d=y(u,n,i,e,a),h=g(d),p=await t.sign(h);let f;if("RSA"===t.type&&(f=c(t.publicKey)),!0===s.v1Compatible){const r={value:l,signatureV1:await W(t,u,n,i),validity:o,validityType:n,sequence:e,ttl:a,signatureV2:p,data:d};return null!=f&&(r.pubKey=f),r}{const t={value:l,validity:o,validityType:n,sequence:e,ttl:a,signatureV2:p,data:d};return null!=f&&(t.pubKey=f),t}},W=async(t,r,e,n)=>{try{const o=m(r,e,n);return await t.sign(o)}catch(o){throw j.error("record signature creation failed",o),new v("Record signature creation failed")}};class q extends Error{constructor(t="DNSLink not found"){super(t),this.name="DNSLinkNotFoundError"}}a(q,"name","DNSLinkNotFoundError");class K extends Error{constructor(t="Records failed validation"){super(t),this.name="RecordsFailedValidationError"}}a(K,"name","RecordsFailedValidationError");class O extends Error{constructor(t="Unsupported multibase prefix"){super(t),this.name="UnsupportedMultibasePrefixError"}}a(O,"name","UnsupportedMultibasePrefixError");class _ extends Error{constructor(t="Unsupported multihash codec"){super(t),this.name="UnsupportedMultihashCodecError"}}a(_,"name","UnsupportedMultihashCodecError");class z extends Error{constructor(t="Invalid value"){super(t),this.name="InvalidValueError"}}a(z,"name","InvalidValueError");async function B(t,r,e,n,o={}){if(0===r)throw new Error("recursion limit exceeded");n("query %s for TXT and CNAME records",t);const a=await e.query(t,{...o,types:[I.TXT]}),s=((null==a?void 0:a.Answer)??[]).sort((t,r)=>t.data.localeCompare(r.data));n("found %d TXT records for %s",s.length,t);for(const h of s)try{let a=h.data;if(a.startsWith('"')&&a.endsWith('"')&&(a=a.substring(1,a.length-1)),!a.startsWith("dnslink="))continue;n("%s TXT %s",h.name,a),a=a.replace("dnslink=","");const[,s,i,...c]=a.split("/");if("ipfs"!==s){if("ipns"===s){try{let t;return t="1"===i.charAt(0)||"Q"===i.charAt(0)?l(i):u(P.parse(i)),{value:`/ipns/${t}${c.length>0?`/${c.join("/")}`:""}`,answer:h}}catch{}return await X(i,r-1,e,n,o)}if("dnslink"===s)return await X(i,r-1,e,n,o);n('unknown protocol "%s" in DNSLink record for domain: %s',s,t);continue}try{return{value:`/ipfs/${P.parse(i)}${c.length>0?`/${c.join("/")}`:""}`,answer:h}}catch{}}catch(d){n.error("could not parse DNS link record for domain %s, %s",t,h.data,d)}n("no DNSLink records found for %s, falling back to CNAME",t);const i=await e.query(t,{...o,types:[I.CNAME]}),c=((null==i?void 0:i.Answer)??[]).sort((t,r)=>t.data.localeCompare(r.data));n("found %d CNAME records for %s",c.length,t);for(const l of c)try{return await X(l.data,r-1,e,n,o)}catch(d){n.error("domain %s cname %s had no DNSLink records",t,l.data,d)}throw new q(`No DNSLink records found for domain: ${t}`)}async function X(t,r,e,n,o={}){if(0===r)throw new Error("recursion limit exceeded");t.startsWith("_dnslink.")||(t=`_dnslink.${t}`);try{return await B(t,r,e,n,o)}catch(a){if("ENOTFOUND"!==a.code&&"ENODATA"!==a.code&&"DNSLinkNotFoundError"!==a.name&&"NotFoundError"!==a.name)throw a;return B(t=t.startsWith("_dnslink.")?t.replace("_dnslink.",""):`_dnslink.${t}`,r,e,n,o)}}class Q{constructor(t){a(this,"routing"),this.routing=t}async put(t,r,e={}){var n;try{await this.routing.put(t,r,e)}catch(o){throw null==(n=e.onProgress)||n.call(e,new C("ipns:routing:helia:error",o)),o}}async get(t,r={}){var e;try{return await this.routing.get(t,r)}catch(n){throw null==(e=r.onProgress)||e.call(r,new C("ipns:routing:helia:error",n)),n}}}function G(t){return new R("/dht/record/"+d(t,"base32"),!1)}const H="/ipns/";function J(t,r){return t.code===r}const Y=i("helia:ipns"),Z=36e5,tt=48*Z,rt=23*Z,et=5000000n*BigInt(6e4),nt={[A.prefix]:A,[L.prefix]:L};class ot{constructor(r,e=[]){var n,s,i,c,l;n=this,(s=t).has(n)?o("Cannot add the same private member more than once"):s instanceof WeakSet?s.add(n):s.set(n,i),a(this,"routers"),a(this,"localStore"),a(this,"timeout"),a(this,"dns"),a(this,"log"),this.routers=[(c=r.routing,new Q(c)),...e],this.localStore=(l=r.datastore,{async put(t,r,e={}){var n,o;try{const o=G(t);try{const t=await l.get(o),e=b.deserialize(t);if($(e.value,r))return}catch(a){if("NotFoundError"!==a.name)throw a}const s=new b(t,r,new Date);null==(n=e.onProgress)||n.call(e,new C("ipns:routing:datastore:put")),await l.put(o,s.serialize(),e)}catch(a){throw null==(o=e.onProgress)||o.call(e,new C("ipns:routing:datastore:error",a)),a}},async get(t,r={}){var e,n;try{const n=G(t);null==(e=r.onProgress)||e.call(r,new C("ipns:routing:datastore:get"));const o=await l.get(n,r),a=b.deserialize(o);return{record:a.value,created:a.timeReceived}}catch(o){throw null==(n=r.onProgress)||n.call(r,new C("ipns:routing:datastore:error",o)),o}},async has(t,r={}){const e=G(t);return l.has(e,r)},async delete(t,r){const e=G(t);return l.delete(e,r)}}),this.dns=r.dns,this.log=r.logger.forComponent("helia:ipns")}async publish(t,r,e={}){var n;try{let n=1n;const o=E(t.publicKey.toMultihash());if(await this.localStore.has(o,e)){const{record:t}=await this.localStore.get(o,e);n=N(t).sequence+1n}const a=null!=e.ttl?1000000n*BigInt(e.ttl):et,s=await async function(t,r,e,n,o=V){const a=new p(Date.now()+Number(n)),s=f.ValidityType.EOL,i=BigInt(o.ttlNs??U);return F(t,r,e,s,a.toString(),i,o)}(t,r,n,e.lifetime??tt,{...e,ttlNs:a}),i=k(s);return await this.localStore.put(o,i,e),!0!==e.offline&&await Promise.all(this.routers.map(async t=>{await t.put(o,i,e)})),s}catch(o){throw null==(n=e.onProgress)||n.call(e,new C("ipns:publish:error",o)),o}}async resolve(n,o={}){const a=function(t){return null!=t&&("RSA"===t.type||"Ed25519"===t.type||"secp256k1"===t.type||"ECDSA"===t.type)&&t.raw instanceof Uint8Array&&"function"==typeof t.equals&&"function"==typeof t.toMultihash&&"function"==typeof t.toCID&&"function"==typeof t.verify}(n)?n.toMultihash():n,i=E(a),c=await s(this,t,e).call(this,i,o);return{...await s(this,t,r).call(this,c.value,o),record:c}}async resolveDNSLink(e,n={}){const o=await async function(t,r,e,n={}){return X(t,n.maxRecursiveDepth??32,r,e,n)}(e,this.dns,this.log,n);return{...await s(this,t,r).call(this,o.value,n),answer:o.answer}}republish(t={}){var r;if(null!=this.timeout)throw new Error("Republish is already running");async function e(){var r;const n=Date.now();null==(r=t.onProgress)||r.call(t,new C("ipns:republish:start"));const o=Date.now();let a=rt-(o-n);a<0&&(a=t.interval??rt),setTimeout(()=>{e().catch(t=>{Y.error("error republishing",t)})},a)}null==(r=t.signal)||r.addEventListener("abort",()=>{clearTimeout(this.timeout)}),this.timeout=setTimeout(()=>{e().catch(t=>{Y.error("error republishing",t)})},t.interval??rt)}async republishRecord(t,r,e={}){var n,o;let a;try{if(a=null==(n=D(r))?void 0:n.toMultihash(),null==a)if("string"==typeof t){t.startsWith(H)&&(t=t.slice(6));try{a=l(t).toMultihash()}catch(s){throw new Error(`Invalid string key: ${s.message}`)}}else a=t;if(null==a)throw new Error("No public key multihash found to determine the routing key");const o=E(a),i=k(r);await S(o,i),await this.localStore.put(o,i,e),!0!==e.offline&&await Promise.all(this.routers.map(async t=>{await t.put(o,i,e)}))}catch(s){throw null==(o=e.onProgress)||o.call(e,new C("ipns:republish:error",{key:a,record:r,err:s})),s}}}function at(t,{routers:r=[]}={}){return new ot(t,r)}t=new WeakSet,r=async function(t,r={}){const e=t.split("/");try{const t=e[1];if("ipns"===t){const t=e[2],n=t.substring(0,1);let o,a;if("1"===n||"Q"===n)o=L.decode(`z${t}`);else{if(null==nt[n])throw new O(`Unsupported multibase prefix "${n}"`);o=nt[n].decode(t)}try{a=M(o)}catch{a=P.decode(o).multihash}if(!J(a,0)&&!J(a,18))throw new _(`Unsupported multihash codec "${a.code}"`);const{cid:s}=await this.resolve(a,r);return{cid:s,path:e.slice(3).join("/")}}if("ipfs"===t){const t=P.parse(e[2]);return{cid:t,path:e.slice(3).join("/")}}}catch(n){Y.error("error parsing ipfs path",n)}throw Y.error("invalid ipfs path %s",t),new z("Invalid value")},e=async function(t,r={}){const e=[];if(await this.localStore.has(t,r))if(Y("record is present in the cache"),!0!==r.nocache)try{const{record:n,created:o}=await this.localStore.get(t,r);this.log("record retrieved from cache"),await S(t,n),this.log("record was valid");const a=N(n),s=Number((a.ttl??et)/1000000n);if(o.getTime()+s>Date.now())return this.log("record TTL was valid"),a;if(!0===r.offline)return this.log("record TTL has been reached but we are resolving offline-only, returning record"),a;this.log("record TTL has been reached, searching routing for updates"),e.push(n)}catch(a){this.log("cached record was invalid",a),await this.localStore.delete(t,r)}else Y("ignoring local cache due to nocache=true option");if(!0===r.offline)throw new h("Record was not present in the cache or has expired");Y("did not have record locally");let n=0;if(await Promise.all(this.routers.map(async o=>{let s;try{s=await o.get(t,{...r,validate:!1})}catch(a){return void Y.error("error finding IPNS record",a)}try{await S(t,s),e.push(s)}catch(a){n++,Y.error("error finding IPNS record",a)}})),0===e.length){if(n>0)throw new K(`${n>1?`${n} records`:"Record"} found for routing key ${n>1?"were":"was"} invalid`);throw new h("Could not find record for routing key")}const o=e[T(t,e)];return await this.localStore.put(t,o,r),N(o)};export{at as ipns,T as ipnsSelector,S as ipnsValidator};
