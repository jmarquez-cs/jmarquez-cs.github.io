var e,t,r=Object.defineProperty,i=(e,t,i)=>((e,t,i)=>t in e?r(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i)(e,"symbol"!=typeof t?t+"":t,i);import{p as o,a as s}from"./index.BofkdKOa.js";import{t as a,T as n,s as l,R as p,m as h}from"./index.8G8SSLdM.js";import{D as u,a as c,b as d,c as m,S as v,R as y,d as g,M as S,e as w,p as f,H as b,K as T,f as E,g as x,h as O,i as P,C as R}from"./index.D4_5qI86.js";import{j as A}from"./index.D4_5qI86.js";import{d as I}from"./message.Ve-2rN-7.js";import"./scalable-cuckoo-filter.BKNYiDuL.js";import"./index.BGGl-gag.js";class D extends Error{constructor(e,t,r){super(e??"The operation was aborted"),i(this,"type"),i(this,"code"),this.type="aborted",this.name=r??"AbortError",this.code=t??"ABORT_ERR"}}function M(e,t){const r=new D(null==t?void 0:t.errorMessage,null==t?void 0:t.errorCode,null==t?void 0:t.errorName),i=new AbortController,o=()=>{i.abort(r)};let s=AbortSignal.timeout(e);s.addEventListener("abort",o);const a=i.signal;return a.reset=t=>{null==s||s.removeEventListener("abort",o),s=AbortSignal.timeout(t??e),s.addEventListener("abort",()=>{i.abort(r)})},a.clear=()=>{null==s||s.removeEventListener("abort",o),s=void 0},a}class C{constructor(e,t={}){i(this,"reservations"),i(this,"maxReservations"),i(this,"applyDefaultLimit"),i(this,"reservationTtl"),i(this,"defaultDurationLimit"),i(this,"defaultDataLimit"),i(this,"log"),this.log=e.logger.forComponent("libp2p:circuit-relay:server:reservation-store"),this.maxReservations=t.maxReservations??u,this.applyDefaultLimit=!1!==t.applyDefaultLimit,this.reservationTtl=t.reservationTtl??c,this.defaultDurationLimit=t.defaultDurationLimit??d,this.defaultDataLimit=t.defaultDataLimit??m,this.reservations=a({metrics:e.metrics,name:"libp2p_circuit_relay_server_reservations_total"})}reserve(e,t,r){let i=this.reservations.get(e);if(this.reservations.size>=this.maxReservations&&null==i)return{status:v.RESERVATION_REFUSED};const o=new Date(Date.now()+this.reservationTtl);let s;return this.applyDefaultLimit&&(s=r??{data:this.defaultDataLimit,duration:this.defaultDurationLimit}),null!=i?(this.log("refreshing reservation for client %p",e),i.signal.reset(this.reservationTtl)):(this.log("creating new reservation for client %p",e),i={addr:t,expiry:o,limit:s,signal:M(this.reservationTtl)}),this.reservations.set(e,i),i.signal.addEventListener("abort",()=>{this.reservations.delete(e)}),{status:v.OK,expire:Math.round(o.getTime()/1e3)}}removeReservation(e){this.reservations.delete(e)}get(e){return this.reservations.get(e)}clear(){this.reservations.clear()}}class N{constructor({relay:e,peer:t,expiration:r}){i(this,"domain","libp2p-relay-rsvp"),i(this,"codec",new Uint8Array([3,2])),i(this,"relay"),i(this,"peer"),i(this,"expiration"),this.relay=e,this.peer=t,this.expiration=r}marshal(){return y.encode({relay:this.relay.toMultihash().bytes,peer:this.peer.toMultihash().bytes,expiration:BigInt(this.expiration)})}equals(e){return e instanceof N&&(!!this.peer.equals(e.peer)&&(!!this.relay.equals(e.relay)&&this.expiration===e.expiration))}}const L=e=>e.protoCodes().includes(R),q={maxOutboundStopStreams:S};class _ extends(t=n,e=Symbol.toStringTag,t){constructor(t,r={}){super(),i(this,"registrar"),i(this,"peerStore"),i(this,"addressManager"),i(this,"peerId"),i(this,"privateKey"),i(this,"connectionManager"),i(this,"connectionGater"),i(this,"reservationStore"),i(this,"started"),i(this,"hopTimeout"),i(this,"shutdownController"),i(this,"maxInboundHopStreams"),i(this,"maxOutboundHopStreams"),i(this,"maxOutboundStopStreams"),i(this,"log"),i(this,e,"@libp2p/circuit-relay-v2-server"),this.log=t.logger.forComponent("libp2p:circuit-relay:server"),this.registrar=t.registrar,this.peerStore=t.peerStore,this.addressManager=t.addressManager,this.peerId=t.peerId,this.privateKey=t.privateKey,this.connectionManager=t.connectionManager,this.connectionGater=t.connectionGater,this.started=!1,this.hopTimeout=(null==r?void 0:r.hopTimeout)??g,this.maxInboundHopStreams=r.maxInboundHopStreams,this.maxOutboundHopStreams=r.maxOutboundHopStreams,this.maxOutboundStopStreams=r.maxOutboundStopStreams??q.maxOutboundStopStreams,this.reservationStore=new C(t,r.reservations),this.shutdownController=new AbortController,l(1/0,this.shutdownController.signal)}isStarted(){return this.started}async start(){this.started||(await this.registrar.handle(w,e=>{this.onHop(e).catch(e=>{this.log.error(e)})},{maxInboundStreams:this.maxInboundHopStreams,maxOutboundStreams:this.maxOutboundHopStreams,runOnLimitedConnection:!0}),this.started=!0)}async stop(){this.reservationStore.clear(),this.shutdownController.abort(),await this.registrar.unhandle(w),this.started=!1}async onHop({connection:e,stream:t}){this.log("received circuit v2 hop protocol stream from %p",e.remotePeer);const r={signal:AbortSignal.timeout(this.hopTimeout)},i=f(t);try{const t=await i.pb(b).read(r);if(null==(null==t?void 0:t.type))throw new Error("request was invalid, could not read from stream");this.log("received",t.type),await this.handleHopProtocol({connection:e,stream:i,request:t},r)}catch(o){this.log.error("error while handling hop",o),await i.pb(b).write({type:b.Type.STATUS,status:v.MALFORMED_MESSAGE},r),t.abort(o)}}async handleHopProtocol({stream:e,request:t,connection:r},i){switch(this.log("received hop message"),t.type){case b.Type.RESERVE:await this.handleReserve({stream:e,request:t,connection:r},i);break;case b.Type.CONNECT:await this.handleConnect({stream:e,request:t,connection:r},i);break;default:this.log.error("invalid hop request type %s via peer %p",t.type,r.remotePeer),await e.pb(b).write({type:b.Type.STATUS,status:v.UNEXPECTED_MESSAGE})}}async handleReserve({stream:e,connection:t},r){var i,o,s;const a=e.pb(b);if(this.log("hop reserve request from %p",t.remotePeer),L(t.remoteAddr))return this.log.error("relay reservation over circuit connection denied for peer: %p",t.remotePeer),void(await a.write({type:b.Type.STATUS,status:v.PERMISSION_DENIED},r));if(!0===await(null==(o=(i=this.connectionGater).denyInboundRelayReservation)?void 0:o.call(i,t.remotePeer)))return this.log.error("reservation for %p denied by connection gater",t.remotePeer),void(await a.write({type:b.Type.STATUS,status:v.PERMISSION_DENIED},r));const n=this.reservationStore.reserve(t.remotePeer,t.remoteAddr);try{if(n.status!==v.OK)return void(await a.write({type:b.Type.STATUS,status:n.status},r));if(null!=n.expire){const e=1e3*n.expire-Date.now();await this.peerStore.merge(t.remotePeer,{tags:{[E]:{value:1,ttl:e},[T]:{value:1,ttl:e}}})}await a.write({type:b.Type.STATUS,status:v.OK,reservation:await this.makeReservation(t.remotePeer,BigInt(n.expire??0)),limit:null==(s=this.reservationStore.get(t.remotePeer))?void 0:s.limit},r),this.log("sent confirmation response to %s",t.remotePeer)}catch(l){this.log.error("failed to send confirmation response to %p - %e",t.remotePeer,l),this.reservationStore.removeReservation(t.remotePeer);try{await this.peerStore.merge(t.remotePeer,{tags:{[E]:void 0,[T]:void 0}})}catch(p){this.log.error("failed to untag relay source peer %p - %e",t.remotePeer,p)}}}async makeReservation(e,t){const r=[];for(const o of this.addressManager.getAddresses())o.toString().includes("/p2p-circuit")||r.push(o.bytes);const i=await p.seal(new N({peer:e,relay:this.peerId,expiration:t}),this.privateKey);return{addrs:r,expire:t,voucher:{publicKey:o(i.publicKey),payloadType:i.payloadType,payload:{peer:e.toMultihash().bytes,relay:this.peerId.toMultihash().bytes,expiration:t},signature:i.signature}}}async handleConnect({stream:e,request:t,connection:r},i){var o,a;const n=e.pb(b);if(L(r.remoteAddr))return this.log.error("relay reservation over circuit connection denied for peer: %p",r.remotePeer),void(await n.write({type:b.Type.STATUS,status:v.PERMISSION_DENIED},i));let l;this.log("hop connect request from %p",r.remotePeer);try{if(null==t.peer)throw this.log.error("no peer info in hop connect request"),new Error("no peer info in request");t.peer.addrs.forEach(h),l=s(I(t.peer.id))}catch(y){return this.log.error("invalid hop connect request via peer %p %s",r.remotePeer,y),void(await n.write({type:b.Type.STATUS,status:v.MALFORMED_MESSAGE},i))}const p=this.reservationStore.get(l);if(null==p)return this.log.error("hop connect denied for destination peer %p not having a reservation for %p with status %s",l,r.remotePeer,v.NO_RESERVATION),void(await n.write({type:b.Type.STATUS,status:v.NO_RESERVATION},i));if(!0===await(null==(a=(o=this.connectionGater).denyOutboundRelayedConnection)?void 0:a.call(o,r.remotePeer,l)))return this.log.error("hop connect for %p to %p denied by connection gater",r.remotePeer,l),void(await n.write({type:b.Type.STATUS,status:v.PERMISSION_DENIED},i));const u=this.connectionManager.getConnections(l);if(0===u.length)return this.log("hop connect denied for destination peer %p not having a connection for %p as there is no destination connection",l,r.remotePeer),void(await n.write({type:b.Type.STATUS,status:v.NO_RESERVATION},i));const c=u[0],d=await this.stopHop({connection:c,request:{type:x.Type.CONNECT,peer:{id:r.remotePeer.toMultihash().bytes,addrs:[]},limit:null==p?void 0:p.limit}},i);if(null==d)return this.log.error("failed to open stream to destination peer %p",null==c?void 0:c.remotePeer),void(await n.write({type:b.Type.STATUS,status:v.CONNECTION_FAILED},i));await n.write({type:b.Type.STATUS,status:v.OK,limit:null==p?void 0:p.limit},i);const m=e.unwrap();this.log("connection from %p to %p established - merging streams",r.remotePeer,l),O(m,d,this.shutdownController.signal,p,{log:this.log})}async stopHop({connection:e,request:t},r){this.log("starting circuit relay v2 stop request to %s",e.remotePeer);const i=await e.newStream([P],{maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0,...r}),o=f(i),s=o.pb(x);let a;await s.write(t,r);try{a=await s.read(r)}catch(n){this.log.error("error parsing stop message response from %p",e.remotePeer)}return null==a?(this.log.error("could not read response from %p",e.remotePeer),void(await i.close(r))):a.status===v.OK?(this.log("stop request to %p was successful",e.remotePeer),o.unwrap()):(this.log("stop request failed with code %d",a.status),void(await i.close(r)))}get reservations(){return this.reservationStore.reservations}}function U(e={}){return t=>new _(t,e)}export{w as RELAY_V2_HOP_CODEC,P as RELAY_V2_STOP_CODEC,U as circuitRelayServer,A as circuitRelayTransport};
