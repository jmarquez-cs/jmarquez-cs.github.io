var e,t,r,i,n,s,o,a,l=Object.defineProperty,d=e=>{throw TypeError(e)},c=(e,t,r)=>((e,t,r)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r),u=(e,t,r)=>(((e,t,r)=>{t.has(e)||d("Cannot "+r)})(e,t,"access private method"),r);import{l as h,K as p,M as g,f as y,a as v,b as m,P as f,c as w,C as E,T as b,s as S,d as T,m as D,e as R,g as C,h as M,i as A,j as I,k as N,n as P}from"./index.8G8SSLdM.js";import{t as O,L as k,D as x,b as L,f as _,a as U}from"./index.BofkdKOa.js";import{a as q,c as F}from"./scalable-cuckoo-filter.BKNYiDuL.js";import{p as V}from"./index.BGGl-gag.js";import{g as $,m as G,h as K,i as Q,k as j,a as X,d as z}from"./message.Ve-2rN-7.js";function W(e){return null!=(null==e?void 0:e.then)}function B(e,t){let r=0;if(null!=e[Symbol.asyncIterator])return async function*(){for await(const i of e){const e=t(i,r++);W(e)&&await e,yield i}}();const i=q(e),{value:n,done:s}=i.next();if(!0===s)return function*(){}();const o=t(n,r++);if("function"==typeof(null==o?void 0:o.then))return async function*(){yield n;for(const e of i){const i=t(e,r++);W(i)&&await i,yield e}}();const a=t;return function*(){yield n;for(const e of i)a(e,r++),yield e}()}class H{constructor(e,t){c(this,"filter"),this.filter=F(e,t)}has(e){return this.filter.has(e.toMultihash().bytes)}add(e){this.filter.add(e.toMultihash().bytes)}remove(e){var t,r;null==(r=(t=this.filter).remove)||r.call(t,e.toMultihash().bytes)}}function J(e,t=.001){return new H(e,t)}function Y(e,t){const r=h(e,t),i={read:async(e,t)=>{const i=await r.read(t);return e.decode(i)},write:async(e,t,i)=>{await r.write(t.encode(e),i)},writeV:async(e,t,i)=>{await r.writeV(e.map(e=>t.encode(e)),i)},pb:e=>({read:async t=>i.read(e,t),write:async(t,r)=>i.write(t,e,r),writeV:async(t,r)=>i.writeV(t,e,r),unwrap:()=>i}),unwrap:()=>r.unwrap()};return i}const Z=290,ee=15,te=72e5,re="circuit-relay-source",ie=`${p}-circuit-relay`,ne=`${p}-circuit-relay-source`,se=12e4,oe=BigInt(1<<17),ae="/libp2p/circuit/relay/0.2.0/hop",le="/libp2p/circuit/relay/0.2.0/stop",de=3e4,ce=300;var ue,he,pe,ge,ye,ve,me,fe,we,Ee,be;!function(e){var t;let r;var i;let n;(t=e.Type||(e.Type={})).RESERVE="RESERVE",t.CONNECT="CONNECT",t.STATUS="STATUS",(i=r||(r={}))[i.RESERVE=0]="RESERVE",i[i.CONNECT=1]="CONNECT",i[i.STATUS=2]="STATUS",function(e){e.codec=()=>$(r)}(e.Type||(e.Type={})),e.codec=()=>(null==n&&(n=G((t,r,i={})=>{!1!==i.lengthDelimited&&r.fork(),null!=t.type&&(r.uint32(8),e.Type.codec().encode(t.type,r)),null!=t.peer&&(r.uint32(18),pe.codec().encode(t.peer,r)),null!=t.reservation&&(r.uint32(26),ge.codec().encode(t.reservation,r)),null!=t.limit&&(r.uint32(34),ye.codec().encode(t.limit,r)),null!=t.status&&(r.uint32(40),ve.codec().encode(t.status,r)),!1!==i.lengthDelimited&&r.ldelim()},(t,r,i={})=>{var n,s,o;const a={},l=null==r?t.len:t.pos+r;for(;t.pos<l;){const r=t.uint32();switch(r>>>3){case 1:a.type=e.Type.codec().decode(t);break;case 2:a.peer=pe.codec().decode(t,t.uint32(),{limits:null==(n=i.limits)?void 0:n.peer});break;case 3:a.reservation=ge.codec().decode(t,t.uint32(),{limits:null==(s=i.limits)?void 0:s.reservation});break;case 4:a.limit=ye.codec().decode(t,t.uint32(),{limits:null==(o=i.limits)?void 0:o.limit});break;case 5:a.status=ve.codec().decode(t);break;default:t.skipType(7&r)}}return a})),n),e.encode=t=>K(t,e.codec()),e.decode=(t,r)=>Q(t,e.codec(),r)}(ue||(ue={})),function(e){var t;let r;var i;let n;(t=e.Type||(e.Type={})).CONNECT="CONNECT",t.STATUS="STATUS",(i=r||(r={}))[i.CONNECT=0]="CONNECT",i[i.STATUS=1]="STATUS",function(e){e.codec=()=>$(r)}(e.Type||(e.Type={})),e.codec=()=>(null==n&&(n=G((t,r,i={})=>{!1!==i.lengthDelimited&&r.fork(),null!=t.type&&(r.uint32(8),e.Type.codec().encode(t.type,r)),null!=t.peer&&(r.uint32(18),pe.codec().encode(t.peer,r)),null!=t.limit&&(r.uint32(26),ye.codec().encode(t.limit,r)),null!=t.status&&(r.uint32(32),ve.codec().encode(t.status,r)),!1!==i.lengthDelimited&&r.ldelim()},(t,r,i={})=>{var n,s;const o={},a=null==r?t.len:t.pos+r;for(;t.pos<a;){const r=t.uint32();switch(r>>>3){case 1:o.type=e.Type.codec().decode(t);break;case 2:o.peer=pe.codec().decode(t,t.uint32(),{limits:null==(n=i.limits)?void 0:n.peer});break;case 3:o.limit=ye.codec().decode(t,t.uint32(),{limits:null==(s=i.limits)?void 0:s.limit});break;case 4:o.status=ve.codec().decode(t);break;default:t.skipType(7&r)}}return o})),n),e.encode=t=>K(t,e.codec()),e.decode=(t,r)=>Q(t,e.codec(),r)}(he||(he={})),function(e){let t;e.codec=()=>(null==t&&(t=G((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.id&&e.id.byteLength>0&&(t.uint32(10),t.bytes(e.id)),null!=e.addrs)for(const i of e.addrs)t.uint32(18),t.bytes(i);!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{var i;const n={id:j(0),addrs:[]},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.id=e.bytes();break;case 2:if(null!=(null==(i=r.limits)?void 0:i.addrs)&&n.addrs.length===r.limits.addrs)throw new g('Decode error - map field "addrs" had too many elements');n.addrs.push(e.bytes());break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>K(t,e.codec()),e.decode=(t,r)=>Q(t,e.codec(),r)}(pe||(pe={})),function(e){let t;e.codec=()=>(null==t&&(t=G((e,t,r={})=>{if(!1!==r.lengthDelimited&&t.fork(),null!=e.expire&&0n!==e.expire&&(t.uint32(8),t.uint64(e.expire)),null!=e.addrs)for(const i of e.addrs)t.uint32(18),t.bytes(i);null!=e.voucher&&(t.uint32(26),be.codec().encode(e.voucher,t)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{var i,n;const s={expire:0n,addrs:[]},o=null==t?e.len:e.pos+t;for(;e.pos<o;){const t=e.uint32();switch(t>>>3){case 1:s.expire=e.uint64();break;case 2:if(null!=(null==(i=r.limits)?void 0:i.addrs)&&s.addrs.length===r.limits.addrs)throw new g('Decode error - map field "addrs" had too many elements');s.addrs.push(e.bytes());break;case 3:s.voucher=be.codec().decode(e,e.uint32(),{limits:null==(n=r.limits)?void 0:n.voucher});break;default:e.skipType(7&t)}}return s})),t),e.encode=t=>K(t,e.codec()),e.decode=(t,r)=>Q(t,e.codec(),r)}(ge||(ge={})),function(e){let t;e.codec=()=>(null==t&&(t=G((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.duration&&(t.uint32(8),t.uint32(e.duration)),null!=e.data&&(t.uint32(16),t.uint64(e.data)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const i={},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:i.duration=e.uint32();break;case 2:i.data=e.uint64();break;default:e.skipType(7&t)}}return i})),t),e.encode=t=>K(t,e.codec()),e.decode=(t,r)=>Q(t,e.codec(),r)}(ye||(ye={})),(me=ve||(ve={})).UNUSED="UNUSED",me.OK="OK",me.RESERVATION_REFUSED="RESERVATION_REFUSED",me.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",me.PERMISSION_DENIED="PERMISSION_DENIED",me.CONNECTION_FAILED="CONNECTION_FAILED",me.NO_RESERVATION="NO_RESERVATION",me.MALFORMED_MESSAGE="MALFORMED_MESSAGE",me.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE",(we=fe||(fe={}))[we.UNUSED=0]="UNUSED",we[we.OK=100]="OK",we[we.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",we[we.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",we[we.PERMISSION_DENIED=202]="PERMISSION_DENIED",we[we.CONNECTION_FAILED=203]="CONNECTION_FAILED",we[we.NO_RESERVATION=204]="NO_RESERVATION",we[we.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",we[we.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE",(ve||(ve={})).codec=()=>$(fe),function(e){let t;e.codec=()=>(null==t&&(t=G((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.relay&&e.relay.byteLength>0&&(t.uint32(10),t.bytes(e.relay)),null!=e.peer&&e.peer.byteLength>0&&(t.uint32(18),t.bytes(e.peer)),null!=e.expiration&&0n!==e.expiration&&(t.uint32(24),t.uint64(e.expiration)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{const i={relay:j(0),peer:j(0),expiration:0n},n=null==t?e.len:e.pos+t;for(;e.pos<n;){const t=e.uint32();switch(t>>>3){case 1:i.relay=e.bytes();break;case 2:i.peer=e.bytes();break;case 3:i.expiration=e.uint64();break;default:e.skipType(7&t)}}return i})),t),e.encode=t=>K(t,e.codec()),e.decode=(t,r)=>Q(t,e.codec(),r)}(Ee||(Ee={})),function(e){let t;e.codec=()=>(null==t&&(t=G((e,t,r={})=>{!1!==r.lengthDelimited&&t.fork(),null!=e.publicKey&&e.publicKey.byteLength>0&&(t.uint32(10),t.bytes(e.publicKey)),null!=e.payloadType&&e.payloadType.byteLength>0&&(t.uint32(18),t.bytes(e.payloadType)),null!=e.payload&&(t.uint32(26),Ee.codec().encode(e.payload,t)),null!=e.signature&&e.signature.byteLength>0&&(t.uint32(42),t.bytes(e.signature)),!1!==r.lengthDelimited&&t.ldelim()},(e,t,r={})=>{var i;const n={publicKey:j(0),payloadType:j(0),signature:j(0)},s=null==t?e.len:e.pos+t;for(;e.pos<s;){const t=e.uint32();switch(t>>>3){case 1:n.publicKey=e.bytes();break;case 2:n.payloadType=e.bytes();break;case 3:n.payload=Ee.codec().decode(e,e.uint32(),{limits:null==(i=r.limits)?void 0:i.payload});break;case 5:n.signature=e.bytes();break;default:e.skipType(7&t)}}return n})),t),e.encode=t=>K(t,e.codec()),e.decode=(t,r)=>Q(t,e.codec(),r)}(be||(be={}));class Se extends Error{constructor(e="Transfer limit error"){super(e),this.name="TransferLimitError"}}class Te extends Error{constructor(e="Duration limit error"){super(e),this.name="DurationLimitError"}}class De extends Error{constructor(){super(...arguments),c(this,"name","HadEnoughRelaysError")}}c(De,"name","HadEnoughRelaysError");class Re extends Error{constructor(){super(...arguments),c(this,"name","DoubleRelayError")}}c(Re,"name","DoubleRelayError");class Ce extends Error{constructor(){super(...arguments),c(this,"name","RelayQueueFullError")}}async function*Me(e,t,r){const i=t.remaining;for await(const s of e){const e=BigInt(s.byteLength);if(t.remaining-e<0){const e=Number(t.remaining);t.remaining=0n;try{0!==e&&(yield s.subarray(0,e))}catch(n){r.log.error(n)}throw new Se(`data limit of ${i} bytes exceeded`)}t.remaining-=e,yield s}}function Ae(e,t,r,i,n){var s,o;function a(r){e.abort(r),t.abort(r)}const l=[r,i.signal];null!=(null==(s=i.limit)?void 0:s.duration)&&(n.log("limiting relayed connection duration to %dms",i.limit.duration),l.push(AbortSignal.timeout(i.limit.duration)));const d=v(l);let c,u=!1,h=!1;null!=(null==(o=i.limit)?void 0:o.data)&&(c={remaining:i.limit.data}),queueMicrotask(()=>{const r=()=>{var e;n.log("relayed connection reached time limit"),t.abort(new Te(`duration limit of ${null==(e=i.limit)?void 0:e.duration} ms exceeded`))};d.addEventListener("abort",r,{once:!0}),t.sink(null==c?e.source:Me(e.source,c,n)).catch(e=>{n.log.error("error while relaying streams src -> dst",e),a(e)}).finally(()=>{u=!0,h&&(d.removeEventListener("abort",r),d.clear())})}),queueMicrotask(()=>{const r=()=>{var t;n.log("relayed connection reached time limit"),e.abort(new Te(`duration limit of ${null==(t=i.limit)?void 0:t.duration} ms exceeded`))};d.addEventListener("abort",r,{once:!0}),e.sink(null==c?t.source:Me(t.source,c,n)).catch(e=>{n.log.error("error while relaying streams dst -> src",e),a(e)}).finally(()=>{h=!0,u&&(d.removeEventListener("abort",r),d.clear())})})}function Ie(e){const t=e*BigInt(1e3),r=(new Date).getTime();return Number(t-BigInt(r))}c(Ce,"name","RelayQueueFullError");class Ne{constructor(e){c(this,"expires"),c(this,"bytes"),null!=(null==e?void 0:e.duration)&&0!==(null==e?void 0:e.duration)&&(this.expires=Date.now()+1e3*e.duration),this.bytes=null==e?void 0:e.data,0n===this.bytes&&(this.bytes=void 0),this.onData=this.onData.bind(this)}onData(e){null!=this.bytes&&(this.bytes-=BigInt(e.byteLength),this.bytes<0n&&(this.bytes=0n))}getLimits(){if(null==this.expires&&null==this.bytes)return;const e={};if(null!=this.bytes){const t=this;Object.defineProperty(e,"bytes",{get:()=>t.bytes})}if(null!=this.expires){const t=this;Object.defineProperty(e,"seconds",{get:()=>Math.round(((t.expires??0)-Date.now())/1e3)})}return e}}const Pe=y(m(f.matchers[0],w(E))),Oe=y(w(E));function ke(e){const{stream:t,remoteAddr:r,logger:i,onDataRead:n,onDataWrite:s}=e,o=i.forComponent("libp2p:stream:converter");let a=!1,l=!1;const d=t.close.bind(t);t.close=async e=>{await d(e),p(!0)};const c=t.abort.bind(t);t.abort=e=>{c(e),p(!0)};const u=t.sink.bind(t);t.sink=async e=>{try{await u(V(e,e=>B(e,e=>null==s?void 0:s(e))))}catch(t){"aborted"!==t.type&&o.error("%s error in sink",r,t)}finally{l=!0,p()}};const h={log:o,sink:t.sink,source:async function*(){try{for await(const e of t.source)null==n||n(e),yield e}finally{a=!0,p()}}(),remoteAddr:r,timeline:{open:Date.now(),close:void 0},close:t.close,abort:t.abort};function p(e){!0===e&&(a=!0,l=!0),a&&l&&null==h.timeline.close&&(h.timeline.close=Date.now())}return h}class xe extends b{constructor(e,t={}){super(),c(this,"components"),c(this,"started"),c(this,"running"),c(this,"topologyId"),c(this,"log"),c(this,"discoveryController"),c(this,"filter"),c(this,"queue"),this.log=e.logger.forComponent("libp2p:circuit-relay:discover-relays"),this.components=e,this.started=!1,this.running=!1,this.filter=t.filter,this.discoveryController=new AbortController,S(1/0,this.discoveryController.signal),this.dialPeer=this.dialPeer.bind(this),this.onPeer=this.onPeer.bind(this)}isStarted(){return this.started}async start(){this.topologyId=await this.components.registrar.register(ae,{filter:this.filter,onConnect:e=>{var t,r;this.log.trace("discovered relay %p queue (length: %d, active %d)",e,null==(t=this.queue)?void 0:t.size,null==(r=this.queue)?void 0:r.running),this.safeDispatchEvent("relay:discover",{detail:e})}}),this.started=!0}stop(){null!=this.topologyId&&this.components.registrar.unregister(this.topologyId),this.running&&this.stopDiscovery(),this.started=!1}startDiscovery(){this.running||(this.log("start discovery"),this.running=!0,this.discoveryController=new AbortController,S(1/0,this.discoveryController.signal),this.components.events.addEventListener("peer:discovery",this.onPeer),Promise.resolve().then(async()=>{var e;this.log("searching peer store for relays");const t=await this.components.peerStore.all({filters:[e=>e.protocols.includes(ae)],orders:[()=>Math.random()<.5?1:-1,(e,t)=>{const r=Le(e),i=Le(t);return r>i?-1:i>r?1:0}]});for(const i of t)this.log.trace("found relay peer %p in peer store",i.id),this.safeDispatchEvent("relay:discover",{detail:i.id});this.log("found %d relay peers in peer store",t.length);const r=this.queue=new T({concurrency:5});this.log("start random walk");for await(const i of this.components.randomWalk.walk({signal:this.discoveryController.signal}))this.log.trace("found random peer %p",i.id),r.has(i.id)?this.log.trace("random peer %p was already in queue",i.id):(null==(e=this.components.connectionManager.getConnections(i.id))?void 0:e.length)>0?this.log.trace("random peer %p was already connected",i.id):await this.components.connectionManager.isDialable(i.multiaddrs)?(r.queued>10&&(this.log.trace("wait for space in queue for %p",i.id),await r.onSizeLessThan(10,{signal:this.discoveryController.signal})),this.log("adding random peer %p to dial queue (length: %d, active %d)",i.id,r.size,r.running),r.add(this.dialPeer,{peerId:i.id,signal:this.discoveryController.signal}).catch(e=>{this.log.error("error opening connection to random peer %p",i.id,e)})):this.log.trace("random peer %p was not dialable",i.id,i.multiaddrs.map(e=>e.toString()));this.log("stop random walk"),await r.onIdle()}).catch(e=>{this.discoveryController.signal.aborted||this.log.error("failed when finding relays on the network",e)}))}stopDiscovery(){var e,t;this.log("stop discovery"),this.running=!1,null==(e=this.discoveryController)||e.abort(),null==(t=this.queue)||t.clear(),this.components.events.removeEventListener("peer:discovery",this.onPeer)}onPeer(e){this.log.trace("maybe dialing discovered peer %p - %e",e.detail.id),this.maybeDialPeer(e).catch(t=>{this.log.trace("error dialing discovered peer %p - %e",e.detail.id,t)})}async maybeDialPeer(e){var t,r;if(null==this.queue)return;const i=e.detail.id,n=e.detail.multiaddrs;this.queue.has(i)?this.log.trace("random peer %p was already in queue",i):(null==(t=this.components.connectionManager.getConnections(i))?void 0:t.length)>0?this.log.trace("random peer %p was already connected",i):await this.components.connectionManager.isDialable(n)?null==(r=this.queue)||r.add(this.dialPeer,{peerId:e.detail.id,signal:this.discoveryController.signal}).catch(t=>{this.log.error("error opening connection to discovered peer %p",e.detail.id,t)}):this.log.trace("random peer %p was not dialable",i)}async dialPeer({peerId:e,signal:t}){const r=v([AbortSignal.timeout(5e3),t]);try{await this.components.connectionManager.openConnection(e,{signal:r})}finally{r.clear()}}}function Le(e){const t=e.metadata.get("last-dial-success");return null==t?0:new Date(O(t)).getTime()}class _e extends b{constructor(e,t={}){super(),c(this,"connectionManager"),c(this,"addressManager"),c(this,"reservationStore"),c(this,"listeningAddrs"),c(this,"log"),c(this,"listenTimeout"),c(this,"reservationId"),c(this,"relay"),c(this,"_onRemoveRelayPeer",e=>{var t,r;this.log("relay removed %p our relay %p",e.detail.relay,this.relay,null==(t=this.relay)?void 0:t.equals(e.detail.relay)),!0===(null==(r=this.relay)?void 0:r.equals(e.detail.relay))&&(this.log("relay peer removed %p",e.detail.relay),this.listeningAddrs.forEach(e=>{this.addressManager.removeObservedAddr(e)}),this.listeningAddrs=[],this.safeDispatchEvent("listening"))}),c(this,"_onAddRelayPeer",e=>{const{details:t}=e.detail;"configured"!==t.type&&t.id===this.reservationId&&this.addedRelay(e.detail)}),this.log=e.logger.forComponent("libp2p:circuit-relay:transport:listener"),this.connectionManager=e.connectionManager,this.addressManager=e.addressManager,this.reservationStore=e.reservationStore,this.listeningAddrs=[],this.listenTimeout=t.listenTimeout??2e3,this.reservationStore.addEventListener("relay:removed",this._onRemoveRelayPeer),this.reservationStore.addEventListener("relay:created-reservation",this._onAddRelayPeer)}async listen(e){if(Oe.exactMatch(e))this.log("searching for circuit relay servers"),this.reservationId=this.reservationStore.reserveRelay();else{if(!Pe.exactMatch(e))throw new k(`Could not listen on p2p-circuit address "${e}"`);{this.log("listen on specific relay server %a",e);const t=AbortSignal.timeout(this.listenTimeout),r=e.decapsulate("/p2p-circuit"),i=await this.connectionManager.openConnection(r,{signal:t});if(!this.reservationStore.hasReservation(i.remotePeer)){this.log("making reservation on peer %p",i.remotePeer);const e=await this.reservationStore.addRelay(i.remotePeer,"configured");this.addedRelay(e)}}}}getAddrs(){return[...this.listeningAddrs.values()].flat()}updateAnnounceAddrs(){}async close(){this.reservationStore.cancelReservations(),this.listeningAddrs=[],this.reservationStore.removeEventListener("relay:removed",this._onRemoveRelayPeer),queueMicrotask(()=>{this.safeDispatchEvent("close")})}addedRelay(e){this.log("relay peer added %p",e.relay),this.relay=e.relay,this.listeningAddrs=e.details.reservation.addrs.map(e=>D(e).encapsulate("/p2p-circuit")),this.listeningAddrs.forEach(e=>{this.addressManager.confirmObservedAddr(e,{type:"transport"})}),queueMicrotask(()=>{this.safeDispatchEvent("listening")})}}class Ue extends b{constructor(t,i){var n,s,o;super(),n=this,(s=e).has(n)?d("Cannot add the same private member more than once"):s instanceof WeakSet?s.add(n):s.set(n,o),c(this,"peerId"),c(this,"connectionManager"),c(this,"peerStore"),c(this,"events"),c(this,"reserveQueue"),c(this,"reservations"),c(this,"pendingReservations"),c(this,"maxReservationQueueLength"),c(this,"reservationCompletionTimeout"),c(this,"started"),c(this,"log"),c(this,"relayFilter"),this.log=t.logger.forComponent("libp2p:circuit-relay:transport:reservation-store"),this.peerId=t.peerId,this.connectionManager=t.connectionManager,this.peerStore=t.peerStore,this.events=t.events,this.reservations=new R,this.pendingReservations=[],this.maxReservationQueueLength=(null==i?void 0:i.maxReservationQueueLength)??100,this.reservationCompletionTimeout=(null==i?void 0:i.reservationCompletionTimeout)??2e3,this.started=!1,this.relayFilter=F(100),this.reserveQueue=new T({concurrency:(null==i?void 0:i.reservationConcurrency)??1,metricName:"libp2p_relay_reservation_queue",metrics:t.metrics}),this.events.addEventListener("connection:close",t=>{null!=[...this.reservations.values()].find(e=>e.connection===t.detail.id)&&u(this,e,r).call(this,t.detail.remotePeer).catch(e=>{this.log("could not remove relay %p - %e",t.detail,e)})})}isStarted(){return this.started}start(){this.started=!0}afterStart(){Promise.resolve().then(async()=>{const t=await this.peerStore.all({filters:[e=>e.tags.has(ie)]});this.log("removing tag from %d old relays",t.length),await Promise.all(t.map(async e=>{await this.peerStore.merge(e.id,{tags:{[ie]:void 0}})})),this.log("redialing %d old relays",t.length),await Promise.all(t.map(async e=>this.addRelay(e.id,"discovered"))),u(this,e,i).call(this)}).catch(e=>{this.log.error(e)})}stop(){this.reserveQueue.clear(),this.reservations.forEach(({timeout:e})=>{clearTimeout(e)}),this.reservations.clear(),this.started=!1}reserveRelay(){const t=((e=21)=>{let t="",r=crypto.getRandomValues(new Uint8Array(e|=0));for(;e--;)t+="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"[63&r[e]];return t})();return this.pendingReservations.push(t),u(this,e,i).call(this),t}async addRelay(n,s){if(this.peerId.equals(n))throw this.log.trace("not trying to use self as relay"),new k("Cannot use self as relay");if(this.reserveQueue.size>this.maxReservationQueueLength)throw new Ce("The reservation queue is full");const o=this.reserveQueue.find(n);if(null!=o)return this.log.trace("potential relay peer %p is already in the reservation queue",n),o.join();if(this.relayFilter.has(n.toMultihash().bytes))throw new k("The relay was previously invalid");return this.log.trace("try to reserve relay slot with %p",n),this.reserveQueue.add(async()=>{const o=Date.now();try{const o=this.reservations.get(n);if(null!=o){const t=this.connectionManager.getConnections(n);let i=!1;if(0===t.length&&this.log("already have relay reservation with %p but we are no longer connected",n),t.map(e=>e.id).includes(o.connection)&&(this.log("already have relay reservation with %p and the original connection is still open",n),i=!0),i&&Ie(o.reservation.expire)>6e5)return this.log("already have relay reservation with %p but we are still connected and it does not expire soon",n),{relay:n,details:o};await u(this,e,r).call(this,n)}if("discovered"===s&&0===this.pendingReservations.length)throw new De("Not making reservation on discovered relay because we do not need any more relays");const a=AbortSignal.timeout(this.reservationCompletionTimeout);S(1/0,a);const l=await this.connectionManager.openConnection(n,{signal:a});if(C.matches(l.remoteAddr))throw new Re("not creating reservation over relayed connection");const d=await u(this,e,t).call(this,l,{signal:a}),c=Ie(d.expire);this.log("created reservation on relay peer %p, expiry date is %s",n,new Date(Date.now()+c).toString());const h=Math.min(Math.max(c-3e5,3e4),Math.pow(2,31)-1),p=setTimeout(()=>{this.log("refresh reservation to relay %p",n),this.addRelay(n,s).catch(async t=>{this.log.error("could not refresh reservation to relay %p - %e",n,t),await u(this,e,r).call(this,n)}).catch(e=>{this.log.error("could not remove expired reservation to relay %p - %e",n,e)})},h);let g;if("discovered"===s){const e=this.pendingReservations.pop();if(null==e)throw new De("Made reservation on relay but did not need any more discovered relays");g={timeout:p,reservation:d,type:s,connection:l.id,id:e}}else g={timeout:p,reservation:d,type:s,connection:l.id};this.reservations.set(n,g),await this.peerStore.merge(n,{tags:{[ie]:{value:1,ttl:c}}}),u(this,e,i).call(this);const y={relay:n,details:g};return this.safeDispatchEvent("relay:created-reservation",{detail:y}),y}catch(a){throw"discovered"===s&&"HadEnoughRelaysError"===a.name||this.log.error("could not reserve slot on %p after %dms - %e",n,Date.now()-o,a),"DialError"!==a.name&&"UnsupportedProtocolError"!==a.name||this.relayFilter.add(n.toMultihash().bytes),u(this,e,r).call(this,n).catch(e=>{this.log.error("could not remove reservation on %p after reserving slot failed - %e",n,e)}),a}},{peerId:n})}hasReservation(e){return this.reservations.has(e)}getReservation(e){var t;return null==(t=this.reservations.get(e))?void 0:t.reservation}reservationCount(e){return null==e?this.reservations.size:[...this.reservations.values()].reduce((t,r)=>(r.type===e&&t++,t),0)}cancelReservations(){[...this.reservations.values()].forEach(e=>{clearTimeout(e.timeout)}),this.reservations.clear()}}e=new WeakSet,t=async function(e,t){var r;null==(r=t.signal)||r.throwIfAborted(),this.log("requesting reservation from %p",e.remotePeer);const i=await e.newStream(ae,t),n=Y(i).pb(ue);let s;this.log.trace("send RESERVE to %p",e.remotePeer),await n.write({type:ue.Type.RESERVE},t);try{this.log.trace("reading response from %p",e.remotePeer),s=await n.read(t)}catch(a){throw i.abort(a),a}finally{"closed"!==i.status&&await i.close(t)}if(this.log.trace("read response %o",s),s.status===ve.OK&&null!=s.reservation){const t=new Set;t.add(e.remoteAddr.toString());for(const r of s.reservation.addrs){let i=D(r);null==i.getPeerId()&&(i=i.encapsulate(`/p2p/${e.remotePeer}`)),i=D(i.toString().replace(`/p2p/${e.remotePeer}/p2p/${e.remotePeer}`,`/p2p/${e.remotePeer}`)),t.add(i.toString())}return s.reservation.addrs=[...t].map(e=>D(e).bytes),s.reservation}const o=`reservation failed with status ${s.status??"undefined"}`;throw this.log.error(o),new Error(o)},r=async function(t){const r=this.reservations.get(t);null!=r&&(this.log("removing relay reservation with %p from local store",t),clearTimeout(r.timeout),this.reservations.delete(t),"discovered"===r.type&&this.pendingReservations.push(r.id),await this.peerStore.merge(t,{tags:{[ie]:void 0}}),this.safeDispatchEvent("relay:removed",{detail:{relay:t,details:r}}),u(this,e,i).call(this))},i=function(){if(0===this.pendingReservations.length)return this.log.trace("have discovered enough relays"),this.reserveQueue.clear(),void this.safeDispatchEvent("relay:found-enough-relays");this.relayFilter=F(100),this.log("not discovered enough relays %d/%d",this.reservations.size,this.pendingReservations.length),this.safeDispatchEvent("relay:not-enough-relays")};const qe=300,Fe=300;class Ve{constructor(e,t={}){c(this,"discovery"),c(this,"registrar"),c(this,"peerStore"),c(this,"connectionManager"),c(this,"transportManager"),c(this,"peerId"),c(this,"upgrader"),c(this,"addressManager"),c(this,"connectionGater"),c(this,"reservationStore"),c(this,"logger"),c(this,"maxInboundStopStreams"),c(this,"maxOutboundStopStreams"),c(this,"started"),c(this,"log"),c(this,"shutdownController"),c(this,a,"@libp2p/circuit-relay-v2-transport"),c(this,o,["@libp2p/transport","@libp2p/circuit-relay-v2-transport"]),c(this,n,!0),this.log=e.logger.forComponent("libp2p:circuit-relay:transport"),this.registrar=e.registrar,this.peerStore=e.peerStore,this.connectionManager=e.connectionManager,this.transportManager=e.transportManager,this.logger=e.logger,this.peerId=e.peerId,this.upgrader=e.upgrader,this.addressManager=e.addressManager,this.connectionGater=e.connectionGater,this.maxInboundStopStreams=t.maxInboundStopStreams??qe,this.maxOutboundStopStreams=t.maxOutboundStopStreams??Fe,this.shutdownController=new AbortController,this.discovery=new xe(e,{filter:t.discoveryFilter??J(4096,.001)}),this.discovery.addEventListener("relay:discover",e=>{this.reservationStore.addRelay(e.detail,"discovered").catch(t=>{"HadEnoughRelaysError"!==t.name&&"RelayQueueFullError"!==t.name&&this.log.error("could not add discovered relay %p",e.detail,t)})}),this.reservationStore=new Ue(e,t),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{var e;null==(e=this.discovery)||e.startDiscovery()}),this.reservationStore.addEventListener("relay:found-enough-relays",()=>{var e;null==(e=this.discovery)||e.stopDiscovery()}),this.started=!1}get[(a=Symbol.toStringTag,o=M,s=A,n=I,s)](){return null!=this.discovery?["@libp2p/identify"]:[]}isStarted(){return this.started}async start(){this.shutdownController=new AbortController,S(1/0,this.shutdownController.signal),await this.registrar.handle(le,e=>{const t=this.upgrader.createInboundAbortSignal(this.shutdownController.signal);this.onStop(e,t).catch(t=>{this.log.error("error while handling STOP protocol",t),e.stream.abort(t)}).finally(()=>{t.clear()})},{maxInboundStreams:this.maxInboundStopStreams,maxOutboundStreams:this.maxOutboundStopStreams,runOnLimitedConnection:!0}),await N(this.discovery,this.reservationStore),this.started=!0}async stop(){this.shutdownController.abort(),await P(this.discovery,this.reservationStore),await this.registrar.unhandle(le),this.started=!1}async dial(e,t){var r,i,n,s,o,a;if(1!==e.protoCodes().filter(e=>290===e).length){const t="Invalid circuit relay address";throw this.log.error(t,e),new x(t)}const l=e.toString().split("/p2p-circuit"),d=D(l[0]),c=D(l[l.length-1]),u=d.getPeerId(),h=c.getPeerId();if(null==u||null==h){const t=`ircuit relay dial to ${e.toString()} failed as address did not have both relay and destination PeerIDs`;throw this.log.error(`c${t}`),new x(`C${t}`)}const p=L(u),g=L(h);let y,v=this.connectionManager.getConnections(p)[0];null==v?(await this.peerStore.merge(p,{multiaddrs:[d]}),null==(r=t.onProgress)||r.call(t,new X("circuit-relay:open-connection")),v=await this.connectionManager.openConnection(p,t)):null==(i=t.onProgress)||i.call(t,new X("circuit-relay:reuse-connection"));try{null==(n=t.onProgress)||n.call(t,new X("circuit-relay:open-hop-stream")),y=await v.newStream(ae,t);const r=Y(y),i=r.pb(ue);null==(s=t.onProgress)||s.call(t,new X("circuit-relay:write-connect-message")),await i.write({type:ue.Type.CONNECT,peer:{id:g.toMultihash().bytes,addrs:[D(c).bytes]}},t),null==(o=t.onProgress)||o.call(t,new X("circuit-relay:read-connect-response"));const l=await i.read(t);if(l.status!==ve.OK)throw new _(`failed to connect via relay with status ${(null==(a=null==l?void 0:l.status)?void 0:a.toString())??"undefined"}`);const u=new Ne(l.limit),h=ke({stream:r.unwrap(),remoteAddr:e,localAddr:d.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),logger:this.logger,onDataRead:u.onData,onDataWrite:u.onData});return this.log("new outbound relayed connection %a",h.remoteAddr),await this.upgrader.upgradeOutbound(h,{...t,limits:u.getLimits()})}catch(m){throw this.log.error("circuit relay dial to destination %p via relay %p failed",g,p,m),null==y||y.abort(m),m}}createListener(e){return function(e){return new _e(e)}({peerId:this.peerId,connectionManager:this.connectionManager,addressManager:this.addressManager,reservationStore:this.reservationStore,logger:this.logger})}listenFilter(e){return(e=Array.isArray(e)?e:[e]).filter(e=>Pe.exactMatch(e)||Oe.exactMatch(e))}dialFilter(e){return(e=Array.isArray(e)?e:[e]).filter(e=>C.exactMatch(e))}async onStop({connection:e,stream:t},r){var i,n;if(!this.reservationStore.hasReservation(e.remotePeer))try{this.log("dialed via relay we did not have a reservation on, start listening on that relay address"),await this.transportManager.listen([e.remoteAddr.encapsulate("/p2p-circuit")])}catch(u){this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on",u)}const s=Y(t).pb(he),o=await s.read({signal:r});if(this.log("new circuit relay v2 stop stream from %p with type %s",e.remotePeer,o.type),void 0===(null==o?void 0:o.type))return this.log.error("type was missing from circuit v2 stop protocol request from %s",e.remotePeer),await s.write({type:he.Type.STATUS,status:ve.MALFORMED_MESSAGE},{signal:r}),void(await t.close());if(o.type!==he.Type.CONNECT)return this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:he.Type.STATUS,status:ve.UNEXPECTED_MESSAGE},{signal:r}),void(await t.close());if(!(e=>{if(null==e.peer)return!1;try{e.peer.addrs.forEach(D)}catch{return!1}return!0})(o))return this.log.error("invalid stop connect request via peer %p",e.remotePeer),await s.write({type:he.Type.STATUS,status:ve.MALFORMED_MESSAGE},{signal:r}),void(await t.close({signal:r}));const a=U(z(o.peer.id));if(!0===await(null==(n=(i=this.connectionGater).denyInboundRelayedConnection)?void 0:n.call(i,e.remotePeer,a)))return this.log.error("connection gater denied inbound relayed connection from %p",e.remotePeer),await s.write({type:he.Type.STATUS,status:ve.PERMISSION_DENIED},{signal:r}),void(await t.close({signal:r}));this.log.trace("sending success response to %p",e.remotePeer),await s.write({type:he.Type.STATUS,status:ve.OK},{signal:r});const l=new Ne(o.limit),d=e.remoteAddr.encapsulate(`/p2p-circuit/p2p/${a.toString()}`);this.addressManager.getAddresses()[0];const c=ke({stream:s.unwrap().unwrap(),remoteAddr:d,logger:this.logger,onDataRead:l.onData,onDataWrite:l.onData});this.log("new inbound relayed connection %a",c.remoteAddr),await this.upgrader.upgradeInbound(c,{limits:l.getLimits(),signal:r}),this.log("%s connection %a upgraded","inbound",c.remoteAddr)}}function $e(e={}){return t=>new Ve(t,e)}export{Z as C,ee as D,ue as H,ne as K,ce as M,Ee as R,ve as S,te as a,se as b,oe as c,de as d,ae as e,re as f,he as g,Ae as h,le as i,$e as j,B as k,Y as p};
