var t,e=Object.defineProperty,n=(t,n,i)=>((t,n,i)=>n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[n]=i)(t,"symbol"!=typeof n?n+"":n,i);import{d as i,e as s,r,p as o,c as a,f as c,a as l,b as h,g as d,m as u,h as f,i as y,j as p}from"./index.S32ayjz-.js";import{U as m,g as w,m as g,h as b,i as _,s as k,C as v,a as B,f as S,y as x,z,j as N,d as D,A as L,D as I,p as P}from"./message.Ve-2rN-7.js";import{g as T}from"./mermaid-core.CmyEpniE.js";import{f as E,p as A,a as R,m as C}from"./index.CzrOjCaM.js";import{p as F}from"./index.BGGl-gag.js";import{p as U,S as H}from"./scalable-cuckoo-filter.BKNYiDuL.js";import{P as M,l as $}from"./index.DnnBcP15.js";import"./decode.9RDMYjMh.js";function V(t,e=1){return e=Number(e),null!=t[Symbol.asyncIterator]?async function*(){let n=[];if(e<1&&(e=1),e!==Math.round(e))throw new Error("Batch size must be an integer");for await(const i of t)for(n.push(i);n.length>=e;)yield n.slice(0,e),n=n.slice(e);for(;n.length>0;)yield n.slice(0,e),n=n.slice(e)}():function*(){let n=[];if(e<1&&(e=1),e!==Math.round(e))throw new Error("Batch size must be an integer");for(const i of t)for(n.push(i);n.length>=e;)yield n.slice(0,e),n=n.slice(e);for(;n.length>0;)yield n.slice(0,e),n=n.slice(e)}()}async function*O(t,e=1){for await(const n of V(t,e)){const t=n.map(async t=>t().then(t=>({ok:!0,value:t}),t=>({ok:!1,err:t})));for(let e=0;e<t.length;e++){const n=await t[e];if(!n.ok)throw n.err;yield n.value}}}const j=(t={})=>{const e=t.chunkSize??262144;return async function*(t){let n=new m,i=0,s=!1;for await(const r of t)for(n.append(r),i+=r.length;i>=e;)if(yield n.slice(0,e),s=!0,e===n.length)n=new m,i=0;else{const t=new m;t.append(n.sublist(e)),n=t,i-=e}(!s||i>0)&&(yield n.subarray(0,i))}},q=class t extends Error{constructor(e="Invalid type"){super(e),n(this,"name",t.name),n(this,"code",t.code)}};n(q,"name","InvalidTypeError"),n(q,"code","ERR_INVALID_TYPE");let W=q;const K=class t extends Error{constructor(e="Invalid message"){super(e),n(this,"name",t.name),n(this,"code",t.code)}};n(K,"name","InvalidUnixFSMessageError"),n(K,"code","ERR_INVALID_MESSAGE");let X=K;var Y,J,Q;!function(t){var e;let n;var i;let s;(e=t.DataType||(t.DataType={})).Raw="Raw",e.Directory="Directory",e.File="File",e.Metadata="Metadata",e.Symlink="Symlink",e.HAMTShard="HAMTShard",(i=n||(n={}))[i.Raw=0]="Raw",i[i.Directory=1]="Directory",i[i.File=2]="File",i[i.Metadata=3]="Metadata",i[i.Symlink=4]="Symlink",i[i.HAMTShard=5]="HAMTShard",function(t){t.codec=()=>w(n)}(t.DataType||(t.DataType={})),t.codec=()=>(null==s&&(s=g((e,n,i={})=>{if(!1!==i.lengthDelimited&&n.fork(),null!=e.Type&&(n.uint32(8),t.DataType.codec().encode(e.Type,n)),null!=e.Data&&(n.uint32(18),n.bytes(e.Data)),null!=e.filesize&&(n.uint32(24),n.uint64(e.filesize)),null!=e.blocksizes)for(const t of e.blocksizes)n.uint32(32),n.uint64(t);null!=e.hashType&&(n.uint32(40),n.uint64(e.hashType)),null!=e.fanout&&(n.uint32(48),n.uint64(e.fanout)),null!=e.mode&&(n.uint32(56),n.uint32(e.mode)),null!=e.mtime&&(n.uint32(66),J.codec().encode(e.mtime,n)),!1!==i.lengthDelimited&&n.ldelim()},(e,n)=>{const i={blocksizes:[]},s=null==n?e.len:e.pos+n;for(;e.pos<s;){const n=e.uint32();switch(n>>>3){case 1:i.Type=t.DataType.codec().decode(e);break;case 2:i.Data=e.bytes();break;case 3:i.filesize=e.uint64();break;case 4:i.blocksizes.push(e.uint64());break;case 5:i.hashType=e.uint64();break;case 6:i.fanout=e.uint64();break;case 7:i.mode=e.uint32();break;case 8:i.mtime=J.codec().decode(e,e.uint32());break;default:e.skipType(7&n)}}return i})),s),t.encode=e=>b(e,t.codec()),t.decode=e=>_(e,t.codec())}(Y||(Y={})),function(t){let e;t.codec=()=>(null==e&&(e=g((t,e,n={})=>{!1!==n.lengthDelimited&&e.fork(),null!=t.Seconds&&(e.uint32(8),e.int64(t.Seconds)),null!=t.FractionalNanoseconds&&(e.uint32(21),e.fixed32(t.FractionalNanoseconds)),!1!==n.lengthDelimited&&e.ldelim()},(t,e)=>{const n={},i=null==e?t.len:t.pos+e;for(;t.pos<i;){const e=t.uint32();switch(e>>>3){case 1:n.Seconds=t.int64();break;case 2:n.FractionalNanoseconds=t.fixed32();break;default:t.skipType(7&e)}}return n})),e),t.encode=e=>b(e,t.codec()),t.decode=e=>_(e,t.codec())}(J||(J={})),function(t){let e;t.codec=()=>(null==e&&(e=g((t,e,n={})=>{!1!==n.lengthDelimited&&e.fork(),null!=t.MimeType&&(e.uint32(10),e.string(t.MimeType)),!1!==n.lengthDelimited&&e.ldelim()},(t,e)=>{const n={},i=null==e?t.len:t.pos+e;for(;t.pos<i;){const e=t.uint32();if(e>>>3==1)n.MimeType=t.string();else t.skipType(7&e)}return n})),e),t.encode=e=>b(e,t.codec()),t.decode=e=>_(e,t.codec())}(Q||(Q={}));const G={Raw:"raw",Directory:"directory",File:"file",Metadata:"metadata",Symlink:"symlink",HAMTShard:"hamt-sharded-directory"},Z=["directory","hamt-sharded-directory"],tt=parseInt("0644",8),et=parseInt("0755",8),nt=BigInt(1024);let it=class t{constructor(t={type:"file"}){n(this,"type"),n(this,"data"),n(this,"blockSizes"),n(this,"hashType"),n(this,"fanout"),n(this,"mtime"),n(this,"_mode"),n(this,"_originalMode");const{type:e,data:i,blockSizes:s,hashType:r,fanout:o,mtime:a,mode:c}=t;if(null!=e&&!Object.values(G).includes(e))throw new W("Type: "+e+" is not valid");this.type=e??"file",this.data=i,this.hashType=r,this.fanout=o,this.blockSizes=s??[],this._originalMode=0,this.mode=c,this.mtime=a}static unmarshal(e){const n=Y.decode(e);if(null!=n.fanout&&n.fanout>nt)throw new X(`Fanout size was too large - ${n.fanout} > ${nt}`);const i=new t({type:G[null!=n.Type?n.Type.toString():"File"],data:n.Data,blockSizes:n.blocksizes,mode:n.mode,mtime:null!=n.mtime?{secs:n.mtime.Seconds??0n,nsecs:n.mtime.FractionalNanoseconds}:void 0,fanout:n.fanout});return i._originalMode=n.mode??0,i}set mode(t){this._mode=null==t?this.isDirectory()?et:tt:4095&t}get mode(){return this._mode}isDirectory(){return Z.includes(this.type)}addBlockSize(t){this.blockSizes.push(t)}removeBlockSize(t){this.blockSizes.splice(t,1)}fileSize(){if(this.isDirectory())return 0n;let t=0n;return this.blockSizes.forEach(e=>{t+=e}),null!=this.data&&(t+=BigInt(this.data.length)),t}marshal(){let t;switch(this.type){case"raw":t=Y.DataType.Raw;break;case"directory":t=Y.DataType.Directory;break;case"file":t=Y.DataType.File;break;case"metadata":t=Y.DataType.Metadata;break;case"symlink":t=Y.DataType.Symlink;break;case"hamt-sharded-directory":t=Y.DataType.HAMTShard;break;default:throw new W(`Type: ${t} is not valid`)}let e,n,i=this.data;return null!=this.data&&0!==this.data.length||(i=void 0),null!=this.mode&&(e=4294963200&this._originalMode|(this.mode??0),e!==tt||this.isDirectory()||(e=void 0),e===et&&this.isDirectory()&&(e=void 0)),null!=this.mtime&&(n={Seconds:this.mtime.secs,FractionalNanoseconds:this.mtime.nsecs}),Y.encode({Type:t,Data:i,filesize:this.isDirectory()?void 0:this.fileSize(),blocksizes:this.blockSizes,hashType:this.hashType,fanout:this.fanout,mode:e,mtime:n})}};const st=async(t,e,n)=>{null==n.codec&&(n.codec=i);const s=await k.digest(t),r=v.create(n.cidVersion,n.codec.code,s);return await e.put(r,t,n),r};function rt(t){return async function*(e,n){let o=0n;for await(let a of e.content)yield async()=>{var c;let l;const h={codec:i,cidVersion:t.cidVersion,onProgress:t.onProgress};t.rawLeaves?(h.codec=r,h.cidVersion=1):(l=new it({type:t.leafType,data:a}),a=s({Data:l.marshal(),Links:[]}));const d=await st(a,n,h);return o+=BigInt(a.byteLength),null==(c=t.onProgress)||c.call(t,new B("unixfs:importer:progress:file:write",{bytesWritten:o,cid:d,path:e.path})),{cid:d,unixfs:l,size:BigInt(a.length),block:a}}}}let ot=(t=class extends Error{constructor(e="Invalid parameters"){super(e),n(this,"name",t.name),n(this,"code",t.code)}},n(t,"name","InvalidParametersError"),n(t,"code","ERR_INVALID_PARAMS"),t);const at=class t extends Error{constructor(e="Invalid content"){super(e),n(this,"name",t.name),n(this,"code",t.code)}};n(at,"name","InvalidContentError"),n(at,"code","ERR_INVALID_CONTENT");let ct=at;const lt=async(t,e,n)=>{const i=new it({type:"directory",mtime:t.mtime,mode:t.mode}),r=s(o({Data:i.marshal()}));return{cid:await st(r,e,n),path:t.path,unixfs:i,size:BigInt(r.length),originalPath:t.originalPath,block:r}};function ht(t){return!0===t.single}const dt=async(t,e,n)=>n.layout(async function*(t,e,n){let i,s=-1;for await(const r of O(n.bufferImporter(t,e),n.blockWriteConcurrency))s++,0!==s?(1===s&&null!=i&&(yield{...i,block:void 0,single:void 0},i=void 0),yield{...r,block:void 0}):i={...r,single:!0};null!=i&&(yield i)}(t,e,n),((t,e,n)=>async function(i){var r,c;if(1===i.length&&ht(i[0])&&n.reduceSingleLeafToSelf){const a=i[0];let c=a.block;return!ht(a)||void 0===t.mtime&&void 0===t.mode||(a.unixfs=new it({type:"file",mtime:t.mtime,mode:t.mode,data:a.block}),c={Data:a.unixfs.marshal(),Links:[]},a.block=s(o(c)),a.cid=await st(a.block,e,{...n,cidVersion:n.cidVersion}),a.size=BigInt(a.block.length)),null==(r=n.onProgress)||r.call(n,new B("unixfs:importer:progress:file:layout",{cid:a.cid,path:a.originalPath})),{cid:a.cid,path:t.path,unixfs:a.unixfs,size:a.size,originalPath:a.originalPath}}const l=new it({type:"file",mtime:t.mtime,mode:t.mode}),h=i.filter(t=>{var e,n;return t.cid.code===a&&t.size>0||null!=t.unixfs&&null==t.unixfs.data&&t.unixfs.fileSize()>0n||Boolean(null==(n=null==(e=t.unixfs)?void 0:e.data)?void 0:n.length)}).map(t=>{var e,n;return t.cid.code===a?(l.addBlockSize(t.size),{Name:"",Tsize:Number(t.size),Hash:t.cid}):(null==(null==(e=t.unixfs)?void 0:e.data)?l.addBlockSize((null==(n=t.unixfs)?void 0:n.fileSize())??0n):l.addBlockSize(BigInt(t.unixfs.data.length)),{Name:"",Tsize:Number(t.size),Hash:t.cid})}),d={Data:l.marshal(),Links:h},u=s(o(d)),f=await st(u,e,n);return null==(c=n.onProgress)||c.call(n,new B("unixfs:importer:progress:file:layout",{cid:f,path:t.originalPath})),{cid:f,path:t.path,unixfs:l,size:BigInt(u.length+d.Links.reduce((t,e)=>t+(e.Tsize??0),0)),originalPath:t.originalPath,block:u}})(t,e,n));function ut(t){try{if(t instanceof Uint8Array)return async function*(){yield t}();if(e=t,Symbol.iterator in e)return async function*(){yield*t}();if(function(t){return Symbol.asyncIterator in t}(t))return t}catch{throw new ct("Content was invalid")}var e;throw new ct("Content was invalid")}function ft(t){return null!=t.content}function yt(t){const e=(null==t?void 0:t.maxChildrenPerNode)??174;return async function t(n,i){const s=[];for await(const r of V(n,e))s.push(await i(r));return s.length>1?t(s,i):s[0]}}let pt=class{constructor(t,e){n(this,"options"),n(this,"root"),n(this,"dir"),n(this,"path"),n(this,"dirty"),n(this,"flat"),n(this,"parent"),n(this,"parentKey"),n(this,"unixfs"),n(this,"mode"),n(this,"mtime"),n(this,"cid"),n(this,"size"),n(this,"nodeSize"),this.options=e??{},this.root=t.root,this.dir=t.dir,this.path=t.path,this.dirty=t.dirty,this.flat=t.flat,this.parent=t.parent,this.parentKey=t.parentKey,this.unixfs=t.unixfs,this.mode=t.mode,this.mtime=t.mtime}};const mt=v.parse("QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn"),wt=v.parse("zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi");class gt extends pt{constructor(t,e){super(t,e),n(this,"_children"),this._children=new Map}async put(t,e){this.cid=void 0,this.size=void 0,this.nodeSize=void 0,this._children.set(t,e)}async get(t){return Promise.resolve(this._children.get(t))}childCount(){return this._children.size}directChildrenCount(){return this.childCount()}onlyChild(){return this._children.values().next().value}*eachChildSeries(){for(const[t,e]of this._children.entries())yield{key:t,child:e}}estimateNodeSize(){if(void 0!==this.nodeSize)return this.nodeSize;this.nodeSize=0;for(const[t,e]of this._children.entries())null!=e.size&&null!=e.cid&&(this.nodeSize+=t.length+(1===this.options.cidVersion?wt.bytes.byteLength:mt.bytes.byteLength));return this.nodeSize}async*flush(t){const e=[];for(const[s,o]of this._children.entries()){let n=o;if(o instanceof pt)for await(const e of o.flush(t))n=e,yield e;null!=n.size&&null!=n.cid&&e.push({Name:s,Tsize:Number(n.size),Hash:n.cid})}const n=new it({type:"directory",mtime:this.mtime,mode:this.mode}),i={Data:n.marshal(),Links:e},r=s(o(i)),a=await st(r,t,this.options),c=r.length+i.Links.reduce((t,e)=>t+(e.Tsize??0),0);this.cid=a,this.size=c,yield{cid:a,unixfs:n,path:this.path,size:BigInt(c)}}}var bt,_t,kt={exports:{}};bt=kt,_t=kt.exports,function(t,e){var n={version:"3.0.0",x86:{},x64:{},inputValidation:!0};function i(t){if(!Array.isArray(t)&&!ArrayBuffer.isView(t))return!1;for(var e=0;e<t.length;e++)if(!Number.isInteger(t[e])||t[e]<0||t[e]>255)return!1;return!0}function s(t,e){return(65535&t)*e+(((t>>>16)*e&65535)<<16)}function r(t,e){return t<<e|t>>>32-e}function o(t){return t=s(t^=t>>>16,2246822507),t=s(t^=t>>>13,3266489909),t^=t>>>16}function a(t,e){t=[t[0]>>>16,65535&t[0],t[1]>>>16,65535&t[1]],e=[e[0]>>>16,65535&e[0],e[1]>>>16,65535&e[1]];var n=[0,0,0,0];return n[3]+=t[3]+e[3],n[2]+=n[3]>>>16,n[3]&=65535,n[2]+=t[2]+e[2],n[1]+=n[2]>>>16,n[2]&=65535,n[1]+=t[1]+e[1],n[0]+=n[1]>>>16,n[1]&=65535,n[0]+=t[0]+e[0],n[0]&=65535,[n[0]<<16|n[1],n[2]<<16|n[3]]}function c(t,e){t=[t[0]>>>16,65535&t[0],t[1]>>>16,65535&t[1]],e=[e[0]>>>16,65535&e[0],e[1]>>>16,65535&e[1]];var n=[0,0,0,0];return n[3]+=t[3]*e[3],n[2]+=n[3]>>>16,n[3]&=65535,n[2]+=t[2]*e[3],n[1]+=n[2]>>>16,n[2]&=65535,n[2]+=t[3]*e[2],n[1]+=n[2]>>>16,n[2]&=65535,n[1]+=t[1]*e[3],n[0]+=n[1]>>>16,n[1]&=65535,n[1]+=t[2]*e[2],n[0]+=n[1]>>>16,n[1]&=65535,n[1]+=t[3]*e[1],n[0]+=n[1]>>>16,n[1]&=65535,n[0]+=t[0]*e[3]+t[1]*e[2]+t[2]*e[1]+t[3]*e[0],n[0]&=65535,[n[0]<<16|n[1],n[2]<<16|n[3]]}function l(t,e){return 32==(e%=64)?[t[1],t[0]]:e<32?[t[0]<<e|t[1]>>>32-e,t[1]<<e|t[0]>>>32-e]:(e-=32,[t[1]<<e|t[0]>>>32-e,t[0]<<e|t[1]>>>32-e])}function h(t,e){return 0==(e%=64)?t:e<32?[t[0]<<e|t[1]>>>32-e,t[1]<<e]:[t[1]<<e-32,0]}function d(t,e){return[t[0]^e[0],t[1]^e[1]]}function u(t){return t=d(t,[0,t[0]>>>1]),t=d(t=c(t,[4283543511,3981806797]),[0,t[0]>>>1]),t=d(t=c(t,[3301882366,444984403]),[0,t[0]>>>1])}n.x86.hash32=function(t,a){if(n.inputValidation&&!i(t))return e;a=a||0;for(var c=t.length%4,l=t.length-c,h=a,d=0,u=3432918353,f=461845907,y=0;y<l;y+=4)d=s(d=t[y]|t[y+1]<<8|t[y+2]<<16|t[y+3]<<24,u),d=s(d=r(d,15),f),h=s(h=r(h^=d,13),5)+3864292196;switch(d=0,c){case 3:d^=t[y+2]<<16;case 2:d^=t[y+1]<<8;case 1:d=s(d^=t[y],u),h^=d=s(d=r(d,15),f)}return(h=o(h^=t.length))>>>0},n.x86.hash128=function(t,a){if(n.inputValidation&&!i(t))return e;a=a||0;for(var c=t.length%16,l=t.length-c,h=a,d=a,u=a,f=a,y=0,p=0,m=0,w=0,g=597399067,b=2869860233,_=951274213,k=2716044179,v=0;v<l;v+=16)y=t[v]|t[v+1]<<8|t[v+2]<<16|t[v+3]<<24,p=t[v+4]|t[v+5]<<8|t[v+6]<<16|t[v+7]<<24,m=t[v+8]|t[v+9]<<8|t[v+10]<<16|t[v+11]<<24,w=t[v+12]|t[v+13]<<8|t[v+14]<<16|t[v+15]<<24,y=r(y=s(y,g),15),h=r(h^=y=s(y,b),19),h=s(h+=d,5)+1444728091,p=r(p=s(p,b),16),d=r(d^=p=s(p,_),17),d=s(d+=u,5)+197830471,m=r(m=s(m,_),17),u=r(u^=m=s(m,k),15),u=s(u+=f,5)+2530024501,w=r(w=s(w,k),18),f=r(f^=w=s(w,g),13),f=s(f+=h,5)+850148119;switch(y=0,p=0,m=0,w=0,c){case 15:w^=t[v+14]<<16;case 14:w^=t[v+13]<<8;case 13:w=s(w^=t[v+12],k),f^=w=s(w=r(w,18),g);case 12:m^=t[v+11]<<24;case 11:m^=t[v+10]<<16;case 10:m^=t[v+9]<<8;case 9:m=s(m^=t[v+8],_),u^=m=s(m=r(m,17),k);case 8:p^=t[v+7]<<24;case 7:p^=t[v+6]<<16;case 6:p^=t[v+5]<<8;case 5:p=s(p^=t[v+4],b),d^=p=s(p=r(p,16),_);case 4:y^=t[v+3]<<24;case 3:y^=t[v+2]<<16;case 2:y^=t[v+1]<<8;case 1:y=s(y^=t[v],g),h^=y=s(y=r(y,15),b)}return h^=t.length,h+=d^=t.length,h+=u^=t.length,d+=h+=f^=t.length,u+=h,f+=h,h=o(h),h+=d=o(d),h+=u=o(u),d+=h+=f=o(f),u+=h,f+=h,("00000000"+(h>>>0).toString(16)).slice(-8)+("00000000"+(d>>>0).toString(16)).slice(-8)+("00000000"+(u>>>0).toString(16)).slice(-8)+("00000000"+(f>>>0).toString(16)).slice(-8)},n.x64.hash128=function(t,s){if(n.inputValidation&&!i(t))return e;s=s||0;for(var r=t.length%16,o=t.length-r,f=[0,s],y=[0,s],p=[0,0],m=[0,0],w=[2277735313,289559509],g=[1291169091,658871167],b=0;b<o;b+=16)p=[t[b+4]|t[b+5]<<8|t[b+6]<<16|t[b+7]<<24,t[b]|t[b+1]<<8|t[b+2]<<16|t[b+3]<<24],m=[t[b+12]|t[b+13]<<8|t[b+14]<<16|t[b+15]<<24,t[b+8]|t[b+9]<<8|t[b+10]<<16|t[b+11]<<24],p=l(p=c(p,w),31),f=a(f=l(f=d(f,p=c(p,g)),27),y),f=a(c(f,[0,5]),[0,1390208809]),m=l(m=c(m,g),33),y=a(y=l(y=d(y,m=c(m,w)),31),f),y=a(c(y,[0,5]),[0,944331445]);switch(p=[0,0],m=[0,0],r){case 15:m=d(m,h([0,t[b+14]],48));case 14:m=d(m,h([0,t[b+13]],40));case 13:m=d(m,h([0,t[b+12]],32));case 12:m=d(m,h([0,t[b+11]],24));case 11:m=d(m,h([0,t[b+10]],16));case 10:m=d(m,h([0,t[b+9]],8));case 9:m=c(m=d(m,[0,t[b+8]]),g),y=d(y,m=c(m=l(m,33),w));case 8:p=d(p,h([0,t[b+7]],56));case 7:p=d(p,h([0,t[b+6]],48));case 6:p=d(p,h([0,t[b+5]],40));case 5:p=d(p,h([0,t[b+4]],32));case 4:p=d(p,h([0,t[b+3]],24));case 3:p=d(p,h([0,t[b+2]],16));case 2:p=d(p,h([0,t[b+1]],8));case 1:p=c(p=d(p,[0,t[b]]),w),f=d(f,p=c(p=l(p,31),g))}return f=a(f=d(f,[0,t.length]),y=d(y,[0,t.length])),y=a(y,f),f=a(f=u(f),y=u(y)),y=a(y,f),("00000000"+(f[0]>>>0).toString(16)).slice(-8)+("00000000"+(f[1]>>>0).toString(16)).slice(-8)+("00000000"+(y[0]>>>0).toString(16)).slice(-8)+("00000000"+(y[1]>>>0).toString(16)).slice(-8)},bt.exports&&(_t=bt.exports=n),_t.murmurHash3=n}();const vt=T(kt.exports),Bt=x({name:"murmur3-128",code:34,encode:t=>z(vt.x64.hash128(t))});function St(t,e){return t+xt(e)}function xt(t){let e=t;return e-=e>>1&1431655765,e=(858993459&e)+(e>>2&858993459),16843009*(e+(e>>4)&252645135)>>24}function zt(t,e){return t[0]-e[0]}function Nt(t){return t[1]}const Dt=T(class{constructor(){this._bitArrays=[],this._data=[],this._length=0,this._changedLength=!1,this._changedData=!1}set(t,e){let n=this._internalPositionFor(t,!1);if(void 0===e)-1!==n&&(this._unsetInternalPos(n),this._unsetBit(t),this._changedLength=!0,this._changedData=!0);else{let i=!1;-1===n?(n=this._data.length,this._setBit(t),this._changedData=!0):i=!0,this._setInternalPos(n,t,e,i),this._changedLength=!0}}unset(t){this.set(t,void 0)}get(t){this._sortData();const e=this._internalPositionFor(t,!0);if(-1!==e)return this._data[e][1]}push(t){return this.set(this.length,t),this.length}get length(){if(this._sortData(),this._changedLength){const t=this._data[this._data.length-1];this._length=t?t[0]+1:0,this._changedLength=!1}return this._length}forEach(t){let e=0;for(;e<this.length;)t(this.get(e),e,this),e++}map(t){let e=0,n=new Array(this.length);for(;e<this.length;)n[e]=t(this.get(e),e,this),e++;return n}reduce(t,e){let n=0,i=e;for(;n<this.length;){i=t(i,this.get(n),n),n++}return i}find(t){let e,n,i=0;for(;i<this.length&&!e;)n=this.get(i),e=t(n),i++;return e?n:void 0}_internalPositionFor(t,e){const n=this._bytePosFor(t,e);if(n>=this._bitArrays.length)return-1;const i=this._bitArrays[n],s=t-7*n;if(!((i&1<<s)>0))return-1;return this._bitArrays.slice(0,n).reduce(St,0)+xt(i&~(4294967295<<s+1))-1}_bytePosFor(t,e){const n=Math.floor(t/7),i=n+1;for(;!e&&this._bitArrays.length<i;)this._bitArrays.push(0);return n}_setBit(t){const e=this._bytePosFor(t,!1);this._bitArrays[e]|=1<<t-7*e}_unsetBit(t){const e=this._bytePosFor(t,!1);this._bitArrays[e]&=~(1<<t-7*e)}_setInternalPos(t,e,n,i){const s=this._data,r=[e,n];if(i)this._sortData(),s[t]=r;else{if(s.length)if(s[s.length-1][0]>=e)s.push(r);else if(s[0][0]<=e)s.unshift(r);else{const t=Math.round(s.length/2);this._data=s.slice(0,t).concat(r).concat(s.slice(t))}else this._data.push(r);this._changedData=!0,this._changedLength=!0}}_unsetInternalPos(t){this._data.splice(t,1)}_sortData(){this._changedData&&this._data.sort(zt),this._changedData=!1}bitField(){const t=[];let e,n=8,i=0,s=0;const r=this._bitArrays.slice();for(;r.length||i;){0===i&&(e=r.shift(),i=7);const o=Math.min(i,n);s|=(e&~(255<<o))<<8-n,e>>>=o,i-=o,n-=o,n&&(i||r.length)||(t.push(s),s=0,n=8)}for(var o=t.length-1;o>0;o--){if(0!==t[o])break;t.pop()}return t}compactArray(){return this._sortData(),this._data.map(Nt)}});class Lt{constructor(t,e,i=0){n(this,"_options"),n(this,"_popCount"),n(this,"_parent"),n(this,"_posAtParent"),n(this,"_children"),n(this,"key"),this._options=t,this._popCount=0,this._parent=e,this._posAtParent=i,this._children=new Dt,this.key=null}async put(t,e){const n=await this._findNewBucketAndPos(t);n.bucket._putAt(n,t,e)}async get(t){const e=await this._findChild(t);if(null!=e)return e.value}async del(t){const e=await this._findPlace(t),n=e.bucket._at(e.pos);null!=n&&n.key===t&&e.bucket._delAt(e.pos)}leafCount(){return this._children.compactArray().reduce((t,e)=>e instanceof Lt?t+e.leafCount():t+1,0)}childrenCount(){return this._children.length}onlyChild(){return this._children.get(0)}*eachLeafSeries(){const t=this._children.compactArray();for(const e of t)e instanceof Lt?yield*e.eachLeafSeries():yield e}serialize(t,e){return e(this._children.reduce((n,i,s)=>(null!=i&&(i instanceof Lt?n.push(i.serialize(t,e)):n.push(t(i,s))),n),[]))}async asyncTransform(t,e){return Et(this,t,e)}toJSON(){return this.serialize(Pt,Tt)}prettyPrint(){return JSON.stringify(this.toJSON(),null,"  ")}tableSize(){return Math.pow(2,this._options.bits)}async _findChild(t){const e=await this._findPlace(t),n=e.bucket._at(e.pos);if(!(n instanceof Lt))return null!=n&&n.key===t?n:void 0}async _findPlace(t){const e=this._options.hash("string"==typeof t?S(t):t),n=await e.take(this._options.bits),i=this._children.get(n);return i instanceof Lt?i._findPlace(e):{bucket:this,pos:n,hash:e,existingChild:i}}async _findNewBucketAndPos(t){const e=await this._findPlace(t);if(null!=e.existingChild&&e.existingChild.key!==t){const t=new Lt(this._options,e.bucket,e.pos);e.bucket._putObjectAt(e.pos,t);const n=await t._findPlace(e.existingChild.hash);return n.bucket._putAt(n,e.existingChild.key,e.existingChild.value),t._findNewBucketAndPos(e.hash)}return e}_putAt(t,e,n){this._putObjectAt(t.pos,{key:e,value:n,hash:t.hash})}_putObjectAt(t,e){null==this._children.get(t)&&this._popCount++,this._children.set(t,e)}_delAt(t){if(-1===t)throw new Error("Invalid position");null!=this._children.get(t)&&this._popCount--,this._children.unset(t),this._level()}_level(){if(null!=this._parent&&this._popCount<=1)if(1===this._popCount){const t=this._children.find(It);if(null!=t&&!(t instanceof Lt)){const e=t.hash;e.untake(this._options.bits);const n={pos:this._posAtParent,hash:e,bucket:this._parent};this._parent._putAt(n,t.key,t.value)}}else this._parent._delAt(this._posAtParent)}_at(t){return this._children.get(t)}}function It(t){return Boolean(t)}function Pt(t,e){return t.key}function Tt(t){return t}async function Et(t,e,n){const i=[];for(const s of t._children.compactArray())if(s instanceof Lt)await Et(s,e,n);else{const n=await e(s);i.push({bitField:t._children.bitField(),children:n})}return n(i)}const At=[255,254,252,248,240,224,192,128],Rt=[1,3,7,15,31,63,127,255];let Ct=class{constructor(t){n(this,"_value"),n(this,"_currentBytePos"),n(this,"_currentBitPos"),this._value=t,this._currentBytePos=t.length-1,this._currentBitPos=7}availableBits(){return this._currentBitPos+1+8*this._currentBytePos}totalBits(){return 8*this._value.length}take(t){let e=t,n=0;for(;e>0&&this._haveBits();){const t=this._value[this._currentBytePos],i=this._currentBitPos+1,s=Math.min(i,e);n=(n<<s)+Ft(t,i-s,s),e-=s,this._currentBitPos-=s,this._currentBitPos<0&&(this._currentBitPos=7,this._currentBytePos--)}return n}untake(t){for(this._currentBitPos+=t;this._currentBitPos>7;)this._currentBitPos-=8,this._currentBytePos+=1}_haveBits(){return this._currentBytePos>=0}};function Ft(t,e,n){const i=function(t,e){return At[t]&Rt[Math.min(e+t-1,7)]}(e,n);return(t&i)>>>e}let Ut=class{constructor(t,e){if(n(this,"_value"),n(this,"_hashFn"),n(this,"_depth"),n(this,"_availableBits"),n(this,"_currentBufferIndex"),n(this,"_buffers"),!(t instanceof Uint8Array))throw new Error("can only hash Uint8Arrays");this._value=t,this._hashFn=e,this._depth=-1,this._availableBits=0,this._currentBufferIndex=0,this._buffers=[]}async take(t){let e=t;for(;this._availableBits<e;)await this._produceMoreBits();let n=0;for(;e>0;){const t=this._buffers[this._currentBufferIndex],i=Math.min(t.availableBits(),e);n=(n<<i)+t.take(i),e-=i,this._availableBits-=i,0===t.availableBits()&&this._currentBufferIndex++}return n}untake(t){let e=t;for(;e>0;){const t=this._buffers[this._currentBufferIndex],n=Math.min(t.totalBits()-t.availableBits(),e);t.untake(n),e-=n,this._availableBits+=n,this._currentBufferIndex>0&&t.totalBits()===t.availableBits()&&(this._depth--,this._currentBufferIndex--)}}async _produceMoreBits(){this._depth++;const t=this._depth>0?N([this._value,Uint8Array.from([this._depth])]):this._value,e=await this._hashFn(t),n=new Ct(e);this._buffers.push(n),this._availableBits+=n.availableBits()}};function Ht(t){if(null==t||null==t.hashFn)throw new Error("please define an options.hashFn");const e={bits:t.bits??8,hash:(n=t.hashFn,function(t){return t instanceof Ut?t:new Ut(t,n)})};var n;return new Lt(e)}async function Mt(t){return(await Bt.encode(t)).slice(0,8).reverse()}const $t=BigInt(34);let Vt=class extends pt{constructor(t,e){super(t,e),n(this,"_bucket"),this._bucket=Ht({hashFn:Mt,bits:e.shardFanoutBits??8})}async put(t,e){this.cid=void 0,this.size=void 0,this.nodeSize=void 0,await this._bucket.put(t,e)}async get(t){return this._bucket.get(t)}childCount(){return this._bucket.leafCount()}directChildrenCount(){return this._bucket.childrenCount()}onlyChild(){return this._bucket.onlyChild()}*eachChildSeries(){for(const{key:t,value:e}of this._bucket.eachLeafSeries())yield{key:t,child:e}}estimateNodeSize(){return void 0!==this.nodeSize||(this.nodeSize=qt(this._bucket,this,this.options)),this.nodeSize}async*flush(t){for await(const e of Ot(this._bucket,t,this,this.options))yield{...e,path:this.path}}};async function*Ot(t,e,n,i){const r=t._children,a=(t.tableSize()-1).toString(16).length,c=[];let l=0n;for(let s=0;s<r.length;s++){const t=r.get(s);if(null==t)continue;const n=s.toString(16).toUpperCase().padStart(a,"0");if(t instanceof Lt){let s;for await(const n of Ot(t,e,null,i))s=n;if(null==s)throw new Error("Could not flush sharded directory, no subshard found");c.push({Name:n,Tsize:Number(s.size),Hash:s.cid}),l+=s.size}else if(jt(t.value)){const i=t.value;let s;for await(const t of i.flush(e))s=t,yield s;if(null==s)throw new Error("Did not flush dir");const r=n+t.key;c.push({Name:r,Tsize:Number(s.size),Hash:s.cid}),l+=s.size}else{const e=t.value;if(null==e.cid)continue;const i=n+t.key,s=e.size;c.push({Name:i,Tsize:Number(s),Hash:e.cid}),l+=BigInt(s??0)}}const h=Uint8Array.from(r.bitField().reverse()),d=new it({type:"hamt-sharded-directory",data:h,fanout:BigInt(t.tableSize()),hashType:$t,mtime:null==n?void 0:n.mtime,mode:null==n?void 0:n.mode}),u={Data:d.marshal(),Links:c},f=s(o(u)),y=await st(f,e,i),p=BigInt(f.byteLength)+l;yield{cid:y,unixfs:d,size:p}}function jt(t){return"function"==typeof t.flush}function qt(t,e,n){const i=t._children,r=(t.tableSize()-1).toString(16).length,a=[];for(let s=0;s<i.length;s++){const t=i.get(s);if(null==t)continue;const e=s.toString(16).toUpperCase().padStart(r,"0");if(t instanceof Lt){const i=qt(t,null,n);a.push({Name:e,Tsize:Number(i),Hash:0===n.cidVersion?mt:wt})}else if("function"==typeof t.value.flush){const i=t.value.nodeSize();a.push({Name:e+t.key,Tsize:Number(i),Hash:0===n.cidVersion?mt:wt})}else{const n=t.value;if(null==n.cid)continue;const i=e+t.key,s=n.size;a.push({Name:i,Tsize:Number(s),Hash:n.cid})}}const c=Uint8Array.from(i.bitField().reverse()),l=new it({type:"hamt-sharded-directory",data:c,fanout:BigInt(t.tableSize()),hashType:$t,mtime:null==e?void 0:e.mtime,mode:null==e?void 0:e.mode});return s(o({Data:l.marshal(),Links:a})).length}async function Wt(t,e,n,i){let s=e;e instanceof gt&&e.estimateNodeSize()>n&&(s=await async function(t,e){const n=new Vt({root:t.root,dir:!0,parent:t.parent,parentKey:t.parentKey,path:t.path,dirty:t.dirty,flat:!1,mtime:t.mtime,mode:t.mode},e);for(const{key:i,child:s}of t.eachChildSeries())await n.put(i,s);return n}(e,i));const r=s.parent;if(null!=r){if(s!==e){if(null!=t&&(t.parent=s),null==s.parentKey)throw new Error("No parent key found");await r.put(s.parentKey,s)}return Wt(s,r,n,i)}return s}async function Kt(t,e,n){var i,s;const r=((t="")=>t.split(new RegExp("(?<!\\\\)\\/")).filter(Boolean))(t.path??""),o=r.length-1;let a=e,c="";for(let l=0;l<r.length;l++){const h=r[l];c+=`${""!==c?"/":""}${h}`;const d=l===o;if(a.dirty=!0,a.cid=void 0,a.size=void 0,d)await a.put(h,t),e=await Wt(null,a,n.shardSplitThresholdBytes,n);else{let t=await a.get(h);null!=t&&t instanceof pt||(t=new gt({root:!1,dir:!0,parent:a,parentKey:h,path:c,dirty:!0,flat:!0,mtime:null==(i=null==t?void 0:t.unixfs)?void 0:i.mtime,mode:null==(s=null==t?void 0:t.unixfs)?void 0:s.mode},n)),await a.put(h,t),a=t}}return e}async function*Xt(t,e){var n;t instanceof pt?yield*t.flush(e):!0===(null==(n=t.unixfs)?void 0:n.isDirectory())&&(yield t)}async function*Yt(t,e,n={}){let i;i=Symbol.asyncIterator in t||Symbol.iterator in t?t:[t];const s=n.wrapWithDirectory??!1,r=n.shardSplitThresholdBytes??262144,o=n.shardFanoutBits??8,a=n.cidVersion??1,c=n.rawLeaves??!0,l=n.leafType??"file",h=n.fileImportConcurrency??50,d=n.blockWriteConcurrency??10,u=n.reduceSingleLeafToSelf??!0,f=n.chunker??j(),y=n.chunkValidator??async function*(t){for await(const e of t){if(void 0===e.length)throw new ct("Content was invalid");if("string"==typeof e||e instanceof String)yield S(e.toString());else if(Array.isArray(e))yield Uint8Array.from(e);else{if(!(e instanceof Uint8Array))throw new ct("Content was invalid");yield e}}},p=n.dagBuilder??function(t){return async function*(e,n){for await(const i of e){let e;if(null!=i.path&&(e=i.path,i.path=i.path.split("/").filter(t=>null!=t&&"."!==t).join("/")),ft(i)){const s={path:i.path,mtime:i.mtime,mode:i.mode,content:async function*(){var e;let n=0n;for await(const s of t.chunker(t.chunkValidator(ut(i.content)))){const r=BigInt(s.byteLength);n+=r,null==(e=t.onProgress)||e.call(t,new B("unixfs:importer:progress:file:read",{bytesRead:n,chunkSize:r,path:i.path})),yield s}}(),originalPath:e},r=t.fileBuilder??dt;yield async()=>r(s,n,t)}else{if(null==i.path)throw new Error("Import candidate must have content or path or both");{const s={path:i.path,mtime:i.mtime,mode:i.mode,originalPath:e},r=t.dirBuilder??lt;yield async()=>r(s,n,t)}}}}}({chunker:f,chunkValidator:y,wrapWithDirectory:s,layout:n.layout??yt(),bufferImporter:n.bufferImporter??rt({cidVersion:a,rawLeaves:c,leafType:l,onProgress:n.onProgress}),blockWriteConcurrency:d,reduceSingleLeafToSelf:u,cidVersion:a,onProgress:n.onProgress,dirBuilder:n.dirBuilder,fileBuilder:n.fileBuilder}),m=n.treeBuilder??function(t){return async function*(e,n){var i;let s,r=new gt({root:!0,dir:!0,path:"",dirty:!0,flat:!0},t),o=!1;for await(const a of e){if(null==a)continue;const e=`${a.originalPath??""}`.split("/")[0];null!=e&&""!==e&&(null==s?(s=e,o=!0):s!==e&&(o=!1)),r=await Kt(a,r,t),!0!==(null==(i=a.unixfs)?void 0:i.isDirectory())&&(yield a)}if(t.wrapWithDirectory||o&&r.childCount()>1)yield*Xt(r,n);else for(const t of r.eachChildSeries())null!=t&&(yield*Xt(t.child,n))}}({wrapWithDirectory:s,shardSplitThresholdBytes:r,shardFanoutBits:o,cidVersion:a,onProgress:n.onProgress});for await(const w of m(O(p(i,e),h),e))yield{cid:w.cid,path:w.path,unixfs:w.unixfs,size:w.size}}async function Jt(t,e,n={}){const i=await c(Yt([t],e,n));if(null==i)throw new ot("Nothing imported");return i}function Qt(t){if(null!=t[Symbol.asyncIterator])return(async()=>{let e;for await(const n of t)e=n;return e})();let e;for(const n of t)e=n;return e}class Gt extends Error{constructor(t,e,i){super(t),n(this,"name"),n(this,"code"),this.name=e,this.code=i}}let Zt=class extends Gt{constructor(t="not a Unixfs node"){super(t,"NotUnixFSError","ERR_NOT_UNIXFS")}};class te extends Gt{constructor(t="invalid PBNode"){super(t,"InvalidPBNodeError","ERR_INVALID_PB_NODE")}}class ee extends Gt{constructor(t="unknown error"){super(t,"InvalidPBNodeError","ERR_UNKNOWN_ERROR")}}class ne extends Gt{constructor(t="path already exists"){super(t,"AlreadyExistsError","ERR_ALREADY_EXISTS")}}class ie extends Gt{constructor(t="path does not exist"){super(t,"DoesNotExistError","ERR_DOES_NOT_EXIST")}}class se extends Gt{constructor(t="no content"){super(t,"NoContentError","ERR_NO_CONTENT")}}class re extends Gt{constructor(t="not a file"){super(t,"NotAFileError","ERR_NOT_A_FILE")}}class oe extends Gt{constructor(t="not a directory"){super(t,"NotADirectoryError","ERR_NOT_A_DIRECTORY")}}let ae=class extends Gt{constructor(t="invalid parameters"){super(t,"InvalidParametersError","ERR_INVALID_PARAMETERS")}};const ce={cidVersion:1,rawLeaves:!0,layout:yt({maxChildrenPerNode:1024}),chunker:j({chunkSize:1048576})};async function*le(t,e,n={}){yield*Yt(t,e,{...ce,...n})}async function he(t,e,n={}){const{cid:i}=await async function(t,e,n={}){return Jt({content:t},e,n)}(t,e,{...ce,...n});return i}async function de(t,e,n={}){const{cid:i}=await async function(t,e,n={}){return Jt({content:t},e,n)}(t,e,{...ce,...n});return i}const ue=class t extends Error{constructor(e="Bad path"){super(e),n(this,"name",t.name),n(this,"code",t.code)}};n(ue,"name","BadPathError"),n(ue,"code","ERR_BAD_PATH");let fe=ue;const ye=class t extends Error{constructor(e="Not found"){super(e),n(this,"name",t.name),n(this,"code",t.code)}};n(ye,"name","NotFoundError"),n(ye,"code","ERR_NOT_FOUND");let pe=ye;const me=class t extends Error{constructor(e="No resolver"){super(e),n(this,"name",t.name),n(this,"code",t.code)}};n(me,"name","NoResolverError"),n(me,"code","ERR_NO_RESOLVER");let we=me;const ge=class t extends Error{constructor(e="Not UnixFS"){super(e),n(this,"name",t.name),n(this,"code",t.code)}};n(ge,"name","NotUnixFSError"),n(ge,"code","ERR_NOT_UNIXFS");let be=ge;const _e=class t extends Error{constructor(e="Over read"){super(e),n(this,"name",t.name),n(this,"code",t.code)}};n(_e,"name","OverReadError"),n(_e,"code","ERR_OVER_READ");let ke=_e;const ve=class t extends Error{constructor(e="Under read"){super(e),n(this,"name",t.name),n(this,"code",t.code)}};n(ve,"name","UnderReadError"),n(ve,"code","ERR_UNDER_READ");let Be=ve;const Se=class t extends Error{constructor(e="No Property found"){super(e),n(this,"name",t.name),n(this,"code",t.code)}};n(Se,"name","NoPropError"),n(Se,"code","ERR_NO_PROP");let xe=Se;const ze=class t extends Error{constructor(e="Invalid parameters"){super(e),n(this,"name",t.name),n(this,"code",t.code)}};n(ze,"name","InvalidParametersError"),n(ze,"code","ERR_INVALID_PARAMS");let Ne=ze;function De(t,e,n,i,s,r,o){let a=t,c=s;for(;r.length>0;){const l=r[0];if(!(l in a))throw new xe(`No property named ${l} found in node ${n}`);{r.shift(),c=`${c}/${l}`;const h=v.asCID(a[l]);if(null!=h)return{entry:{type:"object",name:i,path:s,cid:n,node:e,depth:o,size:BigInt(e.length),content:async function*(){yield t}},next:{cid:h,name:l,path:c,toResolve:r}};a=a[l]}}return{entry:{type:"object",name:i,path:s,cid:n,node:e,depth:o,size:BigInt(e.length),content:async function*(){yield t}}}}function Le(t,e,n,i){const s=BigInt(t.length),r=BigInt(e+s);return n>=r||i<e?new Uint8Array(0):(i>=e&&i<r&&(t=t.subarray(0,Number(i-e))),n>=e&&n<r&&(t=t.subarray(Number(n-e))),t)}const Ie=(t,e=0,n=t)=>{const i=BigInt(t),s=BigInt(e??0);let r=BigInt(n);if(r!==i&&(r=s+r),r>i&&(r=i),s<0n)throw new Ne("Offset must be greater than or equal to 0");if(s>i)throw new Ne("Offset must be less than the file size");if(r<0n)throw new Ne("Length must be greater than or equal to 0");if(r>i)throw new Ne("Length must be less than the file size");return{start:s,end:r}},Pe=async function(t){return(await Bt.encode(t)).slice(0,8).reverse()},Te=(t,e)=>t.toString(16).toUpperCase().padStart(e,"0").substring(0,e),Ee=async(t,e,n,i,s)=>{if(null==i){if(null==t.Data)throw new be("no data in PBNode");let e;try{e=it.unmarshal(t.Data)}catch(u){throw new be(u.message)}if("hamt-sharded-directory"!==e.type)throw new be("not a HAMT");if(null==e.fanout)throw new be("missing fanout");const n=Ht({hashFn:Pe,bits:Math.log2(Number(e.fanout))});i={rootBucket:n,hamtDepth:1,lastBucket:n}}const r=(i.lastBucket.tableSize()-1).toString(16).length;await(async(t,e,n)=>{const i=(e.tableSize()-1).toString(16).length;await Promise.all(t.map(async t=>{if(null==t.Name)throw new Error("Unexpected Link without a Name");if(t.Name.length===i){const i=parseInt(t.Name,16);return void e._putObjectAt(i,new Lt({hash:n._options.hash,bits:n._options.bits},e,i))}await n.put(t.Name.substring(2),!0)}))})(t.Links,i.lastBucket,i.rootBucket);const o=await i.rootBucket._findNewBucketAndPos(e);let a=Te(o.pos,r);const c=(t=>{let e=t.bucket;const n=[];for(;null!=e._parent;)n.push(e),e=e._parent;return n.push(e),n.reverse()})(o);c.length>i.hamtDepth&&(i.lastBucket=c[i.hamtDepth],a=Te(i.lastBucket._posAtParent,r));const l=t.Links.find(t=>{if(null==t.Name)return!1;const n=t.Name.substring(0,r),i=t.Name.substring(r);return n===a&&(""===i||i===e)});if(null==l)return;if(null!=l.Name&&l.Name.substring(r)===e)return l.Hash;i.hamtDepth++;const h=await n.get(l.Hash,s);return t=d(h),Ee(t,e,n,i,s)};function Ae(t){return!1===(null==t?void 0:t.extended)}async function Re(t,e,n,i,s,r,o){if(e instanceof Uint8Array){const t=Le(e,i,s,r);return void n.push(t)}if(null==e.Data)throw new be("no data in PBNode");let c;try{c=it.unmarshal(e.Data)}catch(h){throw new be(h.message)}if(null!=c.data){const t=Le(c.data,i,s,r);n.push(t),i+=BigInt(t.byteLength)}const l=[];if(e.Links.length!==c.blockSizes.length)throw new be("Inconsistent block sizes and dag links");for(let a=0;a<e.Links.length;a++){const t=e.Links[a],n=i,o=n+c.blockSizes[a];if((s>=n&&s<o||r>=n&&r<=o||s<n&&r>o)&&l.push({link:t,blockStart:i}),(i=o)>r)break}await F(l,e=>u(e,e=>async()=>{const n=await t.get(e.link.Hash,o);return{...e,block:n}}),t=>A(t,{ordered:!0,concurrency:o.blockReadConcurrency}),async e=>{for await(const{link:i,block:c,blockStart:l}of e){let e;switch(i.Hash.code){case f:e=d(c);break;case a:e=c;break;default:return void n.end(new be(`Unsupported codec: ${i.Hash.code}`))}const h=new M({concurrency:1});h.on("error",t=>{n.end(t)}),h.add(async()=>{var a;null==(a=o.onProgress)||a.call(o,new B("unixfs:exporter:walk:file",{cid:i.Hash})),await Re(t,e,n,l,s,r,o)}),await h.onIdle()}}),i>=r&&n.end()}const Ce=(t,e,n,i,s,r,o)=>async function*(i={}){var s,r;const a=n.fileSize();if(void 0===a)throw new Error("File was a directory");const{start:c,end:l}=Ie(a,i.offset,i.length);if(0n===l)return;let h=0n;const d=l-c,u=U();null==(s=i.onProgress)||s.call(i,new B("unixfs:exporter:walk:file",{cid:t})),Re(o,e,u,0n,c,l,i).catch(t=>{u.end(t)});for await(const t of u)if(null!=t){if(h+=BigInt(t.byteLength),h>d)throw u.end(),new ke("Read too many bytes - the file size reported by the UnixFS data in the root node may be incorrect");h===d&&u.end(),null==(r=i.onProgress)||r.call(i,new B("unixfs:exporter:progress:unixfs:file",{bytesRead:h,totalBytes:d,fileSize:a})),yield t}if(h<d)throw new Be("Traversed entire DAG but did not read enough bytes")};async function*Fe(t,e,n,i,s,r){const o=t.Links;if(null==t.Data)throw new be("no data in PBNode");let a;try{a=it.unmarshal(t.Data)}catch(h){throw new be(h.message)}if(null==a.fanout)throw new be("missing fanout");const c=(a.fanout-1n).toString(16).length,l=F(o,o=>u(o,o=>async()=>{var a;const l=null!=o.Name?o.Name.substring(c):null;if(null!=l&&""!==l){const t=`${e}/${l}`;if(Ae(r)){return{entries:[{cid:o.Hash,name:l,path:t}]}}return{entries:[(await n(o.Hash,l,t,[],i+1,s,r)).entry].filter(Boolean)}}{const c=await s.get(o.Hash,r);return t=d(c),null==(a=r.onProgress)||a.call(r,new B("unixfs:exporter:walk:hamt-sharded-directory",{cid:o.Hash})),{entries:Fe(t,e,n,i,s,r)}}}),t=>A(t,{ordered:!0,concurrency:r.blockReadConcurrency}));for await(const{entries:d}of l)yield*d}const Ue={raw:Ce,file:Ce,directory:(t,e,n,i,s,r,o)=>async function*(n={}){var a;const c=n.offset??0,l=n.length??e.Links.length,h=e.Links.slice(c,l);null==(a=n.onProgress)||a.call(n,new B("unixfs:exporter:walk:directory",{cid:t})),yield*F(h,t=>u(t,t=>async()=>{const e=t.Name??"",a=`${i}/${e}`;if(Ae(n)){return{cid:t.Hash,name:e,path:a}}return(await s(t.Hash,e,a,[],r+1,o,n)).entry}),t=>A(t,{ordered:!0,concurrency:n.blockReadConcurrency}),t=>E(t,t=>null!=t))},"hamt-sharded-directory":(t,e,n,i,s,r,o)=>function(n={}){var a;return null==(a=n.onProgress)||a.call(n,new B("unixfs:exporter:walk:hamt-sharded-directory",{cid:t})),Fe(e,i,s,r,o,n)},metadata:(t,e,n,i,s,r,o)=>()=>[],symlink:(t,e,n,i,s,r,o)=>()=>[]},He={[f]:async(t,e,n,i,s,r,o,a)=>{if(Ae(a)){return{entry:{cid:t,name:e,path:n}}}const c=await o.get(t,a),l=d(c);let h,u;if(null==e&&(e=t.toString()),null==l.Data)throw new be("no data in PBNode");try{h=it.unmarshal(l.Data)}catch(y){throw new be(y.message)}if(null==n&&(n=e),i.length>0){let t;if(t="hamt-sharded-directory"===(null==h?void 0:h.type)?await Ee(l,i[0],o):((t,e)=>{const n=t.Links.find(t=>t.Name===e);return null==n?void 0:n.Hash})(l,i[0]),null==t)throw new pe("file does not exist");const e=i.shift();u={cid:t,toResolve:i,name:e??"",path:`${n}/${e}`}}const f=Ue[h.type](t,l,h,n,s,r,o);if(null==f)throw new pe("could not find content exporter");return h.isDirectory()?{entry:{type:"directory",name:e,path:n,cid:t,content:f,unixfs:h,depth:r,node:l,size:h.fileSize()},next:u}:{entry:{type:"file",name:e,path:n,cid:t,content:f,unixfs:h,depth:r,node:l,size:h.fileSize()},next:u}},[a]:async(t,e,n,i,s,r,o,a)=>{if(i.length>0)throw new pe(`No link named ${n} found in raw node ${t}`);const c=await o.get(t,a);return{entry:{type:"raw",name:e,path:n,cid:t,content:(l=c,async function*(t={}){var e;const{start:n,end:i}=Ie(l.length,t.offset,t.length),s=Le(l,0n,n,i);null==(e=t.onProgress)||e.call(t,new B("unixfs:exporter:progress:raw",{bytesRead:BigInt(s.byteLength),totalBytes:i-n,fileSize:BigInt(l.byteLength)})),yield s}),depth:r,size:BigInt(c.length),node:c}};var l},[p]:async(t,e,n,i,s,r,o,a)=>{const c=await o.get(t,a);return De(l(c),c,t,e,n,i,r)},[y]:async(t,e,n,i,s,r,o,a)=>{const c=await o.get(t,a);return De(h(c),c,t,e,n,i,r)},[P.code]:async(t,e,n,i,s,r,o,a)=>{if(i.length>0)throw new pe(`No link named ${n} found in raw node ${t}`);const c=D(t.multihash.bytes);return{entry:{type:"identity",name:e,path:n,cid:t,content:(l=c.digest,async function*(t={}){var e;const{start:n,end:i}=Ie(l.length,t.offset,t.length),s=Le(l,0n,n,i);null==(e=t.onProgress)||e.call(t,new B("unixfs:exporter:progress:identity",{bytesRead:BigInt(s.byteLength),totalBytes:i-n,fileSize:BigInt(l.byteLength)})),yield s}),depth:r,size:BigInt(c.digest.length),node:c.digest}};var l},[I]:async(t,e,n,i,s,r,o,a)=>{const c=await o.get(t,a);return De(L(c),c,t,e,n,i,r)}},Me=async(t,e,n,i,s,r,o)=>{const a=He[t.code];if(null==a)throw new we(`No resolver for code ${t.code}`);return a(t,e,n,i,Me,s,r,o)},$e=t=>{if(t instanceof Uint8Array)return{cid:v.decode(t),toResolve:[]};const e=v.asCID(t);if(null!=e)return{cid:e,toResolve:[]};if("string"==typeof t){0===t.indexOf("/ipfs/")&&(t=t.substring(6));const e=((t="")=>(t.trim().match(/([^\\^/]|\\\/)+/g)??[]).filter(Boolean))(t);return{cid:v.parse(e[0]),toResolve:e.slice(1)}}throw new fe(`Unknown path type ${t}`)};async function*Ve(t,e,n={}){let{cid:i,toResolve:s}=$e(t),r=i.toString(),o=r;const a=s.length;for(;;){const c=await Me(i,r,o,s,a,e,n);if(null==c.entry&&null==c.next)throw new pe(`Could not resolve ${t}`);if(null!=c.entry&&(yield c.entry),null==c.next)return;s=c.next.toResolve,i=c.next.cid,r=c.next.name,o=c.next.path}}async function Oe(t,e,n={}){const i=await Qt(Ve(t,e,n));if(null==i)throw new pe(`Could not resolve ${t}`);return i}async function*je(t,e,n={}){const i=await Oe(t,e,n);if(null!=i&&(yield i,"directory"===i.type))for await(const s of async function*t(e,n){for await(const i of e.content(n))yield i,i instanceof Uint8Array||"directory"===i.type&&(yield*t(i,n))}(i,n))yield s}function qe(t){return function(e){return e instanceof We?e:new We(e,t)}}class We{constructor(t,e){if(n(this,"_value"),n(this,"_hashFn"),n(this,"_depth"),n(this,"_availableBits"),n(this,"_currentBufferIndex"),n(this,"_buffers"),!(t instanceof Uint8Array))throw new Error("can only hash Uint8Arrays");this._value=t,this._hashFn=e,this._depth=-1,this._availableBits=0,this._currentBufferIndex=0,this._buffers=[]}async take(t){let e=t;for(;this._availableBits<e;)await this._produceMoreBits();let n=0;for(;e>0;){const t=this._buffers[this._currentBufferIndex],i=Math.min(t.availableBits(),e);n=(n<<i)+t.take(i),e-=i,this._availableBits-=i,0===t.availableBits()&&this._currentBufferIndex++}return n}untake(t){let e=t;for(;e>0;){const t=this._buffers[this._currentBufferIndex],n=Math.min(t.totalBits()-t.availableBits(),e);t.untake(n),e-=n,this._availableBits+=n,this._currentBufferIndex>0&&t.totalBits()===t.availableBits()&&(this._depth--,this._currentBufferIndex--)}}async _produceMoreBits(){this._depth++;const t=this._depth>0?N([this._value,Uint8Array.from([this._depth])]):this._value,e=await this._hashFn(t),n=new Ye(e);this._buffers.push(n),this._availableBits+=n.availableBits()}}const Ke=[255,254,252,248,240,224,192,128],Xe=[1,3,7,15,31,63,127,255];class Ye{constructor(t){n(this,"_value"),n(this,"_currentBytePos"),n(this,"_currentBitPos"),this._value=t,this._currentBytePos=t.length-1,this._currentBitPos=7}availableBits(){return this._currentBitPos+1+8*this._currentBytePos}totalBits(){return 8*this._value.length}take(t){let e=t,n=0;for(;e>0&&this._haveBits();){const t=this._value[this._currentBytePos],i=this._currentBitPos+1,s=Math.min(i,e);n=(n<<s)+Je(t,i-s,s),e-=s,this._currentBitPos-=s,this._currentBitPos<0&&(this._currentBitPos=7,this._currentBytePos--)}return n}untake(t){for(this._currentBitPos+=t;this._currentBitPos>7;)this._currentBitPos-=8,this._currentBytePos+=1}_haveBits(){return this._currentBytePos>=0}}function Je(t,e,n){const i=function(t,e){return Ke[t]&Xe[Math.min(e+t-1,7)]}(e,n);return(t&i)>>>e}const Qe=BigInt(Bt.code);async function Ge(t){return(await Bt.encode(t)).subarray(0,8).reverse()}const Ze=async(t,e,n)=>{null==n.codec&&(n.codec=i);const s=await k.digest(t),r=v.create(n.cidVersion,n.codec.code,s);return await e.put(r,t,{...n,signal:n.signal}),r};class tn{constructor(t,e){n(this,"options"),n(this,"root"),n(this,"dir"),n(this,"path"),n(this,"dirty"),n(this,"flat"),n(this,"parent"),n(this,"parentKey"),n(this,"unixfs"),n(this,"mode"),n(this,"mtime"),n(this,"cid"),n(this,"size"),n(this,"nodeSize"),this.options=e??{},this.root=t.root,this.dir=t.dir,this.path=t.path,this.dirty=t.dirty,this.flat=t.flat,this.parent=t.parent,this.parentKey=t.parentKey,this.unixfs=t.unixfs,this.mode=t.mode,this.mtime=t.mtime}}class en extends tn{constructor(t,e){super(t,e),n(this,"_bucket"),this._bucket=Ht({hashFn:Ge,bits:8})}async put(t,e){this.cid=void 0,this.size=void 0,this.nodeSize=void 0,await this._bucket.put(t,e)}async get(t){return this._bucket.get(t)}childCount(){return this._bucket.leafCount()}directChildrenCount(){return this._bucket.childrenCount()}onlyChild(){return this._bucket.onlyChild()}async*eachChildSeries(){for(const{key:t,value:e}of this._bucket.eachLeafSeries())yield{key:t,child:e}}estimateNodeSize(){return void 0!==this.nodeSize||(this.nodeSize=rn(this._bucket,this,this.options)),this.nodeSize}async*flush(t){for await(const e of nn(this._bucket,t,this,this.options))yield{...e,path:this.path}}}async function*nn(t,e,n,i){const r=t._children,a=[];let c=0n;for(let s=0;s<r.length;s++){const t=r.get(s);if(null==t)continue;const n=s.toString(16).toUpperCase().padStart(2,"0");if(t instanceof Lt){let s;for await(const n of nn(t,e,null,i))s=n;if(null==s)throw new Error("Could not flush sharded directory, no sub-shard found");a.push({Name:n,Tsize:Number(s.size),Hash:s.cid}),c+=s.size}else if(sn(t.value)){const i=t.value;let s;for await(const t of i.flush(e))s=t,yield s;if(null==s)throw new Error("Did not flush dir");const r=n+t.key;a.push({Name:r,Tsize:Number(s.size),Hash:s.cid}),c+=s.size}else{const e=t.value;if(null==e.cid)continue;const i=n+t.key,s=e.size;a.push({Name:i,Tsize:Number(s),Hash:e.cid}),c+=BigInt(s??0)}}const l=Uint8Array.from(r.bitField().reverse()),h=new it({type:"hamt-sharded-directory",data:l,fanout:BigInt(t.tableSize()),hashType:Qe,mtime:null==n?void 0:n.mtime,mode:null==n?void 0:n.mode}),d={Data:h.marshal(),Links:a},u=s(o(d)),f=await Ze(u,e,i),y=BigInt(u.byteLength)+c;yield{cid:f,unixfs:h,size:y}}function sn(t){return"function"==typeof t.flush}function rn(t,e,n){const i=t._children,r=[];for(let s=0;s<i.length;s++){const t=i.get(s);if(null==t)continue;const e=s.toString(16).toUpperCase().padStart(2,"0");if(t instanceof Lt){const i=rn(t,null,n);r.push({Name:e,Tsize:Number(i),Hash:0===n.cidVersion?on:an})}else if("function"==typeof t.value.flush){const i=t.value.nodeSize();r.push({Name:e+t.key,Tsize:Number(i),Hash:0===n.cidVersion?on:an})}else{const n=t.value;if(null==n.cid)continue;const i=e+t.key,s=n.size;r.push({Name:i,Tsize:Number(s),Hash:n.cid})}}const a=Uint8Array.from(i.bitField().reverse()),c=new it({type:"hamt-sharded-directory",data:a,fanout:BigInt(t.tableSize()),hashType:Qe,mtime:null==e?void 0:e.mtime,mode:null==e?void 0:e.mode});return s(o({Data:c.marshal(),Links:r})).length}const on=v.parse("QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn"),an=v.parse("zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi"),cn=$("helia:unixfs:commands:utils:hamt-utils"),ln=t=>t.toString(16).toUpperCase().padStart(2,"0").substring(0,2),hn=async(t,e,n)=>{const i=it.unmarshal(t[0].node.Data??new Uint8Array(0)),r=BigInt(Math.pow(2,8));let a,c;t.reverse();for(let l=0;l<t.length;l++){const h=l===t.length-1,d=t[l],u=Uint8Array.from(d.children.bitField().reverse()),f=new it({type:"hamt-sharded-directory",data:u,fanout:r,hashType:Qe});h&&(f.mtime=i.mtime,f.mode=i.mode),c={Data:f.marshal(),Links:d.node.Links};const y=s(o(c));if(a=await Ze(y,e,n),!h){const e=t[l+1];if(null==e)throw new Error("Was not operating on shard root but also had no parent?");cn("updating link in parent sub-shard with prefix %s",e.prefix),e.node.Links=e.node.Links.filter(t=>t.Name!==e.prefix),e.node.Links.push({Name:e.prefix,Hash:a,Tsize:d.node.Links.reduce((t,e)=>t+(e.Tsize??0),y.byteLength)})}}if(null==a||null==c)throw new Error("Noting persisted");return{cid:a,node:c}},dn=async(t,e,n,i)=>{const s=qe(Ge)(S(e)),r=[];for(;;){const o=await n.get(t,i),a=d(o),c=new Dt,l=await s.take(8),h=ln(l);let u;r.push({prefix:h,children:c,node:a});for(const t of a.Links){const e=t.Name??"";if(e.length<2)throw new Error("Invalid HAMT - link name was too short");const n=parseInt(e.substring(0,2),16);c.set(n,!0),e.startsWith(h)&&(u=t)}if(null==u){cn("no link found with prefix %s for %s",h,e);break}const f=u.Name??"";if(f.length<2)throw new Error("Invalid HAMT - link name was too short");if(2!==f.length)break;t=u.Hash,cn("descend into sub-shard with prefix %s",f)}return{path:r,hash:s}};async function un(t,e,n,i){if(null==t.Data)throw new Error("DagPB node had no data");const s=it.unmarshal(t.Data);let r;if("directory"===s.type)r=function(t){let e=0;for(const n of t.Links)e+=(n.Name??"").length,e+=1===n.Hash.version?an.bytes.byteLength:on.bytes.byteLength;return e}(t);else{if("hamt-sharded-directory"!==s.type)throw new Error("Can only estimate the size of directories or shards");r=await fn(t,0,n,e,i)}return r>n}async function fn(t,e,n,i,s){if(e>n)return n;if(null==t.Data)return e;if(!it.unmarshal(t.Data).isDirectory())return e;for(const r of t.Links){let t=r.Name??"";if(t=t.substring(2),e+=t.length,e+=r.Hash.bytes.byteLength,r.Hash.code===f){const t=await i.get(r.Hash,s),o=d(t);e+=await fn(o,e,n,i,s)}}return e}const yn=$("helia:unixfs:components:utils:add-link");async function pn(t,e,n,i){if(null==t.node.Data)throw new ae("Invalid parent passed to addLink");if("hamt-sharded-directory"===it.unmarshal(t.node.Data).type)return yn("adding link to sharded directory"),gn(t,e,n,i);yn(`adding ${e.Name} (${e.Hash}) to regular directory`);const s=await wn(t,e,n,i);if(await un(s.node,n,i.shardSplitThresholdBytes,i)){yn("converting directory to sharded directory");const t=await mn(s,n);s.cid=t.cid,s.node=d(await n.get(t.cid,i))}return s}const mn=async(t,e)=>{if(null==t.node.Data)throw new ae("Invalid parent passed to convertToShardedDirectory");const n=it.unmarshal(t.node.Data),i=await(async(t,e,n)=>{const i=new en({root:!0,dir:!0,parent:void 0,parentKey:void 0,path:"",dirty:!0,flat:!1,mtime:n.mtime,mode:n.mode},n);for(let r=0;r<e.length;r++)await i._bucket.put(e[r].name,{size:e[r].size,cid:e[r].cid});const s=await Qt(i.flush(t));if(null==s)throw new Error("Flushing shard yielded no result");return s})(e,t.node.Links.map(t=>({name:t.Name??"",size:BigInt(t.Tsize??0),cid:t.Hash})),{mode:n.mode,mtime:n.mtime,cidVersion:t.cid.version});return yn(`converted directory to sharded directory ${i.cid}`),i},wn=async(t,e,n,i)=>{const r=t.node.Links.filter(t=>{const n=t.Name===e.Name;if(n&&!i.allowOverwriting)throw new ne;return!n});if(r.push(e),null==t.node.Data)throw new te("Parent node with no data passed to addToDirectory");const a=it.unmarshal(t.node.Data);let c;if(null!=a.mtime){const t=Date.now(),e=Math.floor(t/1e3);a.mtime={secs:BigInt(e),nsecs:1e3*(t-1e3*e)},c=a.marshal()}else c=t.node.Data;t.node=o({Data:c,Links:r});const l=s(t.node),h=await k.digest(l),d=v.create(t.cid.version,f,h);return await n.put(d,l),{node:t.node,cid:d}},gn=async(t,e,n,i)=>{var s;const{path:r,hash:o}=await dn(t.cid,e.Name,n,i),a=r[r.length-1];if(null==a)throw new Error("Invalid HAMT, could not generate path");const c=a.prefix,l=parseInt(c,16);yn("next prefix for %s is %s",e.Name,c);const h=`${c}${e.Name}`,d=a.node.Links.find(t=>(t.Name??"").startsWith(c));if(null!=d)if(yn("link %s was present in shard",h),d.Name===h){if(!i.allowOverwriting)throw new ne;yn("overwriting %s in sub-shard",e.Name),a.node.Links=a.node.Links.filter(t=>t.Name!==h),a.node.Links.push({Name:h,Hash:e.Hash,Tsize:e.Tsize})}else{if(2===(null==(s=d.Name)?void 0:s.length))throw new Error("Existing link was sub-shard?!");{yn("prefix %s already exists, creating new sub-shard",c);const t=a.node.Links.findIndex(t=>{var e;return null==(e=t.Name)?void 0:e.startsWith(c)}),n=a.node.Links.splice(t,1)[0],i=(n.Name??"").substring(2),s=qe(Ge)(S(i));for(let e=0;e<r.length;e++)await s.take(8);for(;;){const t=await s.take(8),a=ln(t);n.Name=`${a}${i}`;const l=await o.take(8),h=ln(l);if(a===h){const t=new Dt;t.set(l,!0),r.push({prefix:h,children:t,node:{Links:[]}});continue}const d=new Dt;d.set(l,!0),d.set(t,!0),r.push({prefix:c,children:d,node:{Links:[n,{Name:`${h}${e.Name}`,Hash:e.Hash,Tsize:e.Tsize}]}});break}}}else yn("link %s was not present in sub-shard",h),e.Name=h,a.node.Links.push(e),a.children.set(l,!0),yn("adding %s to existing sub-shard",h);return hn(r,n,i)};async function bn(t,e,n={}){const i=await Oe(t,e,n);if("directory"!==i.type)throw new oe(`${t.toString()} was not a UnixFS directory`);return{cid:t,node:i.node}}async function _n(t,e,n,i){const s=await Oe(t,n,i);if("directory"!==s.type&&"file"!==s.type&&"raw"!==s.type)throw new Zt(`${t.toString()} was not a UnixFS node`);return{Name:e,Tsize:s.node instanceof Uint8Array?s.node.byteLength:kn(s.node),Hash:t}}function kn(t){const e=t.Links.reduce((t,e)=>t+(e.Tsize??0),0);return s(t).byteLength+e}const vn=$("helia:unixfs:components:utils:resolve");async function Bn(t,e,n,i){if(null==e||""===e)return{cid:t};const s=`/ipfs/${t}${null==e?"":`/${e}`}`,r=await R(Ve(s,n,i));if(0===r.length)throw new ie("Could not find path in directory");return vn("resolved %s to %c",e,t),{cid:r[r.length-1].cid,path:e,segments:r}}async function Sn(t,e,n,i){if(null==e.segments||0===e.segments.length)return t;let s=e.segments.pop();if(null==s)throw new Error("Insufficient segments");s.cid=t,e.segments.reverse();for(const r of e.segments){const[e,o]=await Promise.all([bn(r.cid,n,i),_n(s.cid,s.name,n,i)]);t=(await pn(e,o,n,{...i,allowOverwriting:!0,cidVersion:t.version})).cid,r.cid=t,s=r}return t}const xn=C.bind({ignoreUndefined:!0}),zn={};const Nn=262144,Dn=C.bind({ignoreUndefined:!0}),Ln=$("helia:unixfs:chmod"),In={recursive:!1,shardSplitThresholdBytes:Nn};const Pn=C.bind({ignoreUndefined:!0}),Tn=$("helia:unixfs:cp"),En={force:!1,shardSplitThresholdBytes:Nn};const An=C.bind({ignoreUndefined:!0}),Rn={};const Cn=C.bind({ignoreUndefined:!0}),Fn=$("helia:unixfs:mkdir"),Un={cidVersion:1,force:!1,shardSplitThresholdBytes:Nn};const Hn=$("helia:unixfs:utils:remove-link");const Mn=async(t,e,n,i)=>{t.node.Links=t.node.Links.filter(t=>t.Name!==e);const r=s(t.node),o=await Ze(r,n,{...i,cidVersion:t.cid.version});return Hn(`Updated regular directory ${o}`),{node:t.node,cid:o}},$n=async(t,e,n,i)=>{const{path:s}=await dn(t.cid,e,n,i),r=s[s.length-1];if(null==r)throw new Error("Invalid HAMT, could not generate path");const o=r.node.Links.filter(t=>(t.Name??"").substring(2)===e).map(t=>t.Name).pop();if(null==o)throw new Error("File not found");const a=o.substring(0,2),c=parseInt(a,16);if(r.node.Links=r.node.Links.filter(t=>t.Name!==o),r.children.unset(c),1===r.node.Links.length)for(;1!==s.length;){const t=s[s.length-1];if(null==t||t.node.Links.length>1)break;s.pop();const e=s[s.length-1];if(null==e)break;const n=t.node.Links[0];e.node.Links=e.node.Links.filter(t=>!(t.Name??"").startsWith(e.prefix)),e.node.Links.push({Hash:n.Hash,Name:`${e.prefix}${(n.Name??"").substring(2)}`,Tsize:n.Tsize})}return hn(s,n,i)},Vn=async(t,e,n)=>{if(null==t.node.Data)throw new ae("Invalid parent passed to convertToFlatDirectory");const r={Links:[]},a=await Oe(t.cid,e);if("directory"!==a.type)throw new Error("Unexpected node type");for await(const i of a.content()){let t=0;t=i.node instanceof Uint8Array?i.node.byteLength:s(i.node).length,r.Links.push({Hash:i.cid,Name:i.name,Tsize:t})}const c=it.unmarshal(t.node.Data);r.Data=new it({type:"directory",mode:c.mode,mtime:c.mtime}).marshal();const l=s(o(r));return{cid:await Ze(l,e,{codec:i,cidVersion:t.cid.version,signal:n.signal}),node:r}},On=C.bind({ignoreUndefined:!0}),jn=$("helia:unixfs:rm"),qn={shardSplitThresholdBytes:Nn};async function Wn(t,e,n,i={}){const s=On(qn,i);if(e.includes("/"))throw new ae("Name must not have slashes");const r=await bn(t,n,s);jn("Removing %s from %c",e,t);const o=await async function(t,e,n,i){if(null==t.node.Data)throw new te("Parent node had no data");if("hamt-sharded-directory"===it.unmarshal(t.node.Data).type){Hn(`removing ${e} from sharded directory`);const s=await $n(t,e,n,i);return await un(s.node,n,i.shardSplitThresholdBytes,i)?s:(Hn("converting shard to flat directory %c",t.cid),Vn(s,n,i))}return Hn(`removing link ${e} regular directory`),Mn(t,e,n,i)}(r,e,n,{...s,cidVersion:t.version});return o.cid}const Kn=1877,Xn=1604,Yn=C.bind({ignoreUndefined:!0}),Jn=$("helia:unixfs:stat"),Qn={};async function Gn(t,e,n={}){const i=Yn(Qn,n),s=await Bn(t,n.path,e,i);Jn("stat %c",s.cid);const r=await Oe(s.cid,e,i);if("raw"===r.type)return!0===n.extended?{type:(o=r).type,cid:o.cid,unixfs:void 0,mode:Xn,mtime:void 0,size:BigInt(o.node.byteLength),localSize:BigInt(o.node.byteLength),dagSize:BigInt(o.node.byteLength),deduplicatedDagSize:BigInt(o.node.byteLength),blocks:1n,uniqueBlocks:1n}:function(t){return{type:t.type,cid:t.cid,unixfs:void 0,mode:Xn,mtime:void 0,size:BigInt(t.node.byteLength)}}(r);if("file"===r.type||"directory"===r.type)return!0===n.extended?async function(t,e,n,i){const s=await Zn(t.cid,e,!1,n,i);return{type:t.type,cid:t.cid,unixfs:t.unixfs,size:t.unixfs.isDirectory()?s.dirSize:t.unixfs.fileSize(),mode:t.unixfs.mode??(t.unixfs.isDirectory()?Kn:Xn),mtime:t.unixfs.mtime,localSize:s.localSize,dagSize:s.dagSize,deduplicatedDagSize:s.deduplicatedDagSize,blocks:s.blocks,uniqueBlocks:s.uniqueBlocks}}(r,e,n.filter??new H({filterSize:1024}),n):function(t){return{type:t.type,cid:t.cid,unixfs:t.unixfs,mode:t.unixfs.mode??(t.unixfs.isDirectory()?Kn:Xn),mtime:t.unixfs.mtime,size:t.unixfs.fileSize()}}(r);var o;throw new Zt}async function Zn(t,e,n,i,s){const r={dirSize:0n,localSize:0n,dagSize:0n,deduplicatedDagSize:0n,blocks:0n,uniqueBlocks:0n};try{const o=i.has(t.bytes);i.add(t.bytes);const c=await e.get(t,s);if(r.blocks++,r.dagSize+=BigInt(c.byteLength),o||(r.uniqueBlocks++,r.deduplicatedDagSize+=BigInt(c.byteLength)),t.code===a)r.localSize+=BigInt(c.byteLength),n&&(r.dirSize+=BigInt(c.byteLength));else{if(t.code!==f)throw new ee(`${t.toString()} was neither DAG_PB nor RAW`);{const o=d(c);let a;if(null!=o.Data&&(a=it.unmarshal(o.Data)),o.Links.length>0){for(const t of o.Links){const n=await Zn(t.Hash,e,ti(t,a),i,s);r.localSize+=n.localSize,r.dagSize+=n.dagSize,r.deduplicatedDagSize+=n.deduplicatedDagSize,r.blocks+=n.blocks,r.uniqueBlocks+=n.uniqueBlocks,r.dirSize+=n.dirSize}n&&null!=a&&(r.dirSize+=a.fileSize())}else{if(null==a)throw new te(`PBNode ${t.toString()} had no data`);null!=a.data&&(r.localSize+=BigInt(a.data.byteLength??0)),n&&(r.dirSize+=a.fileSize())}}}}catch(o){if("NotFoundError"!==o.name||!0!==s.offline)throw o}return r}function ti(t,e){if(null==e)return!1;const n=t.Name;return null!=n&&("directory"===e.type||"hamt-sharded-directory"===e.type&&n.length>2)}const ei=C.bind({ignoreUndefined:!0}),ni=$("helia:unixfs:touch"),ii={recursive:!1,shardSplitThresholdBytes:Nn};class si{constructor(t){n(this,"components"),this.components=t}async*addAll(t,e={}){yield*le(t,this.components.blockstore,e)}async addBytes(t,e={}){return he(t,this.components.blockstore,e)}async addByteStream(t,e={}){return de(t,this.components.blockstore,e)}async addFile(t,e={}){return async function(t,e,n={}){if(null==t.path)throw new ae("path is required");if(null==t.content)throw new ae("content is required");const i=await Qt(le([t],e,{...ce,...n,wrapWithDirectory:!0}));if(null==i)throw new ae("Nothing imported");return i.cid}(t,this.components.blockstore,e)}async addDirectory(t={},e={}){return async function(t,e,n={}){if(null!=t.content)throw new ae("Directories cannot have content, use addFile instead");const i=null==t.path?c:Qt,s=await i(le([{...t,path:t.path??"-"}],e,{...ce,...n,wrapWithDirectory:null!=t.path}));if(null==s)throw new ae("Nothing imported");return s.cid}(t,this.components.blockstore,e)}async*cat(t,e={}){yield*async function*(t,e,n={}){const i=xn(zn,n),s=await Bn(t,i.path,e,i),r=await Oe(s.cid,e,i);if("file"!==r.type&&"raw"!==r.type)throw new re;if(null==r.content)throw new se;yield*r.content(i)}(t,this.components.blockstore,e)}async chmod(t,e,n={}){return async function(t,e,n,i={}){const r=Dn(In,i),o=await Bn(t,r.path,n,i);if(Ln("chmod %c %d",o.cid,e),r.recursive){const a=await F(async function*(){for await(const t of je(o.cid,n,i)){let n,i=[];if("raw"===t.type)n=new it({type:"file",data:t.node});else{if("file"!==t.type&&"directory"!==t.type)throw new Zt;n=t.unixfs,i=t.node.Links}n.mode=e;const s={Data:n.marshal(),Links:i};yield{path:t.path,content:s}}},e=>Yt(e,n,{...r,dagBuilder:async function*(e,n){for await(const i of e)yield async function(){const e=i.content,o=s(e),a=await Ze(o,n,{...r,cidVersion:t.version});if(null==e.Data)throw new te(`${a} had no data`);const c=it.unmarshal(e.Data);return{cid:a,size:BigInt(o.length),path:i.path,unixfs:c}}}}),async t=>Qt(t));if(null==a)throw new ee(`Could not chmod ${o.cid.toString()}`);return Sn(a.cid,o,n,r)}const c=await n.get(o.cid,i);let l,h=[];if(o.cid.code===a)l=new it({type:"file",data:c});else{const t=d(c);if(null==t.Data)throw new te(`${o.cid.toString()} had no data`);h=t.Links,l=it.unmarshal(t.Data)}l.mode=e;const u=s({Data:l.marshal(),Links:h}),y=await k.digest(u),p=v.create(o.cid.version,f,y);return await n.put(p,u),Sn(p,o,n,r)}(t,e,this.components.blockstore,n)}async cp(t,e,n,i={}){return async function(t,e,n,i,s={}){const r=Pn(En,s);if(n.includes("/"))throw new ae("Name must not have slashes");const[o,a]=await Promise.all([bn(e,i,r),_n(t,n,i,r)]);return Tn('Adding %c as "%s" to %c',t,n,e),(await pn(o,a,i,{allowOverwriting:r.force,cidVersion:e.version,...r})).cid}(t,e,n,this.components.blockstore,i)}async*ls(t,e={}){yield*async function*(t,e,n={}){const i=An(Rn,n),s=await Bn(t,i.path,e,i),r=await Oe(s.cid,e);if("file"!==r.type&&"raw"!==r.type){if(null==r.content)throw new se;if("directory"!==r.type)throw new oe;yield*r.content({offset:n.offset,length:n.length})}else yield r}(t,this.components.blockstore,e)}async mkdir(t,e,n={}){return async function(t,e,n,i={}){const r=Cn(Un,i);if(e.includes("/"))throw new ae("Path must not have slashes");if("directory"!==(await Oe(t,n,i)).type)throw new oe(`${t.toString()} was not a UnixFS directory`);Fn("creating %s",e);const o={Data:new it({type:"directory",mode:r.mode,mtime:r.mtime}).marshal(),Links:[]},a=s(o),c=await k.digest(a),l=v.create(r.cidVersion,f,c);await n.put(l,a);const[h,d]=await Promise.all([bn(t,n,r),_n(l,e,n,r)]);return Fn("adding empty dir called %s to %c",e,t),(await pn(h,d,n,{...r,allowOverwriting:r.force})).cid}(t,e,this.components.blockstore,n)}async rm(t,e,n={}){return Wn(t,e,this.components.blockstore,n)}async stat(t,e={}){return Gn(t,this.components.blockstore,e)}async touch(t,e={}){return async function(t,e,n={}){const i=ei(ii,n),r=await Bn(t,i.path,e,i),o=i.mtime??{secs:BigInt(Math.round(Date.now()/1e3)),nsecs:0};if(ni("touch %c %o",r.cid,o),i.recursive){const n=await F(async function*(){for await(const t of je(r.cid,e)){let e,n;if("raw"===t.type)e=new it({data:t.node}),n=[];else{if("file"!==t.type&&"directory"!==t.type)throw new Zt;e=t.unixfs,n=t.node.Links}e.mtime=o;const i={Data:e.marshal(),Links:n};yield{path:t.path,content:i}}},n=>Yt(n,e,{...i,dagBuilder:async function*(e,n){for await(const r of e)yield async function(){const e=r.content,o=s(e),a=await Ze(o,n,{...i,cidVersion:t.version});if(null==e.Data)throw new te(`${a} had no data`);const c=it.unmarshal(e.Data);return{cid:a,size:BigInt(o.length),path:r.path,unixfs:c}}}}),async t=>Qt(t));if(null==n)throw new ee(`Could not chmod ${r.cid.toString()}`);return Sn(n.cid,r,e,i)}const c=await e.get(r.cid,n);let l,h=[];if(r.cid.code===a)l=new it({data:c});else{const t=d(c);if(h=t.Links,null==t.Data)throw new te(`${r.cid.toString()} had no data`);l=it.unmarshal(t.Data)}l.mtime=o;const u=s({Data:l.marshal(),Links:h}),y=await k.digest(u),p=v.create(r.cid.version,f,y);return await e.put(p,u),Sn(p,r,e,i)}(t,this.components.blockstore,e)}}async function*ri(){throw new Error("Not supported in browsers")}function oi(t,e){return t=new URL(t),{path:decodeURIComponent(new URL(t).pathname.split("/").pop()??""),content:ai(t,e)}}async function*ai(t,e){const n=await globalThis.fetch(t,e);if(null==n.body)throw new ee("HTTP response did not have a body");const i=n.body.getReader();try{for(;;){const{done:t,value:e}=await i.read();if(t)return;null!=e&&(yield e)}}finally{i.releaseLock()}}function ci(t){return new si(t)}export{ri as globSource,ci as unixfs,oi as urlSource};
